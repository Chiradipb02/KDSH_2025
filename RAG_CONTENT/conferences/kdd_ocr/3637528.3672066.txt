A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in
Large Sparse Graphs
Ahsanur Rahman
ahsanur.rahman@northsouth.edu
North South University
Dhaka, BangladeshKalyan Roy
kalyan.roy@northsouth.edu
North South University
Dhaka, Bangladesh
Ramiza Maliha
ramiza.maliha@northsouth.edu
North South University
Dhaka, BangladeshTownim Faisal Chowdhury
townim.chowdhury@adelaide.edu.au
Australian Institute for Machine Learning
University of Adelaide, Adelaide, Australia
Abstract
Pseudo-cliques (subgraphs with almost all possible edges) have
many applications. But they do not satisfy the convertible anti-
monotone constraint (as we prove here). So, it is hard to reduce
the search space of pseudo-cliques and list them efficiently. To our
knowledge, only two exact algorithms, namely, ODES and PCE,
were proposed for this purpose, but both have high execution times.
Here, we present an exact algorithm named Fast Pseudo-Clique Enu-
merator (FPCE). It employs some pruning techniques we derived to
reduce the search space. Our experiment on 15real and 16synthetic
graphs shows that (i) on real graphs, FPCE is, on average, 38.6and
6.5times faster than ODES and PCE, respectively, whereas (ii) on
synthetic graphs, FPCE is, on average, 39.7and3.1times faster
than ODES and PCE, respectively. We apply FPCE and a popular
heuristic method on a PPI network to identify pseudo-cliques. FPCE
outputs match with more known protein complexes, are more ac-
curate, and are biologically more significant ‚Äì suggesting that the
exact computation of pseudo-cliques may give better insights. For
its speed, FPCE is a suitable choice in such cases.
CCS Concepts
‚Ä¢Mathematics of computing ‚ÜíGraph algorithms.
Keywords
graph clustering, pseudo-clique, quasi-clique, dense subgraph
ACM Reference Format:
Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowd-
hury. 2024. A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques
in Large Sparse Graphs. In Proceedings of the 30th ACM SIGKDD Con-
ference on Knowledge Discovery and Data Mining (KDD ‚Äô24), August 25‚Äì
29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3637528.3672066
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
¬©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.36720661 Introduction
Graphs, a.k.a. networks, are often used to model real-world objects
and their mutual interactions. For example, social networks rep-
resent social relations among people; web graphs represent links
between web pages; protein-protein interaction (PPI) networks
describe mutual interactions among proteins; etc. Densely inter-
connected subgraphs of such networks are useful to identify social
communities from social networks [ 12], protein complexes from PPI
networks [ 15], link spams from web networks [ 37], etc. Different
research devised different formulations to define such subgraphs
and used different terms to indicate them. Unfortunately, the litera-
ture uses these terms inconsistently (Section 2). Here, we use the
term dense subgraph to indicate any definition of such a subgraph.
Motivation: Although a lot of research has been conducted
on dense subgraph mining [ 23], to our knowledge (as shown in
Section 2 and as noted by some others [ 30,46]), most of them either
(i) focus on heuristic algorithms ‚Äì which do not guarantee to find
all dense subgraphs correctly, or (ii) define dense subgraphs in ways
that allow them to develop fast exact algorithms for finding those.
To our knowledge, only two exact algorithms employ a natural
definition of dense subgraphs: a subgraph in which almost all possi-
ble edges are present (Figure 1). This definition of dense subgraphs
(henceforth called pseudo-cliques following [ 45]) is useful to iden-
tify protein complexes [ 28,33], co-regulated proteins [ 22], disease-
related circRNAs [ 50], Schizophrenia risk genes [ 25], COVID19
drugs [ 13], etc. In absence of efficient exact algorithms, these works
rely on heuristic algorithms to compute pseudo-cliques ‚Äì which
hinders them from judging the actual potential of pseudo-cliques in
these applications. Here, we address these issues by (i) developing
a fast, exact algorithm to list all maximal pseudo-cliques in a graph
and (ii) evaluating its performance and the quality of its outputs.
Contributions. We made the following contributions here.
(1)We prove that "pseudo-cliqueness" is not a convertible anti-
monotone property. So, algorithms available for mining pat-
terns with anti-monotone or convertible anti-monotone prop-
erty are not applicable to pseudo-cliques (Section 4).
(2)We derive some pruning techniques to prune the search-
space of pseudo-cliques (Sections 4 and 5, Appendix B).
(3)We integrate these techniques with an algorithm [ 45] to
design an exact algorithm for listing pseudo-cliques. We call
itFast Pseudo-Clique Enumerator orFPCE, in short (Section 5).
 
2479
KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
(4)We derive a tighter (than that based on [ 45]) bound on the
time complexity of FPCE. Our analysis is much more detailed
and, so, is easier to understand (Section 5, Appendix C).
(5)Our experiment on 16 synthetic and 15 real graphs shows
that FPCE is always faster than its competitors (Section 8).
(6)Our ablation study shows that all pruning techniques of
FPCE are useful for its speedup (Section 9).
(7)We compare the quality of pseudo-cliques found by FPCE
from a PPI network with (i) those found by a popular heuris-
tic approach and (ii) degree-based quasi-cliques (another defi-
nition of dense subgraphs, see Section 2). FPCE outputs are
found to be more biologically interesting (Section 10).
Intuition: Our pruning Techniques are based on our observation
that each pseudo-clique has a certain maximum order, contains a
certainùëü-clique, and can be extended from a smaller pseudo-clique
only if its edge count and minimum degree are high enough. If any
of these conditions are violated, we stop growing the pseudo-clique.
Scope: We focus on sparse graphs only since no exact algorithm
can list pseudo-cliques from dense graphs efficiently (Section 8).
2 Related Work
Dealing with Inconsistent Terminology Usage in Literature:
Finding works that use our definition of pseudo-cliques is compli-
cated due to the discrepancy of terminology usage in the literature.
Some papers use the term quasi-clique [ 21,44], dense-subgraph [ 26], or
near-clique [ 8,43] to mean pseudo-cliques while some others use these
terms to mean some other definitions of dense subgraphs [ 18,32,37].
For example, different papers use quasi-clique to mean at least three
different notions: (i) a pseudo-clique [ 21,44], (ii) a subgraph induced
by a node-set ùëÜin which each node‚Äôs degree is at least ùõº(|ùëÜ|‚àí1)
whereùõºis a user-given threshold [ 6,51] (we call it Degree-based
Quasi-clique, following [ 34,41]), and (iii) a subgraph whose average
degree is greater than a threshold [ 37] (we call it Average-degree-
based Quasi-clique ). So, to find all relevant papers, we searched
for literature mentioning any of these words and looked at papers
citing those works. However, a comprehensive review of all such
papers is beyond the scope of this paper (see [ 16,23] for this pur-
pose). Here, we only review algorithms to find pseudo-cliques ‚Äì no
matter what terms were used to denote them in the respective work.
We also discuss some other notable related work to highlight the
difference between our and their definitions of dense subgraphs.
Non-exact Algorithms: Abello et al. [ 1] designed a greedy
randomized adaptive search procedure (GRASP) to find maximal
pseudo-cliques in a graph. A greedy heuristic was proposed in [ 6] to
compute the largest degree-based quasi-clique. Two stochastic local
search algorithms were proposed in [ 9] to find maximal subgraphs
that satisfy requirements of both pseudo-cliques and degree-based
quasi-cliques. Another local search algorithm was described in [ 11]
to find the maximum pseudo-clique. Tsourakakis et al. [ 44] defined
an objective function that generalizes notions of both average-
degree-based quasi-cliques and pseudo-cliques as well as devised
two non-exact algorithms to find the subgraph achieving the highest
value of that function. A distributed algorithm was described in [ 8]
that can find a single pseudo-clique (having a theoretically proven
minimum density) in a graph with high probability. But it cannot
find pseudo-cliques with a given minimum density and minimum
order thresholds. Also, it is not exact and was never implemented.Exact Algorithms for Finding the Maximum Pseudo-clique:
The first exact algorithm to find the largest pseudo-clique in an
input graph was proposed by Pattillo et al. [ 35]. They designed two
mixed integer programming (MIP) formulations to solve this prob-
lem. Four alternative MIP formulations for the same problem were
proposed in [ 46]. It was also solved by Pajouh et al. [ 29] via a DFS-
based branch-and-bound algorithm. Finally, Marinelli et al. [ 30]
solved it via a branch-and-price algorithm.
Exact Algorithms for Other Related Problems: A fixed-
parameter algorithm was proposed in [ 20] to find the densest sub-
graph withùëònodes. A flow-based algorithm was proposed in [ 14]
to find the largest subgraph with the highest average degree. A
DFS-based exact algorithm, called Quick, was proposed in [ 24]
that lists all maximal degree-based quasi-cliques in a graph. Ko-
musiewicz et al. [ 21] designed a DFS-based branch-and-bound al-
gorithm to find a single pseudo-clique of order ùëò(a user input).
While these are important problems, algorithms to solve them
cannot be easily adapted to efficiently find all the maximal pseudo-
cliques in a graph ‚Äî which is the goal of our work.
Exact Algorithms for Finding All Maximal Pseudo-cliques:
We found only two exact algorithms for solving this problem for a
graph: Overlapping dense subgraph (ODES) [ 26] and Pseudo Clique
Enumerator (PCE) [ 45]. ODES is a BFS-like search algorithm that
maintains a queue of all the order- ùëòpseudo-cliques found so far and
tries to grow each of these pseudo-cliques in the next iteration to
find all the order-(ùëò+1)pseudo-cliques. ODES continues growing
each pseudo-clique in the queue as long as it satisfies the minimum-
density constraint. To maintain such a large queue, ODES needs a
huge memory. PCE, on the other hand, is a reverse-search [ 3] based
(DFS-like) recursive method that continues growing the current
pseudo-clique as long as the minimum-density constraint is satisfied
and reports it when it becomes a maximal pseudo-clique.
3 Notations and Definitions
Table 1 lists our notations. We formally define pseudo-clique below.
Definition 1. ùúÉ-Pseudo-Clique: For a given threshold ùúÉwith
0‚â§ùúÉ‚â§1, a node-set ùëÉwith|ùëÉ|‚â•2is called aùúÉ-pseudo-clique if its
density,ùëëùëíùëõ(ùëÉ)‚â•ùúÉ.
Usually, we are interested in large pseudo-cliques. The following
definitions allow us to incorporate these requirements.
Definition 2.(‚Ñì,ùúÉ)-Pseudo-Clique: LetùúÉand‚Ñìbe two given
thresholds where 0‚â§ùúÉ‚â§1and‚Ñì‚â•2. ThenùëÉis called a(‚Ñì,ùúÉ)-
pseudo-clique if ùëëùëíùëõ(ùëÉ)‚â•ùúÉand|ùëÉ|‚â•‚Ñì.
Definition 3. Maximal(‚Ñì,ùúÉ)-Pseudo-Clique: ùëÉis called a
maximal(‚Ñì,ùúÉ)-pseudo-clique if ùëÉis a(‚Ñì,ùúÉ)-pseudo-clique and there
is no(‚Ñì,ùúÉ)-pseudo-clique ùëÑ, such thatùëÉ‚äÇùëÑ.
We aim to design a fast algorithm to solve the problem below.
Problem: Enumerate all maximal (‚Ñì,ùúÉ)-pseudo-cliques in a sparse
graph for a given density threshold ùúÉand order threshold ‚Ñì.
Basic Algorithm: Explore all subgraphs in a given graph and
report the ones that are maximal (‚Ñì,ùúÉ)-pseudo-cliques.
To systematically enumerate these subgraphs without visiting
the same subgraph twice, we want to represent each subgraph by a
unique order of its vertices. We define two such orderings below.
 
2480A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
Table 1: Notations
Symbol Meaning/Definition
ùê∫ Undirected graph with vertex set ùëâand edge set ùê∏
ùê∫[ùëÉ] Subgraph induced by the set of vertices ùëÉ‚äÜùëâ
ùê∏[ùëÉ] Set of edges in ùê∫[ùëÉ]
ùêæùëü Anùëü-clique
ùëë(ùë£) Degree of vertex ùë£in the whole graph ùê∫
ùëëùëÉ(ùë£) Degree of vertex ùë£inùê∫[ùëÉ]
ùëëùëéùë£(ùëÉ)Average vertex-degree of ùê∫[ùëÉ]=2|ùê∏[ùëÉ]|/|ùëÉ|
ùõø(ùëÉ) Minimum degree of ùê∫[ùëÉ]=ùëöùëñùëõ{ùëëùëÉ(ùë£):ùë£‚ààùëÉ}
ùëÅ(ùë£) Set of all neighbors of ùë£inùê∫
ùê∂ùëò(ùê∫)ùëò-core of graph ùê∫=ùëéùëüùëîùëöùëéùë•ùëÉ‚äÜùëâ{|ùëÉ|:ùõø(ùëÉ)‚â•ùëò}
ùê∂ùëò(ùëÉ)ùëò-core of subgraph ùê∫[ùëÉ]
ùëê(ùë£) Coreness of vertex ùë£inùê∫=ùëöùëéùë•{ùëò:ùë£‚ààùê∂ùëò(ùê∫)}
ùëêùëÉ(ùë£) Coreness of vertex ùë£inùê∫[ùëÉ]
ùëê(ùëÉ) Coreness of vertex set ùëÉ=ùëöùëéùë•{ùëò:ùëÉ‚äÜùê∂ùëò(ùê∫)}
ùúâùê∫ Degeneracy of ùê∫=ùëöùëéùë•ùë£‚ààùëâ{ùëê(ùë£)}=ùëöùëéùë•ùêª‚äÜùëâ{ùõø(ùêª)}
ùúâùëÜ Degeneracy of subgraph ùê∫[ùëÜ]
ùëëùëíùëõ(ùëÉ)Density of subgraph ùëÉ=ùê∏[ùëÉ]/ |ùëÉ|
2
Definition 4. Degree Ordering: The degree ordering ‚âªof a sub-
graphùê∫[ùëÉ]is a total order of nodes in ùëÉs.t.ùë¢‚âªùë£‚áî(ùëëùëÉ(ùë¢)>ùëëùëÉ(ùë£))
‚à®((ùëëùëÉ(ùë¢)=ùëëùëÉ(ùë£))‚àß(ùë¢>ùë£)).
For a node-set ùëÉ, we useùëÉ‚âªto denote an ordered tuple of nodes in
ùëÉordered by a given ordering ‚âª. For example, consider the subgraph
ùê∫[ùëÉ]induced byùëÉ={1,2,3,4,5}in graphùê∫of Figure 1. Assuming
‚âªdenotes the degree ordering of ùê∫,ùëÉ‚âª=<5,4,3,1,2>. However,
when‚âªrepresents the degree ordering of ùê∫[ùëÉ],ùëÉ‚âª=<4,3,2,1,5>.
We useùë£‚àó(ùëÉ)to denote the last element in degree ordering of
ùê∫[ùëÉ],i.e.,for allùë§‚àà(ùëâ[ùëÉ]‚àí{ùë£‚àó(ùëÉ)}),ùë§‚âªùë£‚àó(ùëÉ). Hereùë£‚àó(ùëÉ)=5.
Definition 5. MD Ordering: The MD ordering, a.k.a. reverse de-
generacy ordering of a subgraph ùê∫[ùëÉ]for a node-set ùëÉ={ùë£1,ùë£2,...,ùë£ùëõ}
is a total order ùëÉ‚âª=<ùë£1,ùë£2,...,ùë£ùëõ>s.t.‚àÄùë£ùëñ‚ààùëÉ:ùë£ùëñ=ùë£‚àó(ùëÉùëñ)where
ùëÉùëñ=<ùë£1,ùë£2,...,ùë£ùëñ>is theùëñ-length prefix of ùëÉ‚âª.
For example, if‚âªdenotes the MD ordering of ùê∫,ùëÉ‚âª=<5,4,3,2,1>
but if‚âªdenotes the MD ordering of ùê∫[ùëÉ],ùëÉ‚âª=<4,3,2,1,5>.
MD ordering sorts the vertices in descending order of their core-
nesses , a.k.a. core numbers [ 47] where coreness of a vertex is the
maximum core it belongs to (see Table 1 and Figure 1).
01011 1
3 42 9
56781-core
3-core
4-core
Figure 1: A toy graph. Here both ùëÜ1={1,2,3,4}andùëÜ2=
{1,2,3,4,5}are(0.7,4)-pseudo-cliques. ùëÜ2is a maximal(0.7,4)-
pseudo-clique but ùëÜ1is not. Coreness of each green node is
one, whereas coreness of each blue (red) node is three (four).Our algorithm explores subgraphs in MD ordering. To avoid
exploring non-pseudo-cliques, it exploits the following constraint.
Definition 6. Loosely Anti-monotone (LAM) Constraint: Let
an itemset (which is a node-set in our case) ùëÜsatisfy a constraint ùëù.
Thenùëùis called a loosely anti-monotone [ 7] or a quasi-hereditary con-
straint [29] if at least one subset of ùëÜalso satisfies ùëù.
EveryùúÉ-pseudo-clique contains at least one ùúÉ-pseudo-clique as
a subset, i.e., ùúÉ-pseudo-cliques satisfy the LAM constraint [29]. It
implies that if no subset of ùëÉis aùúÉ-pseudo-clique then ùëÉis not
aùúÉ-pseudo-clique. Thus, this constraint helps reduce the search
space ofùúÉ-pseudo-cliques, as we only need to grow a subgraph as
long as it remains a ùúÉ-pseudo-clique. However, it is less effective
for search space reduction than the famous anti-monotone [ 7] or
convertible anti-monotone [36] constraints defined below.
Definition 7. Anti-monotone (AM) Constraint: Let an itemset
ùëÜsatisfy a constraint ùëù. Thenùëùis called a hereditary [ 29] or an anti-
monotone [36] constraint if each subset of ùëÜalso satisfies ùëù.
Definition 8. Convertible Anti-monotone (CAM) Constraint:
Let a total order‚âªbe defined over all the items in the universal set
(in our case, ùëâ). So the items in any itemset ùëÜcan be represented as
an ordered tuple, ùëÜ‚âª=<ùë•1,ùë•2,...,ùë•|ùëÜ|>. LetùëÜsatisfy a constraint
ùëù. Thenùëùis called a convertible anti-monotone constraint [ 36] with
respect to the order ‚âªif every prefix of ùëÜ‚âªalso satisfies ùëù.
For example, cliques satisfy anti-monotone constraint because
every subset of a clique is also a clique. On the other hand, average-
degree-based pseudo-cliques satisfy convertible anti-monotone con-
straint with respect to the degree ordering ( ‚âª) ofùê∫because for every
prefixùëÉof any node-set ùëÜ‚äÜùëâit holds that ùëëùëéùë£(ùëÉ)‚â•ùëëùëéùë£(ùëÜ)[36].
4 Properties of Pseudo-cliques
In this section, we first show that pseudo-cliques may not satisfy
the convertible anti-monotone constraint ‚Äì which explains why
search-space reduction for pseudo-cliques is not as easy as that
for average-degree-based quasi-cliques. Next, we establish some
properties of pseudo-cliques, which we utilize later to prune the
search space of pseudo-cliques in our algorithm (Section 5).
Lemma 1. There exists no ordering of all vertices for which ùúÉ-
pseudo-cliques satisfy the convertible anti-monotone constraint.
Proof. Let there be a node-ordering ‚âªfor whichùúÉ-pseudo-
clique satisfies the convertible anti-monotone constraint. Take
the graph of Figure 1 after deleting 9. Consider two 0.7-pseudo-
cliques in that graph: ùëÉ={1,2,3,4,5}andùëÑ={4,5,6,7,8}. Ac-
cording to the convertible anti-monotone constraint, every prefix
ofùëÉ‚âª(respectively, ùëÑ‚âª) must be a 0.7-pseudo-clique. But the only
subset ofùëÉ(resp.,ùëÑ) having|ùëÉ|‚àí1(resp.,|ùëÑ|‚àí1) nodes which
is also a 0.7-pseudo-clique is: ùëÉ‚Ä≤=ùëÉ‚àí{5}(resp.,ùëÑ‚Ä≤=ùëÑ‚àí{4}).
SoùëÉ‚Ä≤
‚âª(resp.,ùëÑ‚Ä≤
‚âª) must be a prefix of ùëÉ‚âª(resp.,ùëÑ‚âª). So 4(resp., 5)
must precede 5(resp, 4) in the ordering ùëÉ‚âª(resp.,ùëÑ‚âª)i.e.,the order
of nodes 4 and 5 differs between ùëÉ‚âªandùëÑ‚âª(contradiction).‚ñ°
This lemma shows that no algorithm can compute maximal (‚Ñì,ùúÉ)-
pseudo-cliques by iterating over any global ordering of vertices
(unlike cliques or average-degree-based quasi-cliques). So we rely
on the following idea to solve our problem.
 
2481KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
Idea 1. To find all maximal (‚Ñì,ùúÉ)-pseudo-cliques in ùê∫, extend
the current subgraph (initially, an empty graph) of ùê∫by adding one
vertex with the current subgraph at a time (Figure 2) in MD ordering
as long as the current subgraph remains a ùúÉ-pseudo-clique and finally,
report it when it becomes a maximal (‚Ñì,ùúÉ)-pseudo-clique.
Since there are ùëÇ(2|ùëâ|)subgraphs of a graph ùê∫=(ùëâ,ùê∏), the
search space of our algorithm is exponential. Below, we put forth
some properties of pseudo-cliques that may help us to prune our
search space. To save space, we provide all proofs in Appendix B.
The following two lemmas give two different bounds on the
maximum possible order of a (‚Ñì,ùúÉ)-pseudo-clique ‚Äì which are then
used to establish our Pruning Technique 1 stated below.
Lemma 2. IfùëÜis a(‚Ñì,ùúÉ)-pseudo-clique then ùúâùëÜ‚â•‚åàùúÉ|ùëÜ|/2‚åâ
Corollary 1. IfùëÜis aùúÉ-pseudo-clique then |ùëÜ|‚â§‚åä2ùúâùê∫/ùúÉ‚åã
Lemma 3. IfùëÜis aùúÉ-pseudo-clique, the largest clique in ùê∫[ùëÜ]is of
orderùúî, andùúÉ>(ùúî‚àí1)/ùúîthen|ùëÜ|‚â§j
1
1‚àí(ùúî‚àí1)/ùúîùúÉk
Corollary 2. IfùëÜis aùúÉ-pseudo-clique with ùúÉ>ùúâùê∫/(ùúâùê∫+1)then
|ùëÜ|‚â§1
1‚àíùúâùê∫/(ùúâùê∫+1)ùúÉ
Pruning Techniqe 1 (Order Bound). No(‚Ñì,ùúÉ)-pseudo-clique ex-
ists if‚Ñì>ùúáwhereùúáis the minimum of the two upper-bounds (on the
order of a(‚Ñì,ùúÉ)-pseudo-clique) mentioned in Corollaries 1 and 2.
We also realize that each (‚Ñì,ùúÉ)-pseudo-clique must contain a
certainùëü-clique (Theorem 1) and such cliques must be contained
within a certain ùëü‚Ä≤-core of the input graph (Lemma 4). These results
are then exploited in our Pruning Technique 2 stated below.
Theorem 1. AùúÉ-pseudo-clique ùëÜwith‚Ñìvertices must contain an
ùëü-cliqueùêæwhereùëü=‚åà1/(1‚àíùúÉ(‚Ñì‚àí1)/‚Ñì)‚åâ.
Lemma 4. Ifùê∫contains aùë°-cliqueùêæ, thenùêæ‚äÜùê∂ùë°‚Ä≤[ùê∫]where
ùë°‚Ä≤=ùëöùëñùëõ{ùëò:ùëò‚â•ùë°‚àí1ùëéùëõùëë|ùê∂ùëò|>0}.
Idea 2. Allùëü-cliques inùê∫can be computed by enumerating all
(ùëü,1)-pseudo-cliques in ùê∫[ùê∂ùëü‚Ä≤]via Idea 1.
Pruning Techniqe 2 (Turan Filtering). Find allùëü-cliques in
ùê∫via Idea 2 and extend them to get all maximal (‚Ñì,ùúÉ)-pseudo-cliques.
5 Method
Our algorithm is a modified version of the PCE algorithm [ 45],
which we briefly introduce below for the reader‚Äôs convenience.
PCE Algorithm: PCE recursively grows ùúÉ-pseudo-cliques. The
following holds for the corresponding recursion tree [45].
Property 1. ùëÑ=ùëÉ‚à™{ùë¢}is a child of a ùúÉ-pseudo-clique ùëÉif and
only if (i)ùëÑis aùúÉ-pseudo-clique and (ii) ùë¢=ùë£‚àó(ùëÑ).
From this, we have derived the following corollary.
Corollary 3. A node-setùëÑ=ùëÉ‚à™{ùë¢}is a child of a ùúÉ-pseudo-
cliqueùëÉif and only if (i) ùëÑis aùúÉ-pseudo-clique and (ii) ùëÉ‚âªis a prefix
ofùëÑ‚âªwhere‚âªis the MD ordering of ùëÑ.
It implies that PCE explores pseudo-cliques using Idea 1. Note
thatùëÑhas only one parent ( ùëÑ‚àí{ùë£‚àó(ùëÑ)}) sinceùë£‚àó(ùëÑ)is unique for
ùëÑ. This property ensures the tree structure of the search-space ofPCE. PCE traverses this tree (a.k.a., reverse search tree [3]) in a DFS
manner to visit all ùúÉ-pseudo-cliques. It starts from each vertex and
continues growing the current ùúÉ-pseudo-clique ùëÉuntil a maximal
ùúÉ-pseudo-clique is found (Figure 2). ùëÉ‚à™{ùë¢}becomes a child of
ùëÉif it satisfies the conditions of Property 1. These conditions are
equivalent to the following three conditions [45].
Lemma 5. IfùëÉis aùúÉ-pseudo-clique and node ùë¢‚àâùëÉthenùëÉ‚à™
{ùë¢}is a child of ùëÉif and only if the following conditions hold: (i)
ùëëùëÉ(ùë¢)‚â•ùúÉ |ùëÉ|+1
2‚àíùê∏[ùëÉ], (ii)(ùëëùëÉ(ùë¢),ùë¢)<(ùõø(ùëÉ)+1,ùë£‚àó(ùëÉ))), (iii)
ùë£‚â∫ùë¢‚áíùë£‚ààùëÅ(ùë¢)‚àÄùë£‚ààùëÉwhere‚âªis the degree ordering of ùê∫[ùëÉ].
Corollary 4. IfùëÉ,ùëÉ‚à™{ùë¢}areùúÉ-pseudo-cliques and ùëÉ‚à™{ùë¢}is a
child ofùëÉthenùúÉ |ùëÉ|+1
2‚àíùê∏[ùëÉ]‚â§ùõø(ùëÉ)+1
Our Algorithm: Our approach, namely FPCE, is a significant
modification of the PCE algorithm. Specifically, we added some
pruning techniques with PCE to reduce its search space. We dis-
cussed all but one of these techniques in Section 4. The last one is
based on the following lemmas (see proofs in Appendix B).
Lemma 6. IfùëÜ,ùëÉareùúÉ-pseudo-cliques such that |ùëÜ|=‚ÑìandùëÜis a
descendant of ùëÉthenùúÉ ‚Ñì
2‚â§ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)(ùõø(ùëÉ)+(‚Ñì‚àí|ùëÉ|+1)/2).
Lemma 7. LetùëÉ,ùëÜareùúÉ-pseudo-cliques,|ùëÜ|=‚Ñì,ùúèùëÉ=ùõø(ùëÉ)+1
2,
ùúÇ(ùëÉ)=ùëöùëñùëõ{ùëê(ùëÉ),ùõø(ùëÉ)+‚Ñì‚àí|ùëÉ|}, andùëÉis an ancestor of ùëÜin the
reverse search tree, then
ùúÉ‚Ñì
2
‚â§(
ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)ùõø(ùëÉ), ifùëê(ùëÉ)=ùõø(ùëÉ)
ùê∏[ùëÉ]+(‚Ñì‚àíùëÉ+ùúèùëÉ)ùúÇ(ùëÉ)‚àí(ùõø(ùëÉ)+1)ùúèùëÉ,otherwise
Pruning Techniqe 3 (Edge Bound). If aùúÉ-pseudo-clique ùëÉ
does not satisfy the inequalities in Lemma 6 or Lemma 7 then it
cannot be extended to obtain a ùúÉ-pseudo-clique of order ‚Ñì.
Algorithm 1 illustrates our overall idea. To compute core num-
bers of nodes in the input graph ùê∫, we implement an O(E) time
algorithm [ 5] (line 1) that iteratively deletes the first node from a
sorted (in ascending order of degrees) list ùêøof nodes. Whenever
a node is deleted, its core number is set to its current degree, its
neighbors‚Äô degrees are updated, and they are re-positioned in ùêøto
maintain their degree-wise ordering. We use these core numbers to
apply the Order Bound (lines 2 ‚Äì 4) and to compute ùê∂ùëü‚Ä≤[ùê∫](line 6).
We call a recursive method named recur on each node of ùê∂ùëü‚Ä≤[ùê∫]. It
takes a pseudo-clique ùëÉand either (i) outputs ùëÉ(if it is a maximal
pseudo-clique) or (ii) extends ùëÉto get each child ùëÑ=ùëÉ‚à™{ùë¢}of
ùëÉ(otherwise) ‚Äì where ùëÑis either a clique (when |ùëÉ|<ùëü; lines 12
‚Äì 14) or a pseudo-clique (when |ùëÉ|‚â•ùëü; line 20). In case (ii), recur
calls itself on each child ùëÑ(lines 21 ‚Äì 23).
We design an algorithm called getChildrenClq to generate each
cliqueùëÉ‚à™{ùë¢}from a clique ùëÉ. It relies on the following property.
Property 2. ùëÉ‚à™{ùë¢}is a clique having at least two nodes ùë¢,ùë£if
and only ifùëÉis a clique,ùë¢‚ààùëÅ(ùë£), andùëÉ‚àí{ùë£}‚à™{ùë¢}is a clique.
This property allows us to exploit the already known child-
cliques ofùëÉ‚àí{ùë£}in a reverse-search tree. We use a compressed
bitset [ 10] to storeùëÅ(ùë£)for each node ùë£, which lets us check con-
ditions in this Property in ùëÇ(ùëôùëîŒî)time to find each child of ùëÉ.
We rely on the getChildrenPseudoClq method of PCE (line 20) to
generate children of the current pseudo-clique ùëÉ. Briefly, it returns
nodes satisfying all conditions of Lemma 5.
 
2482A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
{ }
{0}{1} {2} {3} {4} {5}
{0,1} {0,2} {0,3} {0,4}{3,5}
{0,2,6} {0,2,7}
{0,2,6,7}{6}
{0,6}{2,6}{7}
{0,7}{2,7}{8}
{7,8}{9}
{7,9}{10}
{6,10}{11}
{10,11}{12}
{6,12}9 7 2 6 10
11 12 0 8
1 3 4
5  Pruned by Edge Bound
  Pruned by Turan FilteringTraversed by both PCE and FPCE
Figure 2: A graph (left) and the reverse search tree (right) traversed by PCE and FPCE to search (in vain) for all maximal
(5,0.8)-pseudo-cliques in it. This figure shows that FPCE significantly reduces the search space of PCE even for this small graph.
Figure 2 shows a reverse-search tree depicting recur calls on 0.8-
pseudo-cliques to search for maximal (5,0.8)-pseudo-cliques in a
graph. Here ùëü=3, so FPCE only searches for 3-cliques in the 2-core
({0,2,6,7}) of this graph, thereby pruning nodes outside that core
(Turan Filtering). It also detects that no child of {0,2,6}or{0,2,7}
can exist and thereby saves time by skipping getChildrenPseudoClq
calls on the corresponding tree-nodes (Edge Bound).
Time Complexity: We put a detailed time complexity analysis
in Appendix C. Briefly, FPCE time mainly depends on the time
taken by recur calls. The bottleneck of recur isgetChildrenPseudoClq,
which takes ùëÇ(Œîùëôùëîùëâ+ùëöùëñùëõ{Œî2,ùëâ+ùê∏})time, as per [ 45]. We exploit
properties of pseudo-cliques to derive a tighter time complexity of
ùëÇ(Œî(ùëôùëîùëâ+ùúâùê∫))for it. This is also the running time of recur. Since
recur is called once for each pseudo-clique, the time complexity of
FPCE isùëÇ(2|ùëâ|Œî(ùëôùëîùëâ+ùúâùê∫)), but typically it takes much less time.
Time Reduction: Although, time complexity of FPCE is the
same as PCE, FPCE often prunes many branches of the reverse-
search tree. If it prunes ùëòbranches or detects ùëònodes to be leaves
(for e.g. in Figure 2, Edge Bound detects {0,2,6}to be a leaf), it
savesùëÇ(ùëòŒî(ùëôùëîùëâ+ùúâùê∫))time. When|ùëÉ|‚â§ùëü, it saves time by calling
getChildrenClq instead of slower getChildrenPseudoClq. When Order
Bound holds, it prunes the entire search space. So, FPCE should be
faster than PCE ‚Äì which is evident from our results, too (Section 8).
6 Datasets
Synthetic Datasets: We used Python Networkx library to create
two types of undirected graphs: (i) Scale-free (SF) graphs and (ii)
Small-world (SW) graphs because real graphs tend to have these
types of structures [48]. To generate SF graphs, we used a slightly
modified version of Barab√°si‚ÄìAlbert (BA) preferential attachment
model [ 4] with parameters(ùëõ,ùëö). Starting with an initial graph (by
default, a star graph of ùëö+1nodes), it incrementally adds new nodes
one by one. A new node ùë¢is connected with ùëòpre-existing nodes
in such a way that the probability of a pre-existing node ùë£being
a neighbor of ùë¢is proportional to ùëë(ùë£). In the BA model, ùëò=ùëö,
making it prone to generate graphs with an unrealistically high
minimum degree. To fix this issue, we modified the BA model so
that it chooses ùëòuniformly at random from [1,ùëö]in each iteration.Input: Graphùê∫, minimum order ‚Ñì, minimum density ùúÉ
Output: All maximal(‚Ñì,ùúÉ)-pseudo-cliques in ùê∫
1ùëê= getCoreNumbers( ùê∫) //array of core numbers
2ùúâ=ùëöùëéùë•(ùëê)//computeùúâùê∫
3ùúá=ùëúùëüùëëùëíùëüùêµùëúùë¢ùëõùëë(ùúÉ,ùúâ)
4if‚Ñì>ùúáthen return //Pruning Tech. 1
5ùëü=‚åà1/(1‚àíùúÉ(‚Ñì‚àí1)/‚Ñì)‚åâ
6ùê∂ùëü‚Ä≤=ùëîùëíùë°ùê∂ùëúùëüùëí(ùê∫,ùëê,ùëü)
7forallùë£‚ààùê∂ùëü‚Ä≤do
8ùëüùëíùëêùë¢ùëü(ùê∫,‚àû,{ùë£},ùë£,{})
9
10Procedure recur (ùê∫,ùëêùëù,ùëÉ,ùë£,ùê¥ )
11ùëêùëù=ùëöùëñùëõ(ùëêùëù,ùëê[ùë£])//compute c(P)
12 if|ùëÉ|<ùëüthen
13ùê∑=ùëîùëíùë°ùê∂‚Ñéùëñùëôùëëùëüùëíùëõùê∂ùëôùëû(ùê∫,ùëÉ,ùë£,ùê¥)
14 Go to line 21 //Pruning Tech. 2
15 ifùëÉis a maximal(‚Ñì,ùúÉ)-pseudo-clique then
16 outputùëÉ
17 return
18 ifùëíùëëùëîùëíùêµùëúùë¢ùëõùëë(‚Ñì,ùëêùëù,ùëÉ)then return //Pruning Tech. 3
19 ifùúÉ |ùëÉ|+1
2‚àíùê∏[ùëÉ]>ùõø(ùëÉ)+1then return //Corollary 4
20ùê∑=ùëîùëíùë°ùê∂‚ÑéùëñùëôùëëùëüùëíùëõùëÉùë†ùëíùë¢ùëëùëúùê∂ùëôùëû (ùê∫,ùëÉ,ùë£)
21 forallùë¢‚ààùê∑do
22ùëÑ=ùëÉ‚à™{ùë¢}
23ùëüùëíùëêùë¢ùëü(ùê∫,ùëêùëù,ùëÑ,ùë¢,ùê∑ )
24
25Procedure getChildrenClq (ùê∫,ùëÉ,ùë£,ùê¥ )
26 if|ùëÉ|=1then return{ùë¢:ùë¢<ùë£ùëéùëõùëëùë¢‚ààùëÅ(ùë£)}
27 else return‚à™ùë¢‚ààùê¥{ùë¢:ùë¢<ùë£ùëéùëõùëëùë¢‚ààùëÅ(ùë£)}
Algorithm 1: FPCE(ùê∫,‚Ñì,ùúÉ ) algorithm.
To generate SW graphs, we used Watts‚ÄìStrogatz (WS) (ùëõ,ùëö,ùëù)
model [ 49]. Starting with a cycle graph of ùëõnodes, it connects each
node with its ùëönearest neighbors to form a ring lattice. Then with
probabilityùëù, it replaces each edge (ùë¢,ùë£)in that lattice with another
edge(ùë¢,ùë§)whereùë§is chosen uniformly at random from all nodes
while avoiding the creation of any self-loop/multi-edge.
 
2483KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
We created eight instances of each of these two types of graphs
by varying parameter ùëöin{5,10,15,..., 40}. We usedùëõ=100,000
to get sufficiently large graphs. For the WS model, we chose ùëù=0.2.
Table 2: Properties of synthetic graphs.
Scale Free (SF) Graphs Small World (SW) Graphs
ùëö|ùê∏|ùëëùëíùëõ(ùê∫)ùúâùê∫|ùê∏|ùëëùëíùëõ(ùê∫)ùúâùê∫
5 299,799 5.99e-5 5 200,000 4.00e-5 3
10 550,036 1.10e-4 8 500,000 1.00e-4 7
15 798,375 1.59e-4 11 700,000 1.40e-4 10
20 1,046,002 2.09e-4 15 1,000,000 2.00e-4 15
25 1,300,746 2.60e-4 18 1,200,000 2.40e-4 18
30 1,549,292 3.09e-4 22 1,500,000 3.00e-4 24
35 1,802,411 3.60e-4 25 1,700,000 3.40e-4 28
40 2,047,534 4.09e-4 28 2,000,000 4.00e-4 33
Real Datasets: We collected 18real graphs from [ 40] and re-
moved self-loops and multi-edges from them. Last 3of them are
dense and the rest are sparse (Table 3). We mostly considered sparse
graphs since organically formed networks tend to be sparse [48].
Table 3: Features of real graphs. Starred ones are dense.
IDGraph(ùê∫)Name |ùëΩ| |ùë¨| ùíÖùíÜùíè(ùëÆ)ùùÉùëÆ
1 bio-grid-human 9,436 31,181 7.00e‚àí412
2 web-webbase-2001 16,062 25,592 1.98e‚àí432
3 scc_retweet-crawl 17,151 24,014 1.63e‚àí419
4 soc-gplus 23,628 39,193 1.40e‚àí412
5 dictionary28 39,327 89,037 1.15e‚àí425
6 tech-internet-as 40,164 85,122 1.05e‚àí423
7 PROTEINS-full 43,466 81,043 8.57e‚àí54
8 soc-douban 154,908 327,161 2.72e‚àí515
9 citationCiteseer 268,495 1,156,646 3.20e‚àí515
10 ca-MathSciNet 332,689 820,643 1.48e‚àí524
11 com-amazon 334,863 925,871 1.65e‚àí56
12 TWITTER-Partial 580,768 717,557 4.25e‚àí69
13 delaunay_n23 8,388,608 25,165,783 7.15e‚àí74
14 inf-europe_osm 50,912,018 54,054,659 4.17e‚àí83
15 socfb-konect 59,216,215 92,522,017 5.27e‚àí816
16 bn-mouse-brain* 213 16,242 7.19e‚àí1112
17 school-proximity* 242 8,317 2.85e‚àí147
18 p-hat700-3* 700 183,010 7.48e‚àí1426
7 Experiments
Investigation: We compare the performance of FPCE with two
exact algorithms: PCE and ODES. These algorithms were imple-
mented in C/CPP ‚Äì just like our FPCE code. ODES computes con-
nected pseudo-cliques only. So, to fairly compare all algorithms,
we modified PCE and FPCE codes so that they only compute con-
nected pseudo-cliques. We achieved this goal by noting that, for
connected pseudo-cliques, condition (i) of Lemma 5 for ùëÉ‚à™{ùë£}be-
ing a child of ùëÉbecomes:ùëëùëÉ(ùë£)‚â•ùëöùëéùë•
ùúÉ |ùëÉ|+1
2‚àíùê∏[ùëÉ],1
while
the other two conditions remain the same. We downloaded the PCE
code from https://research.nii.ac.jp/~uno/codes.htm and collected a
single-threaded implementation of ODES from [ 38]. To show the
effectiveness of our algorithm for finding large dense subgraphs,
we executed each algorithm with parameters: ‚Ñì=10,ùúÉ=0.9.Evaluation: We define following performance metrics for FPCE.
(i) Speedup w.r.t. algorithm ùê¥=Execution Time of A
Execution Time of FPCE
(ii) Call reduction =ùëÅùëÉùê∂ùê∏‚àíùëÅùêπùëÉùê∂ùê∏
Hereùê¥denotes PCE or ODES algorithm and ùëÅùëÉùê∂ùê∏(resp.,ùëÅùêπùëÉùê∂ùê∏ )
denotes the number of recur calls made by PCE (resp., FPCE).
Experimental Setup: We conducted our experiments on a work-
station with AMD Ryzen 9 5900X 3.7GHz 12 Core 24 thread CPU
and64GB RAM running on a 64-bit Ubuntu 20.04LTS O/S. To en-
sure fair comparison among algorithms, we compiled all codes using
the same GCC flag, turned off the ‚ÄòCore Performance Boost‚Äô and ‚ÄôFre-
quency Scaling‚Äô features, and fixed all processors‚Äô frequencies to 3.7
GHz. We implemented FPCE in C and wrote Python scripts to pre-
process graphs and post-process results. Our code/data are shared
on our suppl. website: https://github.com/ahsanur-research/FPCE
8 Results
(i)No algorithm finished executing any of our three dense graphs
within five days, even though all of these graphs are quite small.
So, our results are based on the remaining 15graphs.
(ii)FPCE time tends to increase with the number of pseudo-cliques
and with the order of a graph (Figures 3 and 4) ‚Äì which is expected
from its time complexity (Section 5).
Figure 3: Bubble chart showing how FPCE time depends on
the number of pseudo-cliques in real graphs. Disk labels are
graph IDs (Table 3). Disk area varies with call reduction.
(iii)FPCE makes a lot fewer recursive calls than PCE for all graphs,
especially for large graphs . Increasing ùëöincreases both the size and
density of synthetic graphs (Table 2) and exponentially increases
both the number of pseudo-cliques and the time taken by FPCE to
enumerate them. But call reduction also increases almost exponen-
tially withùëö(Figure 4) because larger graphs tend to contain many
more unpromising subgraphs : subgraphs that can never be extended
to any(‚Ñì,ùúÉ)-pseudo-cliques. Similarly, real graphs 13, 14, and 15
(respectively, graphs 1 ‚Äì 5) exhibit much larger (resp., smaller) call
reduction than others (Figure 3). These results indicate that FPCE
is more effective than PCE on larger graphs.
(iv)FPCE is always faster than PCE and ODES (Figure 5). For real
graphs, FPCE is, on average, 38.6and6.5times faster than ODES
and PCE, respectively. For synthetic graphs, FPCE is, on average,
39.7and3.1times faster than ODES and PCE, respectively. Among
synthetic graphs, SW graphs yield higher speedup (of FPCE w.r.t.
PCE) than SF graphs. The average speedup of FPCE w.r.t. PCE on
SW graphs (resp., on SF graphs) is 4.23(respectively, 1.88). This is
expected as SW graphs exhibit higher call reduction (Figure 4).
 
2484A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
510152025303540104107
(a)510152025303540 510152025303540 000101104
(b)510152025303540 510152025303540 000106108
(c)# Pseudo-cliques (SF)
# Pseudo-cliques (SW)FPCE time (SW)
PCE time (SW)FPCE time (SF)
PCE time (SF)Call reduction (SF)
Call reduction (SW)
Figure 4: (a) Number of pseudo-cliques, (b) PCE and FPCE execution times (in sec), and (c) Call reduction of FPCE for Small
World (SW) and Scale Free (SF) graphs. Here, X-axis denotes values of ùëöused to generate these synthetic graphs (see Section 6).
510152025303540024 3.6
1.41.31.92.22.1
1.41.2Scale Free Graph
5101520253035400102019.0
2.12.43.12.91.71.51.3Small World Graph
5101520253035400100
17.89.815.176.988.1165.3
**Scale Free Graph
510152025303540020
13.3
3.76.717.622.8
***Small World Graph
123456789101112131415100101
1.51.1 1.13.6
1.41.121.0
1.22.1
1.42.62.124.2 23.1
9.7
123456789101112131415101102
23.4
**193.2
**15.019.137.8
*8.1
2.49.5
**(a) (b)
(c) (d)
Figure 5: Speedup of FPCE w.r.t. (a) PCE and (b) ODES for synthetic graphs. Speedup of FPCE w.r.t. (c) PCE and (d) ODES for real
graphs. X-axis labels in (a) ‚Äì (b) denote values of ùëöused for synthetic graphs (see Section 6) and those in (c) ‚Äì (d) indicate real
graphs‚Äô IDs (see Table 3). Asterisks in (b) and (d) indicate real graphs on which ODES terminated prematurely.
(v)ODES is the worst of all. It terminates prematurely (showing
a memory overflow error) on many graphs and when it works, it
always takes much longer time than both PCE and FPCE (Figures 4
(b) and (d)). So we focus on comparing FPCE with PCE from now.
(vi)Among graphs with a similar number of pseudo-cliques, sparser
ones tend to yield higher call reduction and speedup w.r.t PCE. Real
graphs in each of the following groups have a similar number of
pseudo-cliques:{1,10},{2,12},{7,11,13,14,15}. In terms of den-
sity: 1>10,2>12,7>11>13>14‚âà15. In terms of call
reduction (resp., speedup): 1<10,2<12,7<11<13<14<15
(resp., 1‚âà10,2<12,7>11<13‚âà14>15). Among synthetic
graphs without pseudo-cliques (SW graphs for m = 5, 10 and SF
graphs for m = 5, 10, 15), the denser the graph is, the lower the
speedup and call reduction of FPCE is. The same observation holds
for SW graph m = 25 and SF graph m = 40, which have a similar
number of pseudo-cliques (Tables 2 and 3, Figures 3‚Äì 5). FPCE‚Äôs
call reduction and speedup exhibit this behavior because if a sub-
graph is not embedded in a dense enough supergraph, then FPCE
identifies and prunes it as it is an unpromising subgraph.
(vii) FPCE‚Äôs speedup w.r.t. PCE mostly depends on call reduction,
i.e.,it is mainly the effect of our pruning techniques (Appendix A).9 Ablation Study
When order-bound‚Äôs condition is met (line 4, Algorithm 1), no (‚Ñì,ùúÉ)-
pseudo-clique can exist ‚Äì which FPCE reports and terminates early.
Thus, we know that order-bound holds on real graphs 7,13,14, and
SW graph m=5. So, we see a high speedup (19 ‚Äì 24.2) of FPCE w.r.t.
PCE on these graphs (Figures 5(a),(c)). Since order-bound prunes
the entire search tree, FPCE skips the other two pruning techniques,
acting as FPCE-with-Order-Bound-only on these four graphs.
We created a version of FPCE called FPCE-EB which lacks Edge
Bound. We found that on our graphs other than these four graphs:
‚Ä¢FPCE-EB is faster than PCE on almost all these graphs, having
an average speedup (w.r.t. PCE) of 2.2and1.6on these real
and synthetic graphs, respectively. It is the effect of Turan
Filtering alone as order-bound didn‚Äôt hold on these graphs.
‚Ä¢FPCE is faster than FPCE-EB on almost all these graphs,
with an average speedup (w.r.t. FPCE-EB) of 1.1and1.25
on these real and synthetic graphs, respectively, i.e.,adding
Edge Bound with FPCE-EB yields even more speedup.
These results imply that all pruning techniques of FPCE posi-
tively contribute to its efficiency.
 
2485KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
510152025303540012
1.11.31.41.61.6
1.11.21.0Scale Free Graphs
5101520253035400122.0
1.5
1.21.41.4
1.11.01.0Small World Graphs
123456789101112131415012
1.0 1.01.11.01.21.02.0
0.91.61.4
1.00.91.01.5
1.1Real Graphs
(a) (b) (c)
510152025303540023.2
1.10.91.21.41.9
1.21.1Scale Free Graphs
5101520253035400510 9.5
1.42.02.22.11.51.51.3Small World Graphs
12345678910111213141501020
1.5 1.1 1.03.51.1 1.110.5
1.2 1.3 0.92.5 2.323.4
15.2
8.5Real Graphs
(d) (e) (f)
Figure 6: Speedup of FPCE w.r.t. FPCE-EB for (a) ‚Äì (b) synthetic and (c) real graphs (top figure) and speedup of FPCE-EB w.r.t
PCE for (d) ‚Äì (e) synthetic and (f) real graphs (bottom figure).
10 Application and Comparison
We found a popular heuristic1method called ClusterONE [ 33]
(henceforth called CL1) that computes pseudo-cliques in PPI net-
works to identify protein complexes. So, we applied both CL1 and
FPCE on a PPI graph to see if the exact computation of pseudo-
cliques give any extra insights. We also applied an exact algorithm
called FastQC [51] to compute degree-based quasi-cliques (hence-
forth DQCs ) in that graph using the same parameters as FPCE.
An(‚Ñì,ùúÉ)-DQC is a connected subgraph ùê∫[ùëÉ]s.t.|ùëÉ| ‚â•‚Ñìand
ùõø(ùëÉ)‚â•ùúÉ(|ùëÉ|‚àí1)i.e.,it is always an(‚Ñì,ùúÉ)-pseudo-clique but the op-
posite may not hold. We did not compare pseudo-cliques with other
types of dense subgraphs because there is no such correspondence
between their parameters and parameters of pseudo-cliques.
Dataset: To form a PPI network, we combined two PPI datasets
onEscherichia coli from [ 2] and [ 39]. We removed multi-edges and
self-loops from it. The resultant graph has 2119 nodes and 3778
edges. To prepare a gold standard, we downloaded known E. coli
protein complexes from ECOCYC2. Since it is easier to find very
small complexes, we only kept complexes with at least 5proteins.
There are 28such complexes. These form our gold-standard dataset.
Investigation: We applied FPCE and CL1 (respectively, FastQC)
on our PPI network to find all maximal (5,ùúÉ)-pseudo-cliques (re-
spectively,(5,ùúÉ)-DQCs) with ùúÉ‚àà{0.9,0.8,0.7,0.6}.
Evaluation: We evaluate FPCE and CL1 based on:
(i)Ge
ometric A
ccuracy :Geometric Accuracy, a.k.a. Accuracy [33] is
a popular metric in protein complex prediction research. To define
it, letùê∂ùëñbe theùëñ-th complex in a gold standard, ùëõbe the number
of such complexes, ùëÉùëóbe theùëó-th complex predicted (which is a
pseudo-clique/DQC in our experiment) by an algorithm, and ùëöbe
the number of such complexes. Then accuracy is the geometric
1Another heuristic was proposed to compute pseudo-cliques [ 1], but its code is not
publicly available and its authors could not provide it when we contacted them.
2https://ecocyc.org/group?id=:ALL-PROTEINS-2&orgid=ECOLImean of Sensitivity (SNS) andPositive Predictive Value (PPV) , where
ùëÜùëÅùëÜ=√çùëõ
ùëñ=1ùëöùëéùë•ùëó |ùê∂ùëñ‚à©ùëÉùëó|
√çùëõ
ùëñ=1|ùê∂ùëñ|ùëé
ùëõùëëùëÉùëÉùëâ =√çùëö
ùëó=1ùëöùëéùë•ùëñ |ùê∂ùëñ‚à©ùëÉùëó|
√çùëö
ùëó=1√çùëõ
ùëñ=1|ùê∂ùëñ‚à©ùëÉùëó|
(ii)Matching Comple
xes: If a pseudo-clique/DQC shares at least
ùúÜproteins with a known complex, we say that the complex matches
that pseudo-clique/DQC. We find complexes matching with pseudo-
cliques/DQCs (computed using FPCE/CL1/FastQC) for ùúÜ‚àà{1,3}.
(iii)Biological Significance : As protein complex databases are
incomplete, a predicted complex not matching any known complex
may still be a valid complex or, at least, may form parts of the same
cellular component. So, researchers often estimate the biological
significance of their predicted complexes by Gene Ontology3(GO)
term4enrichment via Fisher‚Äôs exact test, which takes a population
of genes/proteins (in our case, all proteins in our PPI network)
and a study set (in our case, a pseudo-clique/DQC) to compute a
ùëù-value for each GO term. If a term has a low ùëù-value, that means
the fraction of proteins annotated with that term in the study set
is significantly (statistically) higher than the fraction of proteins
annotated with that term in the population. In such a case, we
say that the study set is enriched in that term [ 19]. But this test
is not meaningful/applicable to our pseudo-cliques/DQCs directly,
due to their small sizes and high overlaps among them [ 27,42,52].
So, we combine pseudo-cliques/DQCs in the following way. We
build a graph whose nodes represent pseudo-cliques/DQCs and
place an edge between two nodes if their corresponding pseudo-
cliques/DQCs overlap. We merge the pseudo-cliques/DQCs in each
connected component of this graph to get some clusters. We use
GOATOOLS [ 19] to find GO Cellular Component (CC) terms that
are enriched in those clusters.
Results: (i)FPCE outperforms both CL1 and FastQC in terms of
SNS, PPV, and accuracy for almost all values of ùúÉ(Figure 7(a)).
(ii)All algorithms executed in < 1 sec for each density threshold ( ùúÉ).
3https://gene
ontology.org/
4A GO term denotes a function/component in a cell shared by a set of genes/proteins.
 
2486A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
0.6 0.7 0.8 0.90.00.51.0
(a)0.6 0.7 0.8 0.9102104
(b)SNS FPCE
SNS CL1
SNS FastQCPPV FPCE
PPV CL1
PPV FastQCAccuracy FPCE
Accuracy CL1
Accuracy FastQC# Pseudocliques FPCE
# Pseudocliques CL1
# DQCs FastQC
Figure 7: (a) Performance comparison between FPCE vs. ClusterONE (denoted CL1) and FastQC on protein-complex prediction
and (b) number of (5,ùúÉ)-pseudo-cliques/DQCs computed by them for this purpose. In both figures, X-axis indicates values of ùúÉ.
Table 4: Protein complexes that match (for ùúÜ=3) with a FPCE pseudo-clique but do not match with any DQCs (starred ones
match with neither any DQCs nor any CL1-pseudo-cliques). Results for ùúÜ=1are put in suppl. website to save space.
Complex Name Complex Members, ùê∂|ùê∂|Best Matched Pseudo-clique, ùëÉ|ùëÉ|ùëÉ‚à©ùê∂|ùëÉ‚à©ùê∂|
ATP synthase
F1 complex*atpA, atpC, atpD, atpG, atpH 5 atpA, atpC, atpD, atpG, atpH 5atpA, atpC, atpD,
atpG, atpH5
degradosome* eno, pnp, ppk, rhlB, rne 5 pnp, rhlB, rluB, rne, srmB, yfgB 6 pnp, rhlB, rne 3
ATP synthase
Fo complex*atpA, atpB, atpC, atpD,atpE,
atpF, atpG, atpH8 atpA, atpC, atpD, atpE, atpG 5atpA, atpC, atpD,
atpE, atpG5
DNA polymerase III,
holoenzymednaE, dnaN, dnaQ, dnaX,
holA, holB, . . . , holE9dnaE, dnaN, dnaQ, dnaX,
holA, holB, holC, holD8dnaE, dnaN, dnaQ,
dnaX, holA, . . . , holD8
hydrogenase 3 hycB, hycC . . . , hycG 6 fdhF, hycB, hycE, hycF, hycG 5 hycB, hycG 2
NADH:quinone
oxidoreductase InuoA, nuoB, nuoC,
nuoE, nuoF . . . , nuoN13 nuoJ, nuoK, nuoL, nuoM, nuoN 5nuoJ, nuoK, nuoL,
nuoM, nuoN5
formate hydrogenlyase
complexfdhF, hycB, hycC, hycD,
hycE, hycF, hycG7 fdhF, hycB, hycE, hycF, hycG 5fdhF, hycB, hycE,
hycF, hycG5
(iii)Number of pseudo-cliques decreases with the increase of ùúÉand as
such SNS and accuracy also decreases. We choseùúÉ=0.8for our next
analyses since it gives high enough accuracy (0 .41) and decreasing
ùúÉfurther increases accuracy a little bit (0 .49forùúÉ=0.7) but results
in many more pseudo-cliques (Figure 7 (b)).
(iv) ForùúÜ=3, only 4 and 0 (respectively, 7) known complexes
match with some CL1-pseudo-cliques and FastQC-DQCs (resp.,
FPCE pseudo-cliques), respectively. If we lower ùúÜto1, then 7and
5(resp., 11) complexes match with some CL1 pseudo-cliques and
DQCs, respectively (resp., FPCE pseudo-cliques). For both values
ofùúÜ(resp., forùúÜ=3), each complex that matches with some CL1-
pseudo-cliques (resp., DQCs), also matches with some FPCE pseudo-
cliques (forùúÜ=1, two complexes exist that match with some DQCs
but not with any FPCE pseudo-cliques ‚Äì which may be the effect
of the small value of ùúÜ). These results imply that CL1/FastQC is less
useful compared to FPCE alone here. ForùúÜ=3(resp., forùúÜ=1), we
found 3 (resp., 4) complexes that match with some FPCE pseudo-
cliques but do not match with any CL1 pseudo-cliques (starred
complexes in Table 4), which implies that FPCE may unearth com-
plexes missed by a heuristic pseudo-clique miner. Similarly, For ùúÜ=3
(resp., forùúÜ=1), we found 7 (resp., 8) complexes that match with
some FPCE pseudo-cliques but do not match with any DQCs (Ta-
ble 4), which implies that FPCE may unearth complexes that cannot
be found by computing DQCs.(v) We got 18, 13, and 8 clusters by merging overlapping pseudo-
cliques/DQCs got from FPCE, CL1, and FastQC, respectively. Among
those, 13 FPCE-derived clusters, 8 CL1-derived clusters, and 6
FastQC-derived clusters are enriched in some GO CC terms. FPCE,
CL1, and FastQC-derived clusters are enriched in 64,42and35
unique GO CC terms, respectively. Among these terms, 28 (resp.,
only 6) are enriched in some FPCE clusters (resp, CL1 clusters) but
are not enriched in any CL1 (resp. FPCE) clusters; whereas 40 (resp.,
only 11) terms are enriched in some FPCE clusters (resp, FastQC
clusters) but are not enriched in any FastQC (resp., FPCE) clusters.
All these results indicate that FPCE outputs are biologically more
interesting than those of CL1/FastQC.
11 Conclusion and Future Directions
We present an exact algorithm to compute pseudo-cliques in a graph.
We show that it is the fastest one on our synthetic and real graphs.
But no exact algorithm (including ours) could enumerate pseudo-
cliques from dense graphs in a reasonable time. Other pruning
techniques may need to be devised to achieve that goal. More
speedup can be achieved via parallelization. Our ideas can also
be extended to find pseudo-cliques in weighted graphs.
Acknowledgments
This work was funded by NSU grant CTRG-20/SEPS/19. We thank
Osama Nadeem, Shahriar Kamal, Khan Asfi Reza for helping us.
 
2487KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
References
[1]James Abello, Mauricio G.C. Resende, and Sandra Sudarsky. 2002. Massive
quasi-clique detection. In Lecture Notes in Computer Science, Vol. 2286. Springer,
598‚Äì612.
[2]Mohammad Arifuzzaman, Maki Maeda, Aya Itoh, Kensaku Nishikata, Chiharu
Takita, Rintaro Saito, Takeshi Ara, Kenji Nakahigashi, Hsuan-Cheng Huang, Aki
Hirai, et al .2006. Large-scale identification of protein‚Äìprotein interaction of
Escherichia coli K-12. Genome research 16, 5 (2006), 686‚Äì691.
[3]David Avis and Komei Fukuda. 1996. Reverse search for enumeration. Discrete
Applied Mathematics 65, 1-3 (1996), 21‚Äì46.
[4]Albert L√°szl√≥ Barab√°si and R√©ka Albert. 1999. Emergence of scaling in random
networks. Science (1999).
[5]Vladimir Batagelj and Matjaz Zaversnik. 2003. An O(m) Algorithm for Cores
Decomposition of Networks. CoRR cs.DS/0310049 (2003).
[6]Malay Bhattacharyya and Sanghamitra Bandyopadhyay. 2009. Mining the largest
quasi-clique in human protein interactome. In Proceedings of the 2009 International
Conference on Adaptive and Intelligent Systems, ICAIS 2009. IEEE, 194‚Äì199.
[7]Francesco Bonchi and Claudio Lucchese. 2005. Pushing tougher constraints in
frequent pattern mining. In Lecture Notes in Computer Science. Springer, 114‚Äì124.
[8]Zvika Brakerski and Boaz Patt-Shamir. 2011. Distributed discovery of large
near-cliques. Distributed Computing 24 (2011), 79‚Äì89.
[9]Mauro Brunato, Holger H. Hoos, and Roberto Battiti. 2008. On effectively finding
maximal quasi-cliques in graphs. In Lecture Notes in Computer Science, Vol. 5313
LNCS. 41‚Äì55.
[10] Samy Chambi, Daniel Lemire, Owen Kaser, and Robert Godin. 2016. Better bitmap
performance with roaring bitmaps. Software: practice and experience 46, 5 (2016),
709‚Äì719.
[11] Jiejiang Chen, Shaowei Cai, Shiwei Pan, Yiyuan Wang, Qingwei Lin, Mengyu
Zhao, and Minghao Yin. 2021. NuQClq: An effective local search algorithm
for maximum quasi-clique problem. In Proceedings of the AAAI Conference on
Artificial Intelligence, Vol. 35. 12258‚Äì12266.
[12] Jie Chen and Yousef Saad. 2012. Dense Subgraph Extraction with Application to
Community Detection. IEEE Transactions on Knowledge and Data Engineering 24,
7 (2012), 1216‚Äì1230.
[13] Serena Dotolo, Anna Marabotti, Angelo Facchiano, and Roberto Tagliaferri. 2020.
A review on drug repurposing applicable to COVID-19. Briefings in Bioinformatics
22, 2 (2020), 726‚Äì741.
[14] A. V. Goldberg. 1984. Finding a Maximum Density Subgraph. Technical Report.
University of California at Berkeley.
[15] Mokhtarul Haque, Rosy Sarmah, and Dhruba K. Bhattacharyya. 2018. A common
neighbor based technique to detect protein complexes in PPI networks. Journal
of Genetic Engineering and Biotechnology 16, 1 (2018), 227‚Äì238.
[16] Steve Harenberg, Gonzalo Bello, L. Gjeltema, Stephen Ranshous, Jitendra Har-
lalka, Ramona Seay, Kanchana Padmanabhan, and Nagiza Samatova. 2014. Com-
munity detection in large-scale networks: A survey and empirical evaluation. ,
426‚Äì439 pages.
[17] Shweta Jain and C. Seshadhri. 2017. A Fast and Provable Method for Estimating
Clique Counts Using Tur√°n‚Äôs Theorem. In Proceedings of the 26th International
Conference on World Wide Web. IW3C2, 441‚Äì449.
[18] Shweta Jain and C. Seshadhri. 2020. Provably and Efficiently Approximating
Near-cliques using the Tur√°n Shadow: PEANUTS. In Proceedings of The Web
Conference 2020 (WWW ‚Äô20) . 1966‚Äì1976.
[19] DV Klopfenstein, Liangsheng Zhang, Brent S Pedersen, Fidel Ram√≠rez, Alex
Warwick Vesztrocy, Aur√©lien Naldi, Christopher J Mungall, Jeffrey M Yunes, Olga
Botvinnik, Mark Weigel, et al .2018. GOATOOLS: A Python library for Gene
Ontology analyses. Scientific reports 8, 1 (2018), 10872.
[20] Christian Komusiewicz and Manuel Sorge. 2015. An algorithmic framework
for fixed-cardinality optimization in sparse graphs applied to dense subgraph
problems. Discrete Applied Mathematics 193 (2015), 145‚Äì161.
[21] Christian Komusiewicz, Manuel Sorge, and Kolja Stahl. 2015. Finding Connected
Subgraphs of Fixed Minimum Density: Implementation and Experiments. In
Proceedings of the 14th International Symposium on Experimental Algorithms -
Volume 9125. Springer-Verlag, 82‚Äì93.
[22] Georg Kustatscher, Martina H√∂dl, Edward Rullmann, Piotr Grabowski, Emmanuel
Fiagbedzi, Anja Groth, and Juri Rappsilber. 2023. Higher-order modular regulation
of the human proteome. Molecular Systems Biology 19, 5 (2023), e9503.
[23] Victor E. Lee, Ning Ruan, Ruoming Jin, and Charu Aggarwal. 2010. A Survey of
Algorithms for Dense Subgraph Discovery. Springer, 303‚Äì336.
[24] Guimei Liu and Limsoon Wong. 2008. Effective pruning techniques for mining
quasi-cliques. In Lecture Notes in Computer Science, Vol. 5212 LNAI. Springer B.H.,
Berlin, Heidelberg, 33‚Äì49.
[25] Jiewei Liu, Ming Li, Xiong-Jian Luo, and Bing Su. 2018. Systems-level analysis of
risk genes reveals the modular nature of schizophrenia. Schizophrenia Research
201 (2018), 261‚Äì269.
[26] James Long and Chris Hartman. 2010. ODES: An overlapping dense sub-graph
algorithm. Bioinformatics 26, 21 (2010), 2788‚Äì2789.[27] Weijun Luo, Michael S Friedman, Kerby Shedden, Kurt D Hankenson, and Peter J
Woolf. 2009. GAGE: generally applicable gene set enrichment for pathway
analysis. BMC bioinformatics 10 (2009), 1‚Äì17.
[28] Xiuli Ma, Guangyu Zhou, Jingbo Shang, Jingjing Wang, Jian Peng, and Jiawei Han.
2017. Detection of Complexes in Biological Networks Through Diversified Dense
Subgraph Mining. Journal of computational biology : a journal of computational
molecular cell biology 24 (2017), 923‚Äì941. Issue 9.
[29] Foad Mahdavi Pajouh, Zhuqi Miao, and Balabhaskar Balasundaram. 2014. A
branch-and-bound approach for maximum quasi-cliques. Annals of Operations
Research 216, 1 (2014), 145‚Äì161.
[30] Fabrizio Marinelli, Andrea Pizzuti, and Fabrizio Rossi. 2020. LP-based dual bounds
for the maximum quasi-clique problem. Discrete Applied Mathematics (2020).
[31] David W. Matula and Leland L. Beck. 1983. Smallest-last ordering and clustering
and graph coloring algorithms. Journal of the ACM (JACM) 30, 3 (1983), 417‚Äì427.
[32] Michael Mitzenmacher, Jakub Pachocki, Richard Peng, Charalampos Tsourakakis,
and Shen Chen Xu. 2015. Scalable Large Near-Clique Detection in Large-Scale
Networks via Sampling. In Proceedings of the 21th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining. 815‚Äì824.
[33] Tam√°s Nepusz, Haiyuan Yu, and Alberto Paccanaro. 2012. Detecting overlapping
protein complexes in protein-protein interaction networks. Nature Methods
(2012).
[34] Grigory Pastukhov, Alexander Veremyev, Vladimir Boginski, and Oleg A
Prokopyev. 2018. On maximum degree-based-quasi-clique problem: Complexity
and exact approaches. Networks 71, 2 (2018), 136‚Äì152.
[35] Jeffrey Pattillo, Alexander Veremyev, Sergiy Butenko, and Vladimir Boginski.
2013. On the maximum quasi-clique problem. Discrete Applied Mathematics 161,
1-2 (2013), 244‚Äì257.
[36] Jian Pei, Jiawei Han, and Laks V.S. Lakshmanan. 2001. Mining frequent itemsets
with convertible constraints. Proceedings - International Conference on Data
Engineering (2001), 433‚Äì442,.
[37] Lu Qin, Rong-Hua Li, Lijun Chang, and Chengqi Zhang. 2015. Locally Dens-
est Subgraph Discovery. In Proceedings of the 21th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining. 965‚Äì974.
[38] Ahsanur Rahman, Steve T. K. Jan, Hyunju Kim, B. Aditya Prakash, and T. M.
Murali. 2016. Unstable Communities in Network Ensembles. In Proceedings of
the 2016 SIAM International Conference on Data Mining. SIAM, 504‚Äì512.
[39] Seesandra V Rajagopala, Patricia Sikorski, Ashwani Kumar, Roberto Mosca, James
Vlasblom, Roland Arnold, Jonathan Franca-Koh, Suman B Pakala, Sadhna Phanse,
Arnaud Ceol, et al .2014. The binary protein-protein interaction landscape of
Escherichia coli. Nature biotechnology 32, 3 (2014), 285‚Äì290.
[40] Ryan A. Rossi and Nesreen K. Ahmed. 2015. The network data repository with
interactive graph analytics and visualization. In Proceedings of the Twenty-Ninth
AAAI Conference on Artificial Intelligence. 4292 ‚Äì 4293.
[41] Seyed Vahid Sanei-Mehri, Apurba Das, and Srikanta Tirthapura. 2018. Enumer-
ating Top-k Quasi-Cliques. In Proceedings - 2018 IEEE International Conference on
Big Data, Big Data 2018. IEEE, 1107‚Äì1112.
[42] Cedric Simillion, Robin Liechti, Heidi EL Lischer, Vassilios Ioannidis, and R√©my
Bruggmann. 2017. Avoiding the pitfalls of gene set enrichment analysis with
SetRank. BMC bioinformatics 18, 1 (2017), 1‚Äì14.
[43] Shu Tadaka and Kengo Kinoshita. 2016. NCMine: Core-peripheral based func-
tional module detection using near-clique mining. Bioinformatics 32, 22 (2016),
3454‚Äì3460.
[44] Charalampos E. Tsourakakis, Francesco Bonchi, Aristides Gionis, Francesco
Gullo, and Maria A. Tsiarli. 2013. Denser than the densest subgraph: Extracting
optimal quasi-cliques with quality guarantees. In Proceedings of the ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining. 104‚Äì112.
[45] Takeaki Uno. 2010. An efficient algorithm for solving pseudo clique enumeration
problem. Algorithmica (New York) 56, 1 (2010), 3‚Äì16.
[46] Alexander Veremyev, Oleg A. Prokopyev, Sergiy Butenko, and Eduardo L. Pasiliao.
2016. Exact MIP-based approaches for finding maximum quasi-cliques and dense
subgraphs. Computational Optimization and Applications 64, 1 (2016), 177‚Äì214.
[47] Jose L Walteros and Austin Buchanan. 2020. Why is maximum clique often easy
in practice? Operations Research 68, 6 (2020), 1866‚Äì1895.
[48] Xiao Fan Wang and Guanrong Chen. 2003. Complex networks: small-world,
scale-free and beyond. IEEE circuits and systems magazine 3, 1 (2003), 6‚Äì20.
[49] Duncan J Watts and Steven H Strogatz. 1998. Collective dynamics of ‚Äòsmall-
world‚Äônetworks. nature 393, 6684 (1998), 440‚Äì442.
[50] Qiu Xiao, Haiming Yu, Jiancheng Zhong, Cheng Liang, Guanghui Li, Pingjian
Ding, and Jiawei Luo. 2020. An in-silico method with graph-based multi-label
learning for large-scale prediction of circRNA-disease associations. Genomics
112, 5 (2020), 3407‚Äì3415.
[51] Kaiqiang Yu and Cheng Long. 2023. Fast Maximal Quasi-clique Enumeration:
A Pruning and Branching Co-Design Approach. Proc. ACM Manag. Data 1, 3,
Article 211 (2023), 26 pages.
[52] Qi Zheng and Xiu-Jie Wang. 2008. GOEAST: a web-based software toolkit for
Gene Ontology enrichment analysis. Nucleic acids research 36, suppl_2 (2008),
W358‚ÄìW363.
 
2488A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
A Supplementary Results
FPCE‚Äôs speedup varies with call ratio (ratio of no. of recursive calls
of PCE vs. FPCE), i.e.,its speedup is mainly the effect of its pruning
techniques, not merely that of implementation tactics (Figure 8).
1 2 4 8 16
Call Ratio1248SpeedupScale Free Graph
Small World Graph
Real Graph
Figure 8: Call ratio vs. speedup of FPCE w.r.t. PCE.
On real graphs, FPCE and FPCE-EB achieve an average speedup
of 6.5 and 5, respectively. Both use an average of 2.9 times more
memory than PCE (Table 5). For space limitation, we put other
results for(‚Ñì,ùúÉ)=(10,0.9)and those for(10,0.8)in our suppl.
website.
Table 5: Time (in sec) and Memory (Resident Set Size, in
MB) of PCE, FPCE-EB, and FPCE on real graphs. Memory
consumptions of FPCE and FPCE-EB are almost the same.
Graph Time Memory
ID PCE FPCE-EB FPCE PCE FPCE
1 0.69 0.45 0.46 3.1 5.8
229,713.24 27,345.89 27,498.36 3.6 7.1
3 548.66 552.35 490.87 3.6 7.2
4 2.27 0.64 0.63 4.0 9.2
5 215.52 189.23 158.51 5.5 14.5
6 1,727.02 1,604.64 1,598.60 5.6 14.6
7 0.21 0.02 0.01 5.6 13.3
8 1.21 0.97 1.03 14.2 50.9
9 18.45 13.78 8.83 27.5 127.9
10 224.50 237.39 164.08 29.0 124.0
11 3.89 1.54 1.48 29.7 127.7
12 1.94 0.83 0.93 43.1 160.3
13 260.63 11.13 10.79 706.2 3,003.3
14 453.52 29.86 19.64 3,521.9 12,184.8
15 1,797.16 212.36 185.51 4,322.4 19,220.3
B Proofs
At first, we prove Lemmas 8 to 10 and derive some corollaries
from them. Then we use those results to prove Lemmas 2 to 7 and
Theorem 1 ‚Äì which have already been stated in Sections 4 and 5.
Lemma 8.ùëê(ùëÉ)=ùëöùëñùëõùë£‚ààùëÉùëê(ùë£)Proof.ùëê(ùëÉ)=ùëöùëéùë•ùëÉ‚äÜùê∂ùëò(ùê∫){ùëò}=ùë°=‚áíùëê(ùë£) ‚â•ùë°‚àÄùë£‚ààùëÉ
because some vertices ùë£‚ààùëÉmay belong to a(ùë°+ùë•)-core (for
someùë•>0) ‚Äì which must be a subgraph of the ùë°-core [ 31]. On the
other hand, there must be a vertex ùë£‚ààùëÉs.t.ùëê(ùë£)=ùë°because if
‚àÄùë£‚ààùëÉ:ùëê(ùë£)>ùë°, thenùëê(ùëÜ)>ùë°. ‚ñ°
Corollary 5. ùëê(ùëÉ)‚â§ùëê(ùë£) ‚àÄùë£‚ààùëÉ
Lemma 9. For any subset of vertices ùëÉ,ùõø(ùëÉ)‚â§ùëê(ùëÉ).
Proof. Letùõø(ùëÉ)>ùëê(ùëÉ). So‚àÄùë£‚ààùëÉ:ùëëùëÉ(ùë£) ‚â•ùõø(ùëÉ)>ùëê(ùëÉ).
SoùëÉ‚äÜùê∂ùë°(ùê∫)whereùë°‚â•ùõø(ùëÉ)>ùëê(ùëÉ)=‚áíùëê(ùëÉ)=ùë°>ùëê(ùëÉ)
(contradiction). ‚ñ°
Corollary 6. ùõø(ùëÉ)‚â§ùëê(ùëÉ)‚â§ùëê(ùë£) ‚àÄùë£‚ààùëÉ
The last inequality follows from Corollary 5.
Lemma 10. ùëÉ‚äÜùëâ=‚áíùëêùëÉ(ùë£)‚â§ùëê(ùë£) ‚àÄùë£‚ààùëÉ
Proof. Letùë£be any node in ùëÉandùëêùëÉ(ùë£)=ùëòi.e.,ùë£‚ààùê∂ùëò(ùëÉ)‚äÜùëÉ.
According to Corollary 6, ùëê(ùë£)‚â•ùõø(ùê∂ùëò(ùëÉ))=ùëò=ùëêùëÉ(ùë£)‚ñ°
Corollary 7. ùëÉ‚äÜùëÜ=‚áíùëêùëÉ(ùë£)‚â§ùëêùëÜ(ùë£) ‚àÄùë£‚ààùëÉ
Lemma 2: IfùëÜis a(‚Ñì,ùúÉ)-pseudo-clique then ùúâùëÜ‚â•‚åàùúÉ|ùëÜ|/2‚åâ.
Proof. Each vertex in the MD ordering of ùê∫[ùëÜ]is adjacent to
at mostùúâùëÜpreceding nodes [47]. So
|ùê∏[ùëÜ]|‚â§0+1+2+...+(ùúâùëÜ‚àí1)+(|ùëÜ|‚àíùúâùëÜ)ùúâùëÜ=
|ùëÜ|‚àíùúâùëÜ+1
2
ùúâùëÜ
SinceùëÜis a(‚Ñì,ùúÉ)-pseudo-clique of order |ùëÜ|,|ùê∏[ùëÜ]|‚â•ùúÉ |ùëÜ|
2.
‚à¥ùúÉ|ùëÜ|
2
‚â§
|ùëÜ|‚àíùúâùëÜ+1
2
ùúâùëÜ=‚áíùúâùëÜ‚â•‚åàùúÉ|ùëÜ|/2‚åâ
It follows from the solution of the quadratic inequality in the LHS,
which was simplified by ùúâùëÜ‚â•1(sinceùê∫[ùëÜ]is connected). ‚ñ°
Lemma 3: IfùëÜis aùúÉ-pseudo-clique, the largest clique in ùê∫[ùëÜ]is
of orderùúî, andùúÉ>(ùúî‚àí1)/ùúîthen|ùëÜ|‚â§j
1
1‚àí(ùúî‚àí1)/ùúîùúÉk
.
Proof. Let|ùëÜ|=ùëõ. Since the maximum clique of ùê∫hasùúînodes,
ùê∫isùêæùúî+1-free. So by Turan‚Äôs theorem [ 17],|ùê∏[ùëÜ]|‚â§(1‚àí1/ùúî)ùëõ2/2.
SinceùëÜis aùúÉ-pseudo-clique|ùê∏[ùëÜ]|‚â•ùúÉ ùëõ
2. SoùúÉ ùëõ
2‚â§(1‚àí1/ùúî)ùëõ2/2.
Simplifying this, we get this upper bound on |ùëÜ|=ùëõ.‚ñ°
Theorem 1: AùúÉ-pseudo-clique ùëÜwith‚Ñìvertices must contain an
ùëü-cliqueùêæwhereùëü=‚åà1/(1‚àíùúÉ(‚Ñì‚àí1)/‚Ñì)‚åâ.
Proof. According to Turan‚Äôs theorem, if a subgraph ùê∫[ùëÜ]con-
tains noùêæùëó+1then|ùê∏[ùëÜ]|‚â§( 1‚àí1/ùëó)‚Ñì2/2. SinceùëÜis aùúÉ-pseudo-
clique with‚Ñìvertices,|ùê∏[ùëÜ]|‚â•ùúÉ ‚Ñì
2. So ifùêæùëó+1is not a subgraph of
ùê∫[ùëÜ]thenùëó‚â•‚åà1/(1‚àíùúÉ(‚Ñì‚àí1)/‚Ñì)‚åâ. Taking contrapositive: ùê∫[ùëÜ]
must contain a ùëó-clique for each value of ùëó‚àà{1,2,...ùëü}where
ùëü=‚åà1/(1‚àíùúÉ(‚Ñì‚àí1)/‚Ñì)‚åâ. ‚ñ°
Lemma 4: Ifùê∫contains aùë°-cliqueùêæ, thenùêæ‚äÜùê∂ùë°‚Ä≤[ùê∫]where
ùë°‚Ä≤=ùëöùëñùëõ{ùëò:ùëò‚â•ùë°‚àí1ùëéùëõùëë|ùê∂ùëò|>0}.
Proof. Let<ùë£1,ùë£2,...,ùë£|ùëâ|>be the MD ordering of ùê∫and
ùë£ùëõbe the last vertex of ùêæin that ordering. Let ùëÉ={ùë£1,ùë£2,...ùë£ùëõ}.
Clearly,ùêæ‚äÜùëÉ. According to Corollary 6, ùëê(ùë£)‚â•ùõø(ùëÉ)=ùëëùëÉ(ùë£ùëõ)‚â•
ùëëùêæ(ùë£ùëõ)‚â•ùë°‚àí1for allùë£‚ààùëÉ. Thereforeùêæ‚äÜùëÉ‚äÜùê∂ùë°‚Ä≤[ùê∫].‚ñ°
 
2489KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
Lemma 6: IfùëÜ,ùëÉareùúÉ-pseudo-cliques such that |ùëÜ|=‚ÑìandùëÜis a
descendant of ùëÉthenùúÉ ‚Ñì
2‚â§ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)(ùõø(ùëÉ)+(‚Ñì‚àí|ùëÉ|+1)/2)
Proof. By condition (ii) of Lemma 5, if ùëÉ‚à™{ùë¢}is a child ofùëÉthen
ùëëùëÉ‚à™{ùë¢}(ùë¢)=ùõø(ùëÉ‚à™{ùë¢})‚â§ùõø(ùëÉ)+1. By condition (i) of the same
lemma,ùúÉ |ùëÉ|+1
2‚â§ùê∏[ùëÉ]+ùõø(ùëÉ)+1. Generalizing this condition
for a descendant ùëÜofùëÉwe getùúÉ |ùëÜ|
2‚â§ùê∏[ùëÉ]+√çùõø(ùëÉ)+‚Ñì‚àí|ùëÉ|
ùëñ=ùõø(ùëÉ)+1ùëñ=
ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)
ùõø(ùëÉ)+‚Ñì‚àí|ùëÉ|+1
2
‚ñ°
Lemma 7: LetùëÉ,ùëÜareùúÉ-pseudo-cliques,|ùëÜ|=‚Ñì,ùúèùëÉ=ùõø(ùëÉ)+1
2,
ùúÇ(ùëÉ)=ùëöùëñùëõ{ùëê(ùëÉ),ùõø(ùëÉ)+‚Ñì‚àí|ùëÉ|}, andùëÉis an ancestor of ùëÜin the
reverse search tree, then
ùúÉ‚Ñì
2
‚â§(
ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)ùõø(ùëÉ), ifùëê(ùëÉ)=ùõø(ùëÉ)
ùê∏[ùëÉ]+(‚Ñì‚àíùëÉ+ùúèùëÉ)ùúÇ(ùëÉ)‚àí(ùõø(ùëÉ)+1)ùúèùëÉ,otherwise
Proof. LetùëÜùëñbe theùëñ-length prefix of ùëÜ‚âªandùë£ùëñbe the last
node ofùëÜùëñ. By Lemma 9 and Corollary 7: ùõø(ùëÜ) ‚â•ùõø(ùëÉ). When
ùõø(ùëÜ)=ùõø(ùëÉ), each node ùë£ùëñ‚ààùëÜ‚àíùëÉhas degreeùõø(ùëÉ)inùê∫[ùëÜùëñ]. So,
ùúÉ ‚Ñì
2‚â§ùúì1(ùëÉ)=ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|)ùõø(ùëÉ). Whenùõø(ùëÜ)>ùõø(ùëÉ),ùúÉ ‚Ñì
2‚â§
ùê∏[ùëÉ]+√çùõø(ùëÜ)‚àí1
ùëñ=ùõø(ùëÉ)+1ùëñ+(‚Ñì‚àí|ùëÉ|‚àí(ùõø(ùëÜ)‚àíùõø(ùëÉ)‚àí1))ùõø(ùëÜ). Asùõø(ùëÜ)‚â§
ùúÇ(ùëÉ),ùúÉ ‚Ñì
2‚â§ùúì2(ùëÉ)=ùê∏[ùëÉ]+(‚Ñì‚àí|ùëÉ|+ùúèùëÉ)ùúÇ(ùëÉ)‚àí(ùõø(ùëÉ)+1)ùúèùëÉ.
Altogether ùúÉ ‚Ñì
2‚â§ùëöùëéùë•(ùúì1(ùëÉ),ùúì2(ùëÉ)). Ifùëê(ùëÉ)=ùõø(ùëÉ),ùúì1(ùëÉ)>
ùúì2(ùëÉ). Otherwise, i.e.,whenùëê(ùëÉ)>ùõø(ùëÉ),ùúì2(ùëÉ)>ùúì1(ùëÉ)for both
possible values of ùúÇ(ùëÉ). Putting these together, we get this bound.
‚ñ°
C Time Complexity Analysis
The PCE algorithm (Algorithm 2) is similar to our FPCE algorithm
except that it does not apply our pruning techniques. As compared
to PCE, FPCE takes an extra ùëÇ(ùê∏)time during preprocessing for
core calculation (line 1 of Algorithm 1) and an extra ùëÇ(1)time
during each call of recur for applying Edge Bound. When Turan
Filtering is applied, FPCE takes less time than PCE because in that
case, it calls getChildrenClq instead of slower getChildrenPseudoClq.
So, the time complexity of FPCE remains the same as PCE. Since
our pruning techniques do not incur any extra time complexity,
the worst case time complexity of FPCE is the same as that of PCE,
even though in reality, significant speedup is achieved via FPCE,
as shown in Section 8. Therefore, to derive the time complexity of
FPCE, it suffices to derive the time complexity of the PCE algorithm ‚Äì
which we do below, along with a discussion of its working principle.
To explore the reverse search tree, PCE calls a recursive subrou-
tine called recur-basic on each pseudo-clique of order one, i.e.,on
each node in ùëâ[ùê∫]. This subroutine relies on a procedure called
getChildrenPseudoClq (line 9 of Algorithm 2) to generate child
pseudo-cliques of the current pseudo-clique ùëÉ. This procedure re-
turns a setùê∑of nodes that satisfy the conditions of Lemma 5. Note
that, condition (iii) of this lemma is equivalent to the following
condition: either (a) ùë¢‚â∫ùë£‚àó(ùëÉ), or (b)ùë¢‚â∫ùõæ(ùë¢,ùëÉ)whereùõæ(ùë¢,ùëÉ)is
the last node in degree ordering of ùëÉwhich is not in ùëÅ(ùë¢)(ifùë¢is a
neighbor of all nodes in ùëÉ, thenùë¢‚â∫ùõæ(ùë¢,ùëÉ), by default) [ 45]. To find
such nodes efficiently, PCE maintains a binary tree ùëá(henceforth
called degree tree ) that stores all nodes in ùëâ[ùê∫]at its leaves in the
degree ordering‚âªofùê∫[ùëÉ]. It exploits this tree to find nodes ùë¢‚àâùëÉsatisfying the first two conditions of Lemma 5 and condition (a) or
(b),i.e.,it generates nodes having either of the following properties:
Input: Graphùê∫, minimum order ‚Ñì, minimum density ùúÉ
Output: All maximal(‚Ñì,ùúÉ)-pseudo-cliques in ùê∫
1forallùë£‚ààùëâ[ùê∫]do
2ùëüùëíùëêùë¢ùëü‚àíùëèùëéùë†ùëñùëê(ùê∫,{ùë£},ùë£,{})
3
4Procedure recur-basic (G,ùëÉ,ùë£,ùê¥ )
5 ifùëÉis a maximal(‚Ñì,ùúÉ)-pseudo-clique then
6 outputùëÉ
7 return
8 ifùúÉ |ùëÉ|+1
2‚àíùê∏[ùëÉ]>ùõø(ùëÉ)+1then return
9ùê∑=ùëîùëíùë°ùê∂‚ÑéùëñùëôùëëùëüùëíùëõùëÉùë†ùëíùë¢ùëëùëúùê∂ùëôùëû (ùê∫,ùëÉ,ùë£)
10 forallùë¢‚ààùê∑do
11ùëÑ=ùëÉ‚à™{ùë¢}
12ùëüùëíùëêùë¢ùëü‚àíùëèùëéùë†ùëñùëê(ùê∫,ùëÑ,ùë¢,ùê∑ )
Algorithm 2: PCE(ùê∫,‚Ñì,ùúÉ ) algorithm.
(1)Nodes satisfying the aforementioned condition (a): for such
a nodeùë¢,ùëÑ=ùëÉ‚à™{ùë¢}must be a child of ùëÉ(by Lemma 5).
SogetChildrenPseudoClq simply returns all such nodes and
then recur-basic is called on each of them iteratively. Finding
each such node from ùëárequiresùëÇ(ùëôùëîùëâ)time.
(2)Nodes satisfying condition (b): Such a node must be a neigh-
bor ofùë£‚àó(ùëÉ)[45]. But if a node ùë£‚ààùëÅ(ùë£‚àó(ùëÉ))satisfies
condition (ii) of Lemma 5, then ùõæ(ùë£,ùëÉ)must be in the first
ùëë(ùë£)+1=ùëÇ(Œî)vertices in the degree ordering of ùëÉinùëá. So
searching for ùõæ(ùë£,ùëÉ)requiresùëÇ(ùëöùëñùëõ{Œî,|ùëÉ|})time for each
ùë£‚ààùëÅ(ùë£‚àó(ùëÉ)). Since|ùëÉ|‚â§2Œî/ùúÉ[20], this time is equivalent
toùëÇ(|ùëÉ|). So the total time to compute all such neighbors
ofùë£‚àó(ùëÉ)isùëÇ(Œî|ùëÉ|). This time is equivalent to ùëÇ(Œîùúâùê∫)since
|ùëÉ|isùëÇ(ùúâùê∫)as per Corollary 1. Thus, the time required to
find each such node ùë¢isùëÇ(Œîùúâùê∫/ùëò)whereùëòis the number
of such nodes. Since ùëò‚â•1(because otherwise ùëÉwould be a
maximal pseudo-clique), we simply count the upper bound
ùëÇ(Œîùúâùê∫)as the time spent to find each such node.
The recur-basic algorithm takes each of these nodes and calls it-
self on each extension ùëÑ=ùëÉ‚à™{ùë¢}ofùëÉ(lines 10 ‚Äì 12 of Algorithm 2).
Note that it is computationally expensive to copy a set of nodes and
its corresponding degree tree. So, in the actual implementation, a
global set of nodes ùëÉand its degree tree ùëáis maintained. Whenever
ùëüùëíùëêùë¢ùëü‚àíùëèùëéùë†ùëñùëê(ùê∫,ùëÑ,ùë¢,ùê∑)is called (respectively, returned), ùë¢is added
with (respectively, deleted from) ùëÉ, and its neighbors‚Äô degrees are
updated in the degree tree ùëá. No update is required for all the other
nodesùë§‚àâùëÅ(ùë¢)sinceùëëùëíùëîùëÉ(ùë§)remains the same. Thus, this update
operation takes ùëÇ(Œîùëôùëîùëâ)time in each call of recur-basic.
So, the total time spent by recur-basic algorithm for generat-
ing (done by getChildrenPseudoClq ) and processing each pseudo-
clique isùëÇ(Œî(ùëôùëîùëâ+ùúâùê∫)). Assuming there are ùëÅùúÉ-pseudo-cliques in
the input graph (therefore, ùëÅtreenodes in the reverse-search tree),
the total time complexity of PCE is ùëÇ(ùëÅŒî(ùëôùëîùëâ+ùúâùê∫))which is
ùëÇ(2|ùëâ|Œî(ùëôùëîùëâ+ùúâùê∫)), in the worst case.
 
2490