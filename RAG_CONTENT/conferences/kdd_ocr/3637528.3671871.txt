SeBot: Structural Entropy Guided Multi-View Contrastive
Learning for Social Bot Detection
Yingguang Yang
University of Science and Technology
of China
Hefei, China
dao@mail.ustc.edu.cnQi Wu
University of Science and Technology
of China
Hefei, China
qiwu4512@mail.ustc.edu.cnBuyun He
University of Science and Technology
of China
Hefei, China
byhe@mail.ustc.edu.cn
Hao Peng∗
Beihang University
Beijing, China
penghao@buaa.edu.cnRenyu Yang
Beihang University
Beijing, China
renyuyang@buaa.edu.cnZhifeng Hao
Shantou University
Shantou, China
haozhifeng@stu.edu.cn
Yong Liao∗
University of Science and Technology
of China
Hefei, China
yliao@ustc.edu.cn
ABSTRACT
Recent advancements in social bot detection have been driven by
the adoption of Graph Neural Networks. The social graph, con-
structed from social network interactions, contains benign and bot
accounts that influence each other. However, previous graph-based
detection methods that follow the transductive message-passing
paradigm may not fully utilize hidden graph information and are
vulnerable to adversarial bot behavior. The indiscriminate message
passing between nodes from different categories and communi-
ties results in excessively homogeneous node representations, ul-
timately reducing the effectiveness of social bot detectors. In this
paper, we propose SeBot, a novel multi-view graph-based con-
trastive learning-enabled social bot detector. In particular, we use
structural entropy as an uncertainty metric to optimize the entire
graph’s structure and subgraph-level granularity, revealing the im-
plicitly existing hierarchical community structure. And we design
an encoder to enable message passing beyond the homophily as-
sumption, enhancing robustness to adversarial behaviors of social
bots. Finally, we employ multi-view contrastive learning to maxi-
mize mutual information between different views and enhance the
detection performance through multi-task learning. Experimental
results demonstrate that our approach significantly improves the
performance of social bot detection compared with SOTA methods.
∗Corresponding authors
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671871CCS CONCEPTS
•Computing methodologies →Machine learning; •Security
and privacy→Social network security and privacy.
KEYWORDS
social bot detection, graph neural networks, contrastive learning,
structural entropy
ACM Reference Format:
Yingguang Yang, Qi Wu, Buyun He, Hao Peng, Renyu Yang, Zhifeng Hao,
and Yong Liao. 2024. SeBot: Structural Entropy Guided Multi-View Con-
trastive Learning for Social Bot Detection. In Proceedings of the 30th ACM
SIGKDD Conference on Knowledge Discovery and Data Mining (KDD ’24),
August 25–29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3637528.3671871
1 INTRODUCTION
Social bots are automated controlled accounts that widely exist
on social platforms such as Twitter and Weibo, in most cases, for
malicious purposes such as spreading misinformation [ 16,41], ma-
nipulating public opinion [ 18,42], and influencing political elections
[10,29]. They will undoubtedly give rise to societal disharmony in
social network environments.
Conventional methods for social bots detection primarily focus
on extracting discriminative features, ranging from user attributes,
[47], text features [ 21] to structure features[ 5], which can be then
used to train classifiers in a supervised manner. Due to the con-
tinuous evolution of social bots [ 9], including their ability to steal
information from legitimate accounts and mimic normal account
behaviors [ 26], these traditional methods turn out to be ineffective
in identifying the latest generation bots. A recent advancement
in social bot detection is introducing graph neural networks [ 1]
that treat accounts and the interactions in-between as nodes and
edges, respectively. Multi-relational heterogeneous graphs can be
3841
KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
Intra -class edge
Inter-class edge
 ?
Root Sub
CommunitiesHierarchical Community Structure
?
?
?
?
Figure 1: Illustration of community structure and inter-class
interactions co-exists in social networks. The abstraction of
the hierarchical community structure is presented in the
form of an encoding tree.
established [ 13] and a Relation Graph Transformer (RGT) is respon-
sible for aggregating information from neighbors. Such approaches
consider the features of each account as interdependent ones and
leverage the semantic information of relationships between ac-
counts to generate semantically-richer representations.
While successful, there are two challenges facing the existing
graph-based methods (illustrated in Figure 1). i) How to fully exploit
the hierarchical information hidden in the graph structure? Unlike
other semi-supervised node classification tasks, some accounts in
social platforms tend to exhibit stronger correlations with others in
the topological structure due to shared interests, events of interest,
etc. [ 9], indicating an intrinsic hierarchical community structure in
the graph constructed by social bot detectors. The existing graph-
based social bot detection methods [ 13,15,20,33,45,49,50,54]
primarily focused on aggregating node-level information on the
original graph, neglecting comprehensive utilization of high-order
graph structural information. As a result, the generated representa-
tions only capture low-order graph information and lack high-order
semantic information. ii) How to handle the adversarial behaviors of
bots intentionally interacting with humans to evade detection? Ex-
isting bot detection methods rely on the assumption that bots and
humans exhibit stronger connections with nodes of their category.
However, for social bots, especially in the case of advanced social
bot control programs, gathering human-specific information from
neighbors would be more advantageous for concealing their true
identity. Therefore, bots intentionally tend to establish associations
with human accounts to escape detection [7, 11].
To tackle these two challenges, we propose SeBot, a novel
Structural Entropy Guided Social BotDetection framework through
graph contrastive learning enhanced classification with both intra-
class and inter-class edges. Motivated by minimum entropy theory
[23], indicating systems at the minimum level of uncertainties, and
structural entropy [ 27] further offers an effective measure of the in-
formation embedded in an arbitrary graph and structural diversity.
We construct encoding trees for both the entire input graph and
the subgraphs of each node by minimizing their structural entropy.
We then use the optimal encoding trees to describe the hierarchical
structural information of the graph and obtain cluster assignment
matrixes for the nodes. Subsequently, node representations are ob-
tained through structural entropy pooling and unpooling for node
and graph classification. On the other hand, we designed an encoder
that can adaptively make neighbors similar or differentiate them to
handle the adversarial behavior of bots. Finally, we utilize the noderepresentations generated by the three modules to calculate both
cross-entropy loss and self-supervised contrastive learning loss.
The contributions of this work can be summarized as follows:
•We are the first to introduce structural entropy to capture se-
mantic information at both subgraph and entire-graph levels in
a self-supervised manner.
•We propose a self-supervised contrastive learning framework
called SeBot, which integrates node-node and subgraph-subgraph
level contrastive learning tasks in a multi-task learning manner
to capture high-order semantic information.
•Experiments on two real-world bot detection benchmark datasets
demonstrate that our method outperforms current state-of-the-
art social bot detection methods.
2 RELATED WORK
Graph-based Social Bot Detection. Graph-based social bot de-
tection has been of ultimate importance in modeling various in-
teractions intrinsically existing in social networks. Previous meth-
ods [ 1,13,15,45] have focused primarily on designing informa-
tion aggregation strategies for better detection performance. [ 1]
takes the first attempt to use graph convolutional neural networks
(GCNs) [ 25] for detecting social bots. Typically, BotRGCN [ 15] uti-
lizes relational graph convolutional networks (RGCNs) to aggregate
neighbor information from edges of different relations. [ 13] pro-
posed RGT, which utilizes a self-attention mechanism to adaptively
aggregate information from neighbors in each relational view of the
graph. Although these methods have shown significant improve-
ments compared to traditional feature engineering and text-based
approaches [ 12], they may not fully exploit the crucial semantic
information concealed in the graph structure and the graph struc-
ture obtained from sampling social networks contain a significant
amount of uncertainty and randomness.
Graph Self-Supervised Learning. Self-supervised learning has
achieved great success in the fields of natural language process-
ing [48] and computer vision [ 24] without the need for prohibitively
costly labeled data. Graph contrastive learning (GCL) is a typical
paradigm of self-supervised learning on graphs, aiming at learn-
ing invariant representations between different graph views. For
instance, DGI [ 40] utilizes a local-global mutual information maxi-
mization approach to obtain node representations. [ 51] proposes
a series of graph augmentation methods including node dropping,
edge perturbation, attribute masking, and so on. [ 59] propose an
adaptive way for graph augmentation, which assigns adaptive prob-
abilities to attribute and topological perturbation. However, these
augmentation methods inevitably suffer from the loss of essential
information or introduce class-redundant noise. Due to the sig-
nificant impact of the quality of generated views on contrastive
learning, [ 43] theoretically proves that the anchor view containing
essential semantic information should have the minimum structural
entropy. Inspired by this, structural entropy is employed by us to
generate the anchor view with minimum uncertainty.
Structural Entropy. After Shannon proposed information entropy
to measure system uncertainty [ 35], the measurement of uncer-
tainty in graph structure has been widely studied, and several meth-
ods [ 30,34,37] have been developed to quantify it. Among them,
3842SeBot: Structural Entropy Guided Multi-View Contrastive Learning for Social Bot Detection KDD ’24, August 25–29, 2024, Barcelona, Spain
Target	UserBotHumanUnlabeledRelation𝑚-hop	SubgraphsEncoding	Trees	GenerationEdge	Dropping
GNNGNNSEP-U
GNN	SEPGNNMLP
Contrastive	Pairs
RCM	Layer81%19%
GG	4()(),
,ℒ,-.ProjectionHeadProjectionHead
Contrastive	Pairsℒ/-.ConcatMLP
𝐡34
𝐡35𝐡36×𝐿G	6Intra-Relation	ConvG	5GNN	SEPSEPSEPGNNSEPGNNSEP-UEncoding	Trees	GenerationResidualConnectionDown	SamplingUp	SamplingGNNSE	MinimizationClusterAssignment0		…		1………1		…		0
Figure 2: Overview of our proposed framework SeBot, which mainly consists of three modules: 1) Node-level encoding tree
generation and bottom-up message passing; 2) Subgraph-level encoding trees generation and message-passing; 3) Relational
information aggregation beyond homophily. Contrastive learning loss and classification loss are later calculated on obtained
tree types of representations.
structural entropy [ 6,27,52,53,55] has been widely used in re-
cent years and has shown promising results in graph structure
learning [ 60], graph pooling[ 44], and other tasks. Since structural
entropy can be used as a metric to measure the complexity of graph
hierarchical structure, previous applications have mainly focused
on minimizing the structural entropy of the constructed encod-
ing tree. For instance, SEP [ 44] defines MERGE, REMOVE, and
FILL operations to update the constructed encoding tree based on
the principle of minimizing structural entropy. In this paper, we
employ structural entropy in a self-supervised manner to capture
information at both the node level and subgraph level.
3 PRELIMINARIES
In this section, we first illustrate the graph-based social bot detec-
tion task, followed by an introduction to the definition of graph
contrastive learning.
Definition 3.1. Graph-based Social bot detection. Graph-
based social bot detection can be regarded as a semi-supervised
node binary classification problem on a multi-relational graph. It
involves treating the accounts in social platforms as nodes and
the interactions such as "following" and "follower" as edges of
different relations. Constructed graph in this task can be formulated
asG={V,E,X}, whereV={𝑣𝑖|𝑖=1,2,...,𝑛}is the set of
all nodes,E=∪𝑅
𝑟=1E𝑟represents the set of edges formed by 𝑅
relations andXis the feature matrix. Row 𝑖ofXrepresents the
feature vector of the 𝑖-th node. Total detection process is to use the
graphGand the labels of training nodes Ytrain to predict the labels
of test nodes Ytest:
𝑓(G,Ytrain)→¯Ytest. (1)Definition 3.2. Graph Contrastive Learning. In the general
graph contrastive learning paradigm for node classification, two
augmented graphsG𝛼, andG𝛽are generated using different graph
augmentation methods (such as edge dropping, feature masking,
etc.) on the input graph G. Subsequently, an encoder consisting of
multi-layer graph neural networks is employed to generate node
representations including topological information existing in graph
structure. During the first training stage, these representations are
further mapped into an embedding space by a shared projection
head for contrastive learning. A typical graph contrastive loss,
InfoNCE [ 31], treats the same node in different views 𝑣𝛼
𝑖and𝑣𝛽
𝑖
as positive pairs and other nodes as negative pairs. The graph
contrastive learning loss L𝑖of node𝑣𝑖and total lossLcan be
formulated as:
L𝛼
𝑖=−𝑙𝑜𝑔(𝑒𝑠𝑖𝑚(z𝛼
i,z𝛽
i)/𝜏
Í𝑁
𝑗=11𝑗≠𝑖𝑒𝑠𝑖𝑚(z𝛼
i,z𝛼
j)/𝜏+𝑒𝑠𝑖𝑚(z𝛼
i,z𝛽
j)/𝜏),
L=𝐼𝑛𝑓𝑜𝑁𝐶𝐸(Z𝛼,Z𝛽)=𝑁∑︁
𝑖=1L𝛼
𝑖+L𝛽
𝑖,(2)
where𝑁is the batch size, 𝜏is the temperature coefficient, 1𝑗≠𝑖=1
when𝑗≠𝑖and𝑠𝑖𝑚(·,·)stands for cosine similarity function.
4 METHODOLOGY
4.1 Overview of SeBot
The total pipeline of SeBot is illustrated in Figure 2. To begin with,
an attributed multi-relational graph Gis constructed by represent-
ing social network interactions as edges. Subsequently, it is fed into
three different modules to obtain representations at multi-grained
levels under various receptive field scopes h𝑖=[h𝛼
𝑖∥h𝛽
𝑖∥h𝛾
𝑖].
3843KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
The two modules above are responsible for constructing encoding
trees by minimizing structural entropy for the entire graph view
G𝛼and𝑚-order subgraph view G𝛽respectively.G𝛽is formed by
the target node and surrounding neighbor nodes. The view G𝛾is
generated by edge removing. Then, bottom-up information prop-
agation is performed according to these encoding trees to obtain
node embeddings h𝛼
𝑖andh𝛽
𝑖. In the third module, to counteract
the intentional evasion behaviors of social bots, we devise a graph
convolutional layer that can make neighbors similar or discrimina-
tive adaptively while maintaining normalization. Simultaneously,
a relational channel-wise mixing (RCM) layer is proposed to inte-
grate information from different relations to obtain h𝛾
𝑖. Finally, the
fusion of the three modules involves computing cross-entropy loss
for classification and utilizing graph self-supervised contrastive
learning loss to capture shared information between three views,
enhancing the classification learning process.
4.2 Community-aware Hierarchical Augment
In social networks, some accounts may exhibit more pronounced
connections with each other due to shared interests, events, and
so on, thus forming communities. However, previous detection
methods have not effectively leveraged the community structure
information within social networks. To reveal the hierarchical struc-
ture within the graph, we utilize structural entropy minimization to
obtain fixed-height encoding trees, where the child nodes of each
node belong to the same community. For the sake of clarity, we first
illustrate the definition of structural entropy and its minimization
algorithm.
Structural Entropy. Structural entropy is initially proposed by
[27] to measure the uncertainty of graph structure information. The
structural entropy of a given graph G={V,E,X}on its encoding
Tree𝑇is defined as:
H𝑇(G)=−∑︁
𝑣𝜏∈𝑇𝑔𝑣𝜏
𝑣𝑜𝑙(V)log𝑣𝑜𝑙(𝑣𝜏)
𝑣𝑜𝑙(𝑣+𝜏), (3)
where𝑣𝜏is a node in 𝑇except for root node and also stands for a
subsetV𝜏∈V,𝑔𝑣𝜏is the number of edges connecting nodes in and
outsideV𝜏,𝑣+𝜏is the immediate predecessor of of 𝑣𝜏and𝑣𝑜𝑙(𝑣𝜏),
𝑣𝑜𝑙(𝑣+𝜏)and𝑣𝑜𝑙(V) are the sum of degrees of nodes in 𝑣𝜏,𝑣+𝜏and
V, respectively. The structural entropy of graph Gis the entropy of
the encoding tree with the minimum structural entropy: H(G) =
min∀𝑇{H𝑇(G)} . According to this definition, structural entropy
can be used to decode the hierarchical structure of a given graph
into an encoding tree as a measurement of community division. In
addition, the generated encoding tree 𝑇can be seen as the natural
multi-grained hierarchical community division result.
Minimization Algorithm. In addition to the optimal encoding
tree with the minimum structural entropy, a fixed level of commu-
nity partitioning is preferred for the specific scenario. Considering
this, the𝑘-dimension structural entropy of Gis defined as the
optimal encoding tree with a fixed height 𝑘:
H(𝑘)(G)= min
∀𝑇:Height(𝑇)=𝑘{H𝑇(G)}. (4)Algorithm 1: Structural entropy minimization algorithm
Input : input undirected graph G=(V,E)and a specific
height𝑘>1
Output: encoding tree 𝑇with a fixed height 𝑘
1initialize encoding tree 𝑇with root node 𝑣𝑟and nodes inV
as its children ;
2// Step 1: full-height binary coding tree construction ;
3while|𝑣𝑟.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛|> 2do
4 select child node pair ( 𝑣1𝑐,𝑣2𝑐)←
𝑎𝑟𝑔𝑚𝑎𝑥(𝑣1𝑐,𝑣2𝑐){H𝑇(G)−H𝑇𝑐(G)|𝑣1𝑐,𝑣2𝑐∈𝑣𝑟.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛}
;
5 Merge(𝑣1𝑐,𝑣2𝑐);
6end
7// Step 2: binary coding tree squeeze to height 𝑘;
8while𝐻𝑒𝑖𝑔ℎ𝑡(𝑇)>𝑘do
9 select node 𝑣𝜏←𝑎𝑟𝑔𝑚𝑖𝑛(𝑣𝜏){H𝑇(G)−H𝑇𝑚(G)|𝑣𝜏∈
𝑇&𝑣𝜏≠𝑣𝑟&𝑣𝜏∉V};
10 Drop(𝑣𝜏);
11end
12return encoding tree 𝑇;
The total process of generation of a encoding tree with a fixed
height𝑘can be divided into two steps: 1) construction of the full-
height binary encoding tree and 2) compression of the binary en-
coding tree to height 𝑘. Given root node 𝑣𝑟of the encoding tree 𝑇,
all original nodes in graph G=(V,E)are treated as leaf nodes.
We first define two iterative operations on 𝑇.
Definition 4.1. Assuming𝑣1𝑐and𝑣2𝑐as two children of root node
𝑣𝑟, the function Merge(𝑣1𝑐,𝑣2𝑐)is defined as adding a new node 𝑣𝑖
as the child of 𝑣𝑟and the parent of 𝑣1𝑐and𝑣2𝑐:
𝑣𝑖.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛 ={𝑣1
𝑐,𝑣2
𝑐},
𝑣𝑟.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛 ={𝑣𝑖}∪𝑣𝑟.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛.(5)
Definition 4.2. Given node 𝑣𝜏and its parent node 𝑣+𝜏in𝑇, the
function Drop(𝑣𝜏)is defined as adding the children of 𝑣𝜏and itself
to the child set of 𝑣+𝜏:
𝑣+
𝜏.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛 =𝑣+
𝜏.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛∪𝑣𝜏.𝑐ℎ𝑖𝑙𝑑𝑟𝑒𝑛. (6)
The generation of the encoding tree with a fixed height 𝑘pri-
marily involves iterations through two operations to obtain the
minimum structural entropy, which is shown in Algorithm 1. To
start with, we initialize an encoding tree 𝑇by treating all nodes in V
as children of root node 𝑣𝑟. During step 1, an iterative Merge(𝑣1𝑐,𝑣2𝑐)
is conducted with the aim of minimizing structural entropy to ob-
tain a binary coding tree without height limitation. In this way,
selected leaf nodes are combined to form new community divisions
with minimal structural entropy. Then, to compress height to a
specific hyperparameter 𝑘,Drop(𝑣𝜏)is leveraged to merge small
divisions into larger ones, and thus the height of the coding tree is
reduced, which is still following the structural entropy minimiza-
tion strategy. Eventually, the encoding tree with fixed height 𝑘and
minimal structural entropy is obtained.
3844SeBot: Structural Entropy Guided Multi-View Contrastive Learning for Social Bot Detection KDD ’24, August 25–29, 2024, Barcelona, Spain
Obtained encoding tree in this manner can also be seen as the
anchor view that includes minimal but sufficient important informa-
tion in an unsupervised manner [ 43]. The quality of views generated
by graph augmentation technologies plays a crucial role in learning
informative representations. According to graph information bottle-
neck theory (GIB) [ 46], retaining important information in a graph
view should involve maximizing mutual information between the
output and labels while reducing mutual information between input
and output. This can be formally expressed as follows:
GIB: max𝐼(𝑓(𝐺);𝑌)−𝛽𝐼(𝐺;𝑓(𝐺)), (7)
where𝐼(·;·)represents the mutual information between inputs. A
lot of graph augmentation methods have been proposed, including
edge removal, feature masking, graph diffusion, and more. Yet, these
methods cannot ensure the preservation of essential information
regarding downstream tasks and may introduce class-redundant
noise.
4.3 Message Passing on Encoding Tree
To obtain node representations and subgraph representations, the
message passing on the encoding tree is carried out bottom-up,
where the generated parent nodes aggregate information from their
child nodes. This process begins with the leaf nodes (i.e., the nodes
inV) at the first layer transmitting information to their second-
layer parent nodes. Specifically, given the cluster assignment matrix
S𝑡∈R𝑛𝑡×𝑛𝑡+1where𝑛𝑡and𝑛𝑡+1are the number of nodes and
assigned clusters (i.e. nodes in the next layer) in the 𝑡-th layer,
each element in S𝑡equal to 1 indicates that the node belongs to a
corresponding cluster. The adjacency matrix A𝑡+1∈R𝑛𝑡+1×𝑛𝑡+1and
the hidden layer representations P𝑡+1∈R𝑛𝑡+1×𝑑for the(𝑡+1)-th
layer can be obtained by matrix multiplication:
SEP :A𝑡+1=S⊤
𝑡A𝑡S𝑡;P𝑡+1=S⊤
𝑡H𝑡, (8)
where A𝑡is the adjacency matrix and H𝑡denotes the hidden fea-
tures martix in the 𝑡-th layer. As pooling continues, the number of
nodes decreases. To obtain representations of nodes in V, we fur-
ther employ unpooling to ensure that the number of nodes matches
the number of nodes in V:
SEP-U :A𝑡+1=S𝑡A𝑡S⊤
𝑡;P𝑡+1=S𝑡H𝑡, (9)
where S𝑡is the same matrix used in previous pooling layers. The
node-level representation h𝛼
𝑖is obtained through multiple layers
of SEP to obtain high-order community representations and multi-
layer SEP-U reconstructions.
On the other hand, the representation of each subgraph extracted
for every target user can be obtained by concatenating the results
of SEP pooling layers:
SEP-G :h𝛽,𝑡
𝑖=𝑅𝑒𝑎𝑑𝑜𝑢𝑡(𝑆𝐸𝑃𝑡(𝐺𝐶𝑁𝑡(H𝑡,A𝑡),S𝑡))
h𝛽
𝑖=𝐶𝑜𝑛𝑐𝑎𝑡(h𝛽,1
𝑖,···,h𝛽,𝑙
𝑖),(10)
where𝑆𝐸𝑃𝑡(·)denotes the 𝑡-th SEP layer and 𝑅𝑒𝑎𝑑𝑜𝑢𝑡(·)can be
chosen between average pooling and sum pooling. These high-
order representations obtained in this manner enable social bot
detection to be implemented through subgraph classification.4.4 Relational Information Aggregation
To alleviate graph adversarial attacks by social bots (i.e., actively
establishing relationships with humans), we propose a relational
information aggregation mechanism beyond homophily and a rela-
tion channel-wise mixing layer in this subsection.
4.4.1 Relational graph convolution beyond resemblance limitation.
Previous work [ 15] has adopted RGCN to detect bot accounts
and has shown promising success in modeling different relations.
However, the information aggregation of RGCN is based on the
homophily assumption (i.e., nodes belonging to the same class
tend to be connected), and advanced bots may consciously interact
more with humans. Considering this issue, we incorporate high-
frequency information (i.e., the differences between nodes) into the
information aggregation strategy of RGCN through the generation
of negative attention coefficients. However, positive and negative
weights generated directly through the tanh activation function
can not be normalized. To ensure the consistency of information
aggregation, we further introduce the Gumbel-Max reparametriza-
tion trick [ 22] to make the weights close to 1 or -1. Specifically, the
attention weight 𝜔𝑟,{𝑙}
𝑖𝑗of the edge𝑒𝑖𝑗in relation𝑟and the layer 𝑙
is generated by:
𝜔𝑟,{𝑙}
𝑖𝑗=tanh
(g{𝑙},⊤
𝑟h
h{𝑙−1}
𝑖∥h{𝑙−1}
𝑗i
+𝑙𝑜𝑔𝜖−𝑙𝑜𝑔(1−𝜖))/𝜏𝐺
,
(11)
where g{𝑙}
𝑟∈R2𝐷denotes the trainabele parameter, 𝜖∼𝑈𝑛𝑖𝑓𝑜𝑟𝑚(0,1)
is the sampled Gumbel random variate and 𝜏𝐺is a small tempera-
ture used to amplify 𝜔𝑟,{𝑙}
𝑖𝑗. In this manner, when the weights are
close to 1, it retains similar information with neighbors, whereas
when close to -1, it preserves dissimilar information. In addition,
normalization can be directly performed based on the number of
neighbors:
h𝑟,{𝑙}
𝑖=1
|𝑁𝑟(𝑣𝑖)|∑︁
𝑣𝑗∈𝑁𝑟(𝑣𝑖)𝜔𝑟,{𝑙}
𝑖𝑗h{𝑙−1}
𝑗𝑊{𝑙}
𝑟, (12)
where𝑁𝑟(𝑣𝑖)is the neighbors of 𝑣𝑖and𝑊{𝑙}
𝑟is the weight matrix.
Due to the adopted parametrization tick, normalization is approxi-
mately satisfied by |𝑁𝑟(𝑣𝑖)|≈Í
𝑣𝑗∈𝑁𝑟(𝑣𝑖)|𝜔𝑟,{𝑙}
𝑖𝑗|.
4.4.2 Relational Channel-wise Mixing. After aggregating informa-
tion independently across different relations, it is necessary to
merge this relational information to acquire representations with
richer semantics. Previous adaptive method [ 13] is limited to gen-
erating normalized weight coefficients for representations in each
relation, inevitably introducing some noise information present in
specific relations. Inspired by [ 28], we propose a relational channel-
wise adaptive fusion layer. Specifically, given the embeddings h𝑟,{𝑙}
𝑖
generated in each relation and at layer 𝑙, we first calculate the
weight vector of the relation:
ˆu𝑟,{𝑙}
𝑖=[h1,{𝑙}
𝑖∥···∥ h𝑅,{𝑙}
𝑖]ˆ𝑊{𝑙}
𝑟, (13)
where ˆ𝑊{𝑙}
𝑟is the weight matrix and [·||·] is the concat operation.
3845KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
Then, we apply a channel-wise softmax function to normalize
weight coefficients at each feature channel:
[u1,{𝑙}
𝑖,..., u𝑅,{𝑙}
𝑖]=𝑆𝑜𝑓𝑡𝑚𝑎𝑥([ˆu1,{𝑙}
𝑖,..., ˆu𝑅,{𝑙}
𝑖]).(14)
Last, u𝑟,{𝑙}
𝑖can be used to mix representations from different
relations and add transformed original features:
h{𝑙}
𝑖=h{𝑙−1}
𝑖𝑊{𝑙}
𝑟𝑜𝑜𝑡+𝑅∑︁
𝑟=1h𝑟,{𝑙}
𝑖⊙u𝑟,{𝑙}
𝑖, (15)
where⊙denotes the Hadamard product operation and 𝑊{𝑙}
𝑟𝑜𝑜𝑡is the
weight matrix to transform original features.
In fact, when each edge weight 𝜔𝑟,{𝑙}
𝑖𝑗=1andu𝑟,{𝑙}
𝑖=1, the
proposed encoder is equal to RGCN and thus can be seen as an
extension of it. Besides, 𝐿layers of the two networks described
above are used to generate h𝛾
𝑖onG𝛾.
4.5 Multi-Task Optimization and Learning
After obtaining node representations from the three modules, it is
necessary to design the loss function as the learning objective. The
primary objective of the model remains classification, to identify
bot accounts. We employ a two-layer MLP as the classification
layer for the concatenation h𝑖=[h𝛼
𝑖∥h𝛽
𝑖∥h𝛾
𝑖]and calculate the
classification loss using binary cross-entropy:
L𝐶𝐸=−∑︁
𝑣𝑖∈V𝑡[𝑦𝑖𝑙𝑜𝑔(𝑝𝑖)+(1−𝑦𝑖)𝑙𝑜𝑔(1−𝑝𝑖)]
𝑝𝑖=𝑠𝑜𝑓𝑡𝑚𝑎𝑥(𝜎(h𝑖𝑊1+𝑏1)𝑊2+𝑏2).(16)
Additionally, as shown in Figure 1, in real-world scenarios, hi-
erarchical community structure and heterophily coexist in social
networks. Our goal is to learn unified node representations that can
incorporate both types of information simultaneously. However, to
our knowledge, there are no methods that capture both types of
information simultaneously. Therefore, we use three modules to ob-
tain three representations, h𝛼
𝑖,h𝛽
𝑖, and h𝛾
𝑖, each containing different
semantic information. Specifically, h𝛼
𝑖includes global hierarchical
structure information, h𝛽
𝑖includes local hierarchical structure in-
formation, and h𝛾
𝑖includes specific category information of the
neighborhood.
However, representations obtained through independent mod-
ules are often one-sided. Therefore, we further use self-supervised
contrastive learning to capture the consistency between different
representations. Specifically, by maximizing the mutual informa-
tion between different representations. The proposed two level
contrastive learning losses L𝑁𝐶𝐿 andL𝑆𝐶𝐿are computed based
on the representations of all nodes (i.e., H𝛼,H𝛽andH𝛾) across
different views:
L𝑁𝐶𝐿=𝐼𝑛𝑓𝑜𝑁𝐶𝐸(𝜓𝑁(H𝛼),𝜓𝑁(H𝛾)),
L𝑆𝐶𝐿=𝐼𝑛𝑓𝑜𝑁𝐶𝐸(𝜓𝑆(H𝛽),𝜓𝑆(H𝛾)),(17)
where𝜓𝑁(·)and𝜓𝑆(·)are defined as projection heads for node-
level and subgraph-level contrastive learning, respectively. In this
way, two seemingly contradictory challenges are unified and ad-
dressed in a self-supervised manner, rather than being simply solved
independently.Algorithm 2: The training process of SeBot
Input : input undirected graph G=(V,E,X)and a
specific height 𝑘>1, hyperparameter 𝑚,
temperature 𝜏and loss weights 𝜆1and𝜆2
Output: node representations H
1generate undirected graph view G𝛼and its𝑚-hop subgraph
viewG𝛽;
2generate viewG𝛾through edge dropping ;
3minimizing structural entropy to construct encoding trees
forG𝛼andG𝛽according to Algorithm 1 ;
4for𝑒𝑝𝑜𝑐ℎ←1,2,···do
5 for𝑣𝑖∈Vdo
6 obtain node embedding h𝛼
𝑖of𝑣𝑖fromG𝛼←
Equation (8-9) ;
7 obtain node embedding h𝛽
𝑖of𝑣𝑖fromG𝛽←
Equation (10) ;
8 obtain node embedding h𝛾
𝑖of𝑣𝑖fromG𝛾←
Equation (11-15) ;
9 end
10 classification lossL𝐶𝐸←Equation (16) ;
11 contrastive lossL𝑁𝐶𝐿 andL𝑆𝐶𝐿←Equation (17) ;
12 total lossL← Equation (18) ;
13 loss backward ;
14end
15return the predicted label set for the test nodes ˆYtest.
Ultimately, the overall loss of the proposed method is calculated
by summing the aforementioned three learning losses:
L=L𝐶𝐸+𝜆1L𝑁𝐶𝐿+𝜆2L𝑆𝐶𝐿. (18)
where𝜆1and𝜆2are two hyperparameters ranging from 0 to 1, used
to adjust the magnitudes and weights of different losses.
4.6 Complexity Analysis
Given a mutli-relational graph G={V,E},𝑛=|V|and𝑚=|E|,
the runtime complexity of Algorithm 1 is 𝑂(ℎ𝑚𝑎𝑥(𝑚𝑙𝑜𝑔𝑛+𝑛)), in
whichℎ𝑚𝑎𝑥 is the height of coding tree 𝑇after the first step. In
general, the coding tree 𝑇tends to be balanced in the process of
structural entropy minimization, thus, ℎ𝑚𝑎𝑥 will be around 𝑙𝑜𝑔𝑛 .
Besides, a large-scale social network generally has more edges than
nodes, i.e.,𝑚≫𝑛, thus the runtime of Algorithm 1 almost scales
linearly in the number of edges.
The overall time complexity of the three proposed modules is
𝑂(𝑛+𝑚+ℎ𝑚𝑎𝑥(𝑚log𝑛+𝑛)). Specifically, in Section 4.3, the time
complexities of SEP, SEP-U, and SEP-G are all 𝑂(𝑛). In Section 4.4,
the proposed relational information aggregation has a time com-
plexity of𝑂(𝐿(𝑅·𝑛+𝑚)), where𝐿represents the number of layers
and𝑅represents the number of relations.
5 EXPERIMENTS
In this paper, we propose the following research questions for a
deep evaluation of the proposed SeBot framework:
•RQ1: How does SeBot perform compared with other baselines?
3846SeBot: Structural Entropy Guided Multi-View Contrastive Learning for Social Bot Detection KDD ’24, August 25–29, 2024, Barcelona, Spain
•RQ2: How does SeBot benefit from its different modules?
•RQ3: How does SeBot perform concerning different hyperpa-
rameters?
•RQ4: CanSeBot generate more class-discriminative node repre-
sentations than other baselines?
•RQ5: CanSeBot effectively address the two challenges men-
tioned in the introduction?
5.1 Experimental Setup
5.1.1 Datasets. TwiBot-20 [14] and MGTAB [36] are adopted to
evaluate the performance of SeBot. TwiBot-20 contains 229,580
accounts extracted from Twitter and their following and follower
interactions. MGTAB consists of 10,199 accounts and 7 types of
relations including follower, friend, mentioned, reply, quoted, refer-
ence, and hashtag. Details of two datasets are shown in Table 1, in
which homo represents the proportion of edges between nodes of
the same class. In addition, we follow the same splits of datasets
as [14] and [36] for training, validating, and testing.
5.1.2 Baselines. We compare SeBot with previous graph-based
social bot detection methods as well as typical GNNs beyond ho-
mophily and self-supervised graph contrastive learning methods.
All selected baselines are listed below:
•GCN&GAT GCN [ 25] is a typical graph convolution network
that can also be seen as a low-pass filter. GAT [ 39] lies on an
attention-based information aggregation mechanism.
•GraphSage [19] is an inductive GNN capable of predicting node
types that were not seen during the training process.
•FAGCN [4] can adaptively utilize neighbor representations to
be similar or diverse by breaking the limitation of low-frequency
information aggregation.
•H2GCN [57] introduces three simple designs: separating self
and neighbor embeddings, high-order neighbor information, and
concatenating node representations.
•GPRGNN [8] employs a learnable weight for each order of neigh-
bor information.
•Alhosseini et al. [1] is the first to employ graph convolutional
neural networks for detecting social bots.
•FriendBot [2] utilizes network, content, temporal, and user fea-
tures obtained from the communication network, and employs
machine learning classifiers for classification purposes.
•RGT [13] constructs heterogeneous views through various re-
lations and proposes the Relation Graph Transformer to obtain
node representations.
•BotRGCN [15] applies relational graph neural networks to per-
form social bot detection. RGT andBotRGCN are the current
SOTA methods for social bot detection using GNNs.
•DGI [40] captures consistency between nodes and the entire
graph by maximizing local-global mutual information.
•GRACE [58] employs feature masking and edge removal as
graph augmentation techniques to generate views. It also uses a
discriminator to encourage a uniform distribution.
•GBT [3] calculates the empirical cross-correlation matrix using
node representations and computes the loss using the Barlow-
Twins loss function.Table 1: Statistics of TwiBot-20 and MGTAB.
Dataset #nodes #e
dges class #class #relation homo
TwiBot-20 229,580 227,979human
5,2372 0.53bot 6,589
MGTAB 10,199 1,700,108human
7,4517 0.84bot 2,748
Table 2: Hyerparameter setting on TwiBot-20 and MGTAB.
Parameter T-20
MGTAB Parameter T-20
MGTAB
optimizer AdamW
AdamW hidden dimension 32
32
learning rate 0.01 0.01 subgraph order 𝑚 2
1
dropout 0.5 0.5 L2 regularization
3e-3 3e-3
loss weight 𝜆1 0.09 0.05 loss weight 𝜆2 0.03
0.05
tree depth𝑘 6 6 maximum epo
chs 70 200
temperture𝜏 0.1 0.1 trick temperatur
e𝜏𝐺 0.01 0.01
5.1.3 Hyperparameter Setting. Hyperparameter settings of our ex-
periments on TwiBot-20 and MGTAB are listed in Table 2. We used
the AdamW optimizer to update the parameters. The learning rate
is set to 0.01, which is larger compared to baseline models like
RGT, resulting in faster convergence. The dropout mechanism is
employed to prevent overfitting and maintain high generalization
capacity. The weight of two contrastive loss 𝜆1and𝜆2are set ac-
cording to sensitive study results. The tree depth is set to 6, which
is a compromise between training time and accuracy. Gumbel-Max
reparametrization trick temperature 𝜏𝐺is set to 0.01 to amplify
edge attention.
5.1.4 Implementation. Pytorch [ 32] and Pytorch Geometric [ 17]are
leveraged to implement SeBot and other baselines. All experiments
are conducted on a cluster with 8 GeForce RTX 3090 GPUs with
24 GB memory, 16 CPU cores, and 264 GB CPU memory. See our
code1for more details.
5.2 RQ1: Performance Analysis
To answer RQ1, we evaluate the performance of SeBot and 11 other
baselines on two social bot detection benchmarks. The experimental
results are presented in Table 3, which illustrates that:
•SeBot demonstrates superior performance compared to all other
baselines on both datasets in terms of Accuracy and F1-score on
both datasets. Furthermore, it achieves relatively high results in
terms of Recall and Precision on TwiBot-20 and MGTAB, indicat-
ing that SeBot is better at uncovering social bots and possesses
stronger robustness. On the other hand, SeBot demonstrates the
better generalization performance across both datasets, a feat
that other methods cannot achieve.
•Compared to traditional GNNs (i.e., GCN, GAT, and GraphSage),
SeBot not only considers the community structure but also is
conscious of the adversarial structure intentionally constructed
by social bots, thus exhibiting stronger detection performance.
This also highlights the need for extra fine-grained designs when
applying graph neural networks to social bot detection.
•Compared to GNNs beyond homophily (i.e., FAGCN, H2GCN,
GPRGNN), SeBot extends further into the social bot detection
1https://github.com/846468230/SEBot
3847KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
Table 3: Performance comparison on TwiBot-20 and MGTAB in terms of accuracy, F1-score, recall and precision. The best and
second-best results are highlighted with bold and underline .’-’ indicates that the method is not applicable to MGTAB due to
lack of unprocessed raw dataset.
METHODsTwiBot-20 MGTABTYPE
Accuracy F1-scor
e Recall Precision Accuracy F1-scor
e Recall Precision
GCN 77.53±1.73 80.86 ±
0.86 87.62±3.31 75.23±3.08 80.07±0.77 51.71 ±
4.05 75.07±5.93 40.08±5.90
CLASSIC GAT 83.27±0.56 85.25 ±
0.38 89.53±0.87 81.39±1.18 85.07±1.19 69.32 ±
4.02 77.33±2.19 63.34±7.31
GraphSage 85.44±0.43 86.68 ±
0.61 87.66±2.08 85.78±0.86 88.58±1.11 77.55 ±
2.00 82.43±2.39 73.32±3.12
FAGCN 85.43±0.40 87.36 ±
0.32 93.00±0.73 82.39±0.70 88.11±1.43 77.43 ±
3.20 76.36±7.90 79.19±3.41
HETEROPHILY H2GCN 85.84±0.34 87.57±
0.15 92.19±1.56 83.44±1.32 89.09±1.16 79.99±
1.53 81.00±5.94 79.70±5.01
GPRGNN 86.05±0.34 87.50 ±
0.30 90.25±0.29 84.92±0.41 89.07±1.20 80.48 ±
1.62 83.54±1.24 77.67±2.37
Alhosseini et al. 59.88±0.59 72.07±
0.48 95.69±1.93 57.81±0.43 - - - -
SOTA
sBotRGCN 85.75±0.69 87.25 ±
0.74 90.19±1.72 84.52±0.54 89.09±0.61 79.66±0.82 80.22 ±
3.07 79.39±4.00
FriendBot 75.89±0.47 79.97 ±
0.34 88.94±0.59 72.64±0.52 - - - -
RGT 86.57±0.42 88.01±0.42 91.06±0.80 85.15 ±
0.28 89.00±1.35 79.26 ±
2.87 78.51±6.25 80.48±2.93
DGI 84.93±0.31 87.09 ±
0.36 93.94±1.13 81.17±0.26 87.08±0.98 75.67 ±1.62
74.61±2.58 76.81±1.56
CONTRASTI VE GBT 84.74±0.92 86.87 ±
0.79 93.28±1.14 81.29±0.92 84.68±0.53 70.12 ±
1.33 66.87±2.30 73.80±1.90
GRACE 84.74±0.88 86.90 ±
0.84 93.56±1.57 81.13±0.55 83.16±1.60 66.99 ±
3.90 63.83±6.00 70.77±2.02
SeBot 87.24±0.10 88.74 ±
0.13 92.97±1.16 84.90±0.79 90.46±1.44 82.12 ±
2.42 81.73±2.77 82.52±2.19 OURs
scenario, specifically on multi-relation directed graphs. In addi-
tion, better performance also implies the significant importance
of considering adversarial heterophily in social bot detection.
•Compared with state-of-the-art graph-based social bot detection
methods (i.e., BotRGCN and RGT), SeBot achieves the best accu-
racy and F1-score as it further takes into account the structural
semantics present in social networks, which proves to be po-
tent for uncovering deeply concealed bots. Meanwhile, previous
graph-based detection methods relied on traditional information
aggregation patterns and could not fully capture the structural
information within the graph.
•Compared with typical self-supervised graph contrastive learn-
ing methods (i.e., DGI, GBT, and GRACE), SeBot retains essential
information within the graph by minimizing structural entropy,
while other graph augmentation methods may unavoidably in-
troduce noise or lead to the loss of crucial information relevant to
downstream tasks. It’s important to mention that class imbalance
in MGTAB significantly impacts the performance of contrastive
learning techniques like DGI, leading to suboptimal results across
various metrics.
5.3 RQ2: Ablation Study
To address RQ2, we conducted ablation experiments as follows. We
separately removed the encoding tree of the entire graph, encoding
trees of subgraphs and the proposed RCM layer, and evaluated the
performance of the residual modules. We also substitute RGCN for
the encoder, and adopt different policies of graph augmentation.
The results are presented in Table 4. Removing different modules
from SeBot resulted in performance degradation on TwiBot-20
and MGTAB datasets, indicating the pivotal role in overall model
effectiveness. This emphasizes the importance of co-considering
community structure and heterophilic relations in social bot de-
tection. By comparison, graph augmentation, feature masking, or
dropout may disrupt the original feature distribution structure, a
critical step in node classification, meanwhile, adding edges may
introduce some additional structure noise, and thus lead to model
performance degradation.Table 4: Ablation study of SeBot on TwiBot-20 and MGTAB.
SettingsTwiBot-20 MGTAB
Accuracy F1-scor
e Accuracy F1-scor
e
Full model 87.24±0.10 88.74±
0.13 90.46±1.44 82.12±
2.42
w/o entire
graph tree 86.39±0.30 87.84±
0.26 89.71±0.98 81.09±
1.41
w/o subgraph trees 86.45±0.07 88.02±
0.09 90.07±1.04 81.79±
1.73
w/o RCM layer 86.24±0.49 87.69±
0.55 89.58±1.52 80.51±
2.63
RGCN as encoder 86.35±0.24 87.96±
0.26 90.32±1.48 81.99±2.44
Feature Mask 84.93±0.67 87.00±
0.70 90.00±1.28 81.59±
1.85
Feature Dropping 83.39±0.61 85.53±
0.92 89.36±1.48 80.58±
1.27
Edge Adding 86.52±0.42 87.96±0.53 89.29±1.39 80.60±
2.95
5.4 RQ3: Sensitive Analysis
To answer RQ3, we conducted experiments on TwiBot-20 (MGTAB
see in Appendix A.1) to analyze the impact of fixed encoding tree
depth and contrastive losses. We set 𝑘to 6, 7, and 8, and varied
hyperparameters 𝜆1and𝜆2from 0.01 to 0.1 in steps of 0.01. The
results of the experiments are presented in the form of heatmaps in
Figure 3. From this, we can intuitively observe that increasing the
depth of the tree improves the overall performance of the proposed
model. A greater depth enables a finer-grained community parti-
tion, benefiting social bot detection, but it requires longer training
time. Further, as the tree depth increases, the impact of hyperpa-
rameters𝜆1and𝜆2on model performance exhibits a fluctuating
pattern, initially decreasing and then increasing. Notably, when
𝑘=7, the model’s accuracy shows minimal variation across differ-
ent hyperparameters. However, increasing or decreasing 𝑘results
in greater sensitivity of the accuracy to changes in the hyperpa-
rameters. This corresponds to our assertion in Section 4.2 that, in
practical scenarios, a specific tree depth is generally preferred.
5.5 RQ4: Visualization
To address RQ4, we visually represent the 128-dimensional node
embeddings generated by GCN, FAGCN, BotRGCN, RGT, GRACE,
andSeBot on TwiBot-20 by projecting them onto a 2-dimensional
3848SeBot: Structural Entropy Guided Multi-View Contrastive Learning for Social Bot Detection KDD ’24, August 25–29, 2024, Barcelona, Spain
0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
87.2486.8186.9086.3186.4886.9885.7186.3986.3986.81
86.5687.2487.3287.0787.0785.8887.0786.7386.4886.64
86.4886.9087.1586.8187.2487.1586.7386.9086.3986.98
87.1586.9886.9087.0787.4987.4087.2486.8187.0787.32
86.5686.4886.8186.9887.2486.7386.8187.1586.5686.73
86.6486.9087.2487.3286.8186.6486.8186.7387.0786.90
86.5686.6486.9086.6486.7386.7386.3987.0786.9086.73
86.9086.7386.6486.4886.4886.6486.3986.6486.7386.81
86.4886.9086.7386.4886.5686.4886.0586.5686.6486.73
86.6486.6486.3186.4886.8186.3986.3986.5686.6486.56
Tree… depth…k=6… on… TwiBot-200.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
86.9886.9086.7387.1586.8186.3187.2486.5686.0586.31
86.7386.7386.0587.3287.2486.8187.0787.3286.1486.81
86.2287.2487.4086.7387.0787.4086.8187.0786.3185.97
86.5686.6486.7386.9087.2486.8187.2486.9887.2486.98
86.9087.0786.9886.8187.0786.3987.0787.0786.5686.98
87.2486.9886.8187.0786.8187.0787.0787.0786.8186.31
86.9087.0786.9886.9886.8186.7386.8186.8186.8186.64
86.9086.9086.8186.9086.9887.3286.9087.0787.3286.98
87.0786.9887.5787.0786.9887.1587.2486.3187.2486.64
87.1587.2486.7387.3287.1587.3286.9086.9886.4886.81
Tree… depth…k=7… on… TwiBot-200.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
86.9087.0786.2286.9086.8185.4686.3986.3986.2286.56
87.1586.7386.9087.3286.9886.6486.0586.5686.3986.22
86.9886.6487.1586.8186.6486.5686.7386.3186.5686.48
87.0786.3986.9086.5686.5686.8186.5686.9086.6486.31
87.3286.9086.7386.3186.8186.7386.7386.3186.5686.56
87.0786.8186.2285.8886.1486.2286.7386.4886.1486.31
86.9886.3985.9786.3986.5686.4886.9086.9086.6486.22
86.3986.2286.8186.3186.0586.3986.4886.3186.8185.97
86.3186.4886.8186.7386.6486.1485.7186.0586.3186.64
86.6486.3986.4886.8186.3986.5685.9785.7186.2286.22
Tree… depth…k=8… on… TwiBot-2085.085.586.086.587.087.5
Figure 3: Sensitive analysis of hyperparameter 𝜆1and𝜆2on TwiBot-20.
(a) GCN
 (b) FAGCN
 (c) BotRGCN
 (d) RGT
 (e) GRACE
 (f)SeBot
Figure 4: Account representations visualization on TwiBot-20. Redrepresents bots, while blue represents humans.
space using T-SNE [ 38], as depicted in Figure 4. The embeddings
from GCN and BotRGCN exhibit more scattering, whereas FAGCN,
RGT, and our SeBot produce denser embeddings. GRACE embed-
dings are quite uniform but suffer from the class collapse issue,
where nodes from different classes are located closely to each
other [ 56] due to the absence of label information. It is worth not-
ing that, compared to RGT and FAGCN, our method exhibits local
clustering rather than smooth curves visible in 2-dimensional space.
This implies that nodes of similar features or belonging to the same
community tend to aggregate together in clusters or beads. This
also indicates the ability of our method to capture the inherent com-
munities present in the graph structure. Overall, the embeddings
generated by SeBot demonstrate relatively better class discrimina-
tion compared to other methods, and the inclusion of reparameteri-
zation techniques ensures that the representations avoid excessive
clustering.
5.6 RQ5: Case Study
To answer RQ5, we visualize a local community consisting of 3
subcommunities and 7 social accounts, one of which is a bot ac-
count. Due to the employment of the reparameterization technique,
edge weights generated adaptively are equal to or near 1 or -1, and
edges of two different colors are to represent them, respectively. As
shown in Figure 5, social networks contain both the edges between
nodes of the same class and the edges between nodes of different
classes. The edge weight adaptive mechanism proposed by us can
simultaneously model both types of edges by enabling positive
and negative edge weights. Furthermore, the fine-grained hierar-
chical community structure is obtained by minimizing structural
entropy with a height constraint. Message passing on the encod-
ing tree provides higher-order feature information favorable for
classification.
User A
Rated (E) for Everyone. Official EA 
SPORTS account for the FIFA franchise. Followers: 7723523 
Friends: 348
FUT Future Star no more; @Inter_en’s 
Lautaro Martínez’s time is now 
User B
Thaofficial page for Erigga aka 
paperboi ... emirate empire/epic media.Followers: 646773 
Friends: 2448
Congrats you won 🙌🏻🙌🏻 send your 
account and phone number
User C
Spanish: @LigadeCampeones Japanese: 
@UCLJapan U19: @UEFAYouthLeagueFollowers:30042227 
Friends: 535
Mission accomplished. @FCBayern are 
champions of Europe.
User D
Steady SteadyFollowers: 0
Friends: 91
domain: Politics
User E
News & Updates: Become a part of the 
@XboxAmbassadorsFollowers: 1587982
Friends: 273256
Players should once again be able to join 
matches in Tom Clancy’s Ghost Recon 
Breakpoint. 
User G
@LaLiga in English. @LaLigaArab | 
@LaLigaJP | https://t.co/Gw30bq46Jd |Followers: 702974 
Friends: 225
Former captain @ivanrakit tic is BACK 
at @SevillaFC_ENG!BotF
A good place to play 11 v 11 competitive 
FIFA Pro Clubs! Followers: 1 
Friends: 11
'@EdCarterRS Hey!, would you be able 
to help me out with some stuff with  fifa
league imdoing? 
Figure 5: A case study of local community structure and gen-
erated edge attention. The same background color represents
belonging to the same sub-community, with the same parent
node on the constructed encoding tree.
6 CONCLUSION
In this paper, we propose SeBot, a novel graph-based social bot
detection framework that takes into consideration both commu-
nity structure and adversarial behaviors of social bots. SeBot ad-
dresses the aforementioned issues using three separate modules
that leverage structural entropy minimization and a heterophily-
aware encoder. SeBot employs self-supervised contrastive learning
to unify and learn the intrinsic characteristics of nodes more ef-
fectively. Comprehensive experiments show that SeBot exhibits
superior generalizability and robustness on two real-world datasets
compared with all other baselines.
ACKNOWLEDGMENTS
This work was supported by the National Key Research and De-
velopment Program of China through the grants 2022YFB3104700,
2022YFB3105405, 2021YFC3300502, NSFC through grants 62322202
and 61932002, Beijing Natural Science Foundation through grant
4222030, Guangdong Basic and Applied Basic Research Founda-
tion through grant 2023B1515120020, Shijiazhuang Science and
Technology Plan Project through grant 231130459A.
3849KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
REFERENCES
[1]Seyed Ali Alhosseini, Raad Bin Tareaf, Pejman Najafi, and Christoph Meinel.
2019. Detect me if you can: Spam bot detection using inductive representation
learning. In WWW. 148–153.
[2]David M Beskow and Kathleen M Carley. 2020. You are known by your friends:
Leveraging network metrics for bot detection in twitter. SMA (2020).
[3]Piotr Bielak, Tomasz Kajdanowicz, and Nitesh V Chawla. 2022. Graph Barlow
Twins: A self-supervised representation learning framework for graphs. KBS 256
(2022), 109631.
[4]Deyu Bo, Xiao Wang, Chuan Shi, and Huawei Shen. 2021. Beyond low-frequency
information in graph convolutional networks. In AAAI. 3950–3957.
[5]Nan Cao, Conglei Shi, Sabrina Lin, Jie Lu, Yu-Ru Lin, and Ching-Yung Lin. 2015.
Targetvue: Visual analysis of anomalous user behaviors in online communication
systems. TVCG 22, 1 (2015), 280–289.
[6]Yuwei Cao, Hao Peng, Angsheng Li, Chenyu You, Zhifeng Hao, and Philip S Yu.
2024. Multi-Relational Structural Entropy. In UAI.
[7]Nikan Chavoshi, Hossein Hamooni, and Abdullah Mueen. 2017. Temporal pat-
terns in bot activities. In WWW. 1601–1606.
[8]Eli Chien, Jianhao Peng, Pan Li, and Olgica Milenkovic. 2021. Adaptive Universal
Generalized PageRank Graph Neural Network. In ICLR. OpenReview.net.
[9] Stefano Cresci. 2020. A decade of social bot detection. Commun ACM (2020).
[10] Ashok Deb, Luca Luceri, Adam Badaway, and Emilio Ferrara. 2019. Perils and
challenges of social media and election manipulation analysis: The 2018 us
midterms. In WWW. 237–247.
[11] Nicolas Guenon des Mesnards, David Scott Hunter, Zakaria el Hjouji, and Tauhid
Zaman. 2022. Detecting bots and assessing their impact in social networks.
Operations Research 70, 1 (2022), 1–22.
[12] Shangbin Feng, Zhaoxuan Tan, and etc. Herun Wan. 2022. TwiBot-22: Towards
Graph-Based Twitter Bot Detection. In NeurIPS.
[13] Shangbin Feng, Zhaoxuan Tan, Rui Li, and Minnan Luo. 2022. Heterogeneity-
aware twitter bot detection with relational graph transformers. In AAAI.
[14] Shangbin Feng, Herun Wan, Ningnan Wang, Jundong Li, and Minnan Luo. 2021.
Twibot-20: A comprehensive twitter bot detection benchmark. In CIKM.
[15] Shangbin Feng, Herun Wan, Ningnan Wang, and Minnan Luo. 2021. BotRGCN:
Twitter bot detection with relational graph convolutional networks. In SNAM.
[16] Emilio Ferrara. 2017. Disinformation and social bot operations in the run up to
the 2017 French presidential election. First Monday 22, 8 (2017).
[17] Matthias Fey and Jan Eric Lenssen. 2019. Fast graph representation learning with
PyTorch Geometric. arXiv (2019).
[18] Sami Abdullah Hamdi. 2022. Mining ideological discourse on Twitter: The case
of extremism in Arabic. Discourse & Communication 16, 1 (2022), 76–92.
[19] Will Hamilton, Zhitao Ying, and Jure Leskovec. 2017. Inductive representation
learning on large graphs. NIPS 30 (2017).
[20] Buyun He, Yingguang Yang, Qi Wu, Hao Liu, Renyu Yang, Hao Peng, Xiang Wang,
Yong Liao, and Pengyuan Zhou. 2024. Dynamicity-aware Social Bot Detection
with Dynamic Graph Transformers. In IJCAI.
[21] Maryam Heidari, James H Jones, and Ozlem Uzuner. 2020. Deep contextualized
word embedding for text-based online user profiling to detect social bots on
twitter. In ICDMW. IEEE, 480–487.
[22] Eric Jang, Shixiang Gu, and Ben Poole. 2017. Categorical Reparameterization
with Gumbel-Softmax. In ICLR (Poster). OpenReview.net.
[23] Edwin T Jaynes. 1980. The minimum entropy production principle. ARPC 31, 1
(1980), 579–601.
[24] Minguk Kang and Jaesik Park. 2020. Contragan: Contrastive learning for condi-
tional image generation. NIPS 33 (2020), 21357–21369.
[25] Thomas N. Kipf and Max Welling. 2017. Semi-Supervised Classification with
Graph Convolutional Networks. In ICLR (Poster). OpenReview.net.
[26] Thai Le, Long Tran-Thanh, and Dongwon Lee. 2022. Socialbots on Fire: Modeling
Adversarial Behaviors of Socialbots via Multi-Agent Hierarchical Reinforcement
Learning. In WWW. 545–554.
[27] Angsheng Li and Yicheng Pan. 2016. Structural information and dynamical
complexity of networks. TOIT 62, 6 (2016), 3290–3339.
[28] Sitao Luan, Chenqing Hua, Qincheng Lu, Jiaqi Zhu, Mingde Zhao, Shuyuan Zhang,
Xiao-Wen Chang, and Doina Precup. 2021. Is heterophily a real nightmare for
graph neural networks to do node classification? arXiv (2021).
[29] Luca Luceri, Ashok Deb, Adam Badawy, and Emilio Ferrara. 2019. Red bots
do it better: Comparative analysis of social bot partisan behavior. In WWW.
1007–1012.
[30] Abbe Mowshowitz and Matthias Dehmer. 2012. Entropy and the complexity of
graphs revisited. Entropy 14, 3 (2012), 559–570.
[31] Aaron van den Oord, Yazhe Li, and Oriol Vinyals. 2018. Representation learning
with contrastive predictive coding. arXiv (2018).
[32] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory
Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, et al .2019.
Pytorch: An imperative style, high-performance deep learning library. NIPS 32
(2019).[33] Hao Peng, Jingyun Zhang, Xiang Huang, Zhifeng Hao, Angsheng Li, Zhengtao
Yu, and Philip S Yu. 2024. Unsupervised Social Bot Detection via Structural
Information Theory. TOIS (2024).
[34] Nicolas Rashevsky. 1955. Life, information theory, and topology. Bull. Math. Biol.
17 (1955), 229–235.
[35] Claude Elwood Shannon. 1948. A mathematical theory of communication. BSTJ
27, 3 (1948), 379–423.
[36] Shuhao Shi, Kai Qiao, Jian Chen, Shuai Yang, Jie Yang, Baojie Song, Linyuan
Wang, and Bin Yan. 2023. Mgtab: A multi-relational graph-based twitter account
detection benchmark. arXiv (2023).
[37] Ernesto Trucco. 1956. A note on the information content of graphs. Bull. Math.
Biol. 18 (1956), 129–135.
[38] Laurens Van der Maaten and Geoffrey Hinton. 2008. Visualizing data using t-SNE.
JMLR 9, 11 (2008).
[39] Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro
Liò, and Yoshua Bengio. 2018. Graph Attention Networks. In ICLR (Poster).
OpenReview.net.
[40] Petar Velickovic, William Fedus, William L Hamilton, Pietro Liò, Yoshua Bengio,
and R Devon Hjelm. 2019. Deep graph infomax. ICLR 2, 3 (2019), 4.
[41] Patrick Wang, Rafael Angarita, and Ilaria Renna. 2018. Is this the era of misin-
formation yet: combining social bots and fake news to deceive the masses. In
WWW. 1557–1561.
[42] Zixuan Weng and Aijun Lin. 2022. Public opinion manipulation on social media:
Social network analysis of twitter bots during the covid-19 pandemic. JERPH 19,
24 (2022), 16376.
[43] Junran Wu, Xueyuan Chen, Bowen Shi, Shangzhe Li, and Ke Xu. 2023. SEGA:
Structural Entropy Guided Anchor View for Graph Contrastive Learning. In
ICML (Proceedings of Machine Learning Research, Vol. 202). PMLR, 37293–37312.
[44] Junran Wu, Xueyuan Chen, Ke Xu, and Shangzhe Li. 2022. Structural entropy
guided graph hierarchical pooling. In ICML. PMLR, 24017–24030.
[45] Qi Wu, Yingguan Yang, Buyun He, Hao Liu, Xiang Wang, Yong Liao, Renyu
Yang, and Pengyuan Zhou. 2023. Heterophily-aware Social Bot Detection with
Supervised Contrastive Learning. arXiv (2023).
[46] Tailin Wu, Hongyu Ren, Pan Li, and Jure Leskovec. 2020. Graph information
bottleneck. NIPS 33 (2020), 20437–20448.
[47] Yuhao Wu, Yuzhou Fang, Shuaikang Shang, Jing Jin, Lai Wei, and Haizhou Wang.
2021. A novel framework for detecting social bots with deep neural networks
and active learning. KBS 211 (2021), 106525.
[48] Yuanmeng Yan, Rumei Li, Sirui Wang, Fuzheng Zhang, Wei Wu, and Weiran
Xu. 2021. ConSERT: A Contrastive Framework for Self-Supervised Sentence
Representation Transfer. In ACL/IJCNLP (1).
[49] Yingguang Yang, Renyu Yang, Yangyang Li, Kai Cui, Zhiqin Yang, Yue Wang, Jie
Xu, and Haiyong Xie. 2023. Rosgas: Adaptive social bot detection with reinforced
self-supervised gnn architecture search. TWEB (2023).
[50] Yingguang Yang, Renyu Yang, Hao Peng, Yangyang Li, Tong Li, Yong Liao, and
Pengyuan Zhou. 2023. FedACK: Federated Adversarial Contrastive Knowledge
Distillation for Cross-Lingual and Cross-Model Social Bot Detection. In WWW.
1314–1323.
[51] Yuning You, Tianlong Chen, Yongduo Sui, Ting Chen, Zhangyang Wang, and
Yang Shen. 2020. Graph contrastive learning with augmentations. NIPS 33 (2020),
5812–5823.
[52] Guangjie Zeng, Hao Peng, Angsheng Li, Zhiwei Liu, Chunyang Liu, S Yu Philip,
and Lifang He. 2023. Unsupervised Skin Lesion Segmentation via Structural
Entropy Minimization on Multi-Scale Superpixel Graphs. In ICDM.
[53] Xianghua Zeng, Hao Peng, and Angsheng Li. 2023. Effective and stable role-based
multi-agent collaboration by structural information principles. In AAAI.
[54] Xianghua Zeng, Hao Peng, and Angsheng Li. 2024. Adversarial socialbots mod-
eling based on structural information principles. In AAAI.
[55] Xianghua Zeng, Hao Peng, Angsheng Li, Chunyang Liu, Lifang He, and Philip S
Yu. 2023. Hierarchical state abstraction based on structural information principles.
InIJCAI.
[56] Mingkai Zheng, Fei Wang, Shan You, Chen Qian, Changshui Zhang, Xiaogang
Wang, and Chang Xu. 2021. Weakly supervised contrastive learning. In ICCV.
10042–10051.
[57] Jiong Zhu, Yujun Yan, Lingxiao Zhao, Mark Heimann, Leman Akoglu, and Danai
Koutra. 2020. Beyond homophily in graph neural networks: Current limitations
and effective designs. NIPS 33 (2020), 7793–7804.
[58] Yanqiao Zhu, Yichen Xu, Feng Yu, Qiang Liu, Shu Wu, and Liang Wang. 2020.
Deep graph contrastive representation learning. arXiv (2020).
[59] Yanqiao Zhu, Yichen Xu, Feng Yu, Qiang Liu, Shu Wu, and Liang Wang. 2021.
Graph contrastive learning with adaptive augmentation. In WWW. 2069–2080.
[60] Dongcheng Zou, Hao Peng, Xiang Huang, Renyu Yang, Jianxin Li, Jia Wu, Chun-
yang Liu, and Philip S Yu. 2023. SE-GSL: A General and Effective Graph Struc-
ture Learning Framework through Structural Entropy Optimization. In WWW.
499––510.
3850SeBot: Structural Entropy Guided Multi-View Contrastive Learning for Social Bot Detection KDD ’24, August 25–29, 2024, Barcelona, Spain
0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
86.8186.8186.6486.7386.1486.1486.5686.5686.8185.21
86.7386.8186.7386.3986.7386.5685.8085.4686.8186.05
87.1587.2486.6487.0786.0586.2286.5686.0586.6486.31
86.8186.6486.9886.6486.7386.7386.6486.0586.7386.22
86.8186.9086.6486.7386.7386.7387.0786.9886.0586.39
86.9086.6486.8186.8186.9087.0786.5686.9086.7386.64
86.1486.5687.1586.8186.7386.2286.8186.7386.2286.48
86.3986.3986.8186.8186.7386.6486.9086.4886.7386.56
86.3186.9887.1585.9786.9086.7386.6486.5686.4886.56
86.0585.9786.4885.8886.2287.1586.1486.4886.4886.73
Tree… depth…k=3… on… TwiBot-200.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
86.7386.9086.3186.8187.2485.4686.5686.1486.6486.73
86.7386.5687.2486.4885.6386.1486.3986.3986.9086.98
86.3186.4886.3186.4886.1486.5686.6486.4886.3986.64
86.9886.9086.9086.5686.9886.8186.5686.6486.3985.63
87.0786.8187.1586.9887.5786.8187.2486.6487.0786.56
86.9886.9886.8186.9086.6486.3986.6486.8185.6386.31
85.8087.0787.4087.0786.9886.4886.9086.7387.0785.80
86.4886.9086.7386.9086.3186.8186.6486.6486.3986.14
86.5687.3286.5686.6486.4886.0586.6485.4686.3985.97
86.7387.3286.3986.8186.5686.3186.5685.9786.4886.14
Tree… depth…k=4… on… TwiBot-200.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
86.7386.6486.7386.5685.8085.7185.8086.9086.8186.56
86.9087.4986.8186.9886.9086.7386.3185.7185.6385.97
87.2487.2487.2486.4886.7386.5685.8885.5586.0586.39
87.4086.8186.4885.9786.3186.3185.2185.4685.6385.88
86.9886.9086.9886.0585.0486.6486.7385.9785.3885.71
87.4086.9086.5686.2286.3185.7184.9586.5685.3886.22
87.1586.3186.7386.3186.1485.7185.1285.2986.1486.31
86.7385.9786.8186.5685.6385.8885.5585.9785.8085.97
86.5686.3186.1486.1486.6486.3185.9786.1485.9785.88
86.6486.4886.4885.1286.5685.7186.3185.8085.9786.56
Tree… depth…k=5… on… TwiBot-2085.085.586.086.587.087.5
(a) Sensitive analysis of hyperparameter 𝜆1and𝜆2on TwiBot-20. (Tree depth 3-5)
0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
90.0090.8890.4989.7190.2090.2990.8890.4989.5190.10
90.3989.7190.2090.6990.4990.3990.3990.8890.3990.00
90.4990.0090.3990.2990.2090.5990.1090.3990.8890.10
89.9090.3989.5190.4990.5989.6190.3990.2090.3990.49
90.5990.1090.2989.9090.6990.2090.8890.3990.6990.29
89.4190.0089.8090.4990.6990.5989.9090.2989.7190.59
90.6990.7889.7190.6989.9089.9090.2990.2990.8890.78
90.3990.2089.4189.9089.4189.7190.7889.8090.1090.49
89.7190.6990.1090.3989.7190.2990.4990.4990.2989.41
90.2090.4990.7890.2090.5989.5190.5990.0090.2090.59
Tree… depth…k=3… on… MGTAB0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
90.7890.8890.3990.2990.3990.7890.7890.6990.6990.39
89.8089.9089.7887.7891.2790.1089.7190.2990.7890.20
90.7891.1890.0090.1088.7390.1090.4990.3990.0090.69
90.2990.0090.2990.9890.2089.5191.0889.9090.2090.29
89.8090.4990.5988.4888.7890.4990.5990.2090.0090.49
90.3990.6990.6990.2090.2090.3991.2790.1089.7189.61
90.8890.2090.5991.0890.1090.2989.7190.5990.5991.18
90.7891.0890.3990.8890.8890.4990.3990.4990.7890.00
90.1089.2290.4990.5989.3189.7190.9889.8090.1090.20
90.5990.5990.3990.2990.1090.1089.6190.2090.3990.00
Tree… depth…k=4… on… MGTAB0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
90.5989.9090.2090.3990.6990.2990.6990.4990.6990.49
90.3990.5990.6990.2990.2990.6989.9090.2990.1090.10
89.7190.5989.7190.1089.9089.8090.0090.7890.4989.90
91.3790.2989.9090.1089.9089.3190.2089.7190.0090.00
90.2090.2990.4990.3990.3990.2090.2090.2990.5990.39
89.7189.9090.7890.4989.9090.5990.0089.4190.0089.61
90.4990.3989.8090.0090.6990.5989.9090.1090.1090.59
90.5989.9090.2990.4990.4989.9089.5190.2989.7190.00
90.8890.3989.7189.9089.6189.8090.7890.7890.4990.49
90.9890.3989.8089.8090.0090.1090.5990.2990.2089.90
Tree… depth…k=5… on… MGTAB88.088.589.089.590.090.591.091.5
(b) Sensitive analysis of hyperparameter 𝜆1and𝜆2on MGTAB. (Tree depth 3-5)
0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
90.2990.4990.3990.5990.4990.2090.4990.3990.2090.39
90.1090.6990.5990.2090.0090.7890.3990.8890.5990.49
90.9890.2990.1090.3990.4990.2990.1090.2090.6990.39
89.9091.0890.2090.8890.8890.9890.3990.6990.6989.90
90.3990.3990.6990.3990.3990.9891.0890.3990.5990.39
89.6190.7889.2290.8891.3790.1090.6990.2990.1090.10
90.0090.3989.9090.4991.1890.8891.0890.5990.3990.10
90.8890.4990.5990.0090.6989.6190.1089.9090.2089.71
90.2090.0090.1090.1090.2089.3190.9890.3990.9890.59
90.2090.6990.2090.4989.9090.1090.6990.6990.4990.29
Tree… depth…k=6… on… MGTAB0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
89.7190.3990.2090.8890.9890.5990.3990.5990.1089.90
90.3990.6991.0890.7890.2090.3990.8890.8890.7890.59
90.1089.1291.0889.8089.8089.5190.2990.5990.5990.29
90.3990.5990.8889.7190.8890.8889.1291.2790.6989.31
91.1890.4990.2089.7191.5790.3990.5990.2991.1890.59
89.8090.5990.8889.9090.2990.1091.0889.0290.5989.90
90.6989.9089.9090.1090.3990.7890.4989.9090.5990.98
90.2090.9890.6990.5990.6990.5990.0090.2990.4989.31
90.1090.0090.5989.7190.2989.2291.0890.2989.8089.90
90.4990.4989.5190.2989.8090.2090.7890.4989.9090.10
Tree… depth…k=7… on… MGTAB0.010.020.030.040.050.060.070.080.090.1
2
0.010.020.030.040.050.060.070.080.090.11
89.9090.2990.5990.0090.7890.0090.6990.5990.8890.29
90.2090.5990.7890.4990.1090.5990.2090.1091.1890.49
90.5990.0090.8890.2990.3990.2090.3990.7890.4990.29
90.2990.8890.0089.7190.4989.3189.8090.6991.2790.39
90.3989.6190.5990.4990.2990.2089.8090.7890.0090.10
90.2989.4190.7890.7890.4990.1090.2990.6990.2090.39
89.8090.0090.5990.1090.1090.5990.3990.1089.7189.31
90.1090.7890.2090.2090.2990.2990.3989.7190.4990.88
90.9890.2090.7889.9090.2990.2990.0090.0090.6989.90
89.7190.2990.3989.8090.2990.5990.0090.1090.2090.39
Tree… depth…k=8… on… MGTAB88.088.589.089.590.090.591.091.5
(c) Sensitive analysis of hyperparameter 𝜆1and𝜆2on MGTAB. (Tree depth 6-8)
Figure 6: Sensitive analysis of hyperparameter 𝜆1and𝜆2on TwiBot-20 and MGTAB.
A APPENDIX
A.1 Sensitive Analysis Supplement
In this subsection, we provide additional experimental results on
the impact of hyperparameters 𝜆1,𝜆2and tree depth 𝑘on accuracy,
as shown in Figure 6. From Figure 6a, when 𝑘is set to 5, the trained
model is more sensitive to changes in hyperparameters 𝜆1and𝜆2,
and the impact is larger. When 𝑘=3, the overall performance is
less affected by hyperparameters, and the differences in accuracy
are smaller. We also conduct experiments on MGTAB in the same
way, which is shown in Figure 6b and 6c. It is visually evident that
the influence of hyperparameters is relatively small on MGTAB
compared to TwiBot-20. Moreover, with the increase in tree depth,
there isn’t a significant overall improvement in performance. Even
when𝑘=3, satisfactory results can be achieved, indicating that theperformance of SeBot on MGTAB is minimally affected by the
granularity of community partitioning.
A.2 Data Efficiency Study
Current approaches to social bot detection predominantly follow
a supervised paradigm, heavily reliant on an adequately rich set
of annotated training data. However, acquiring such a dataset is a
costly endeavor, and issues such as inaccurate annotations, noise,
and insufficient richness are widespread. Consequently, it becomes
imperative to evaluate the performance of SeBot under conditions
of limited training data, relationships, and account features. To
address this, we specifically design experimental conditions by
training solely on a subset of the data, randomly removing edges,
and masking partial features. The results are illustrated in Figure
7. Notably, even under the constraint of utilizing only 50% of the
3851KDD ’24, August 25–29, 2024, Barcelona, Spain Yingguang Yang et at.
10%20%30%40%50%60%70%80%90%100%0.80.850.90.95Label
87.4487.6687.7187.9888.4488.4988.4988.5188.6288.74F1-score Accuracy
10%20%30%40%50%60%70%80%90%100%0.80.850.90.95Edge
87.7288.0588.3288.4288.5588.5988.5988.6088.6088.74F1-score Accuracy
10%20%30%40%50%60%70%80%90%100%
Data…Percentage0.80.850.90.95Feature
87.5688.0488.1488.2088.3888.5588.5988.6888.7288.74F1-score Accuracy
Figure 7: The experimental results of the data efficiency study
regarding training data, edge quantity, and feature quantity.training data, SeBot demonstrates superior performance compared
to RGT [ 13], affirming its capability to mitigate dependence on data.
Furthermore, our observations indicate that increased edges and
features contribute to enhanced performance, suggesting that both
factors play an advantageous role in detection."
3852