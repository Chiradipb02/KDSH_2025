Efficient Decision Rule List Learning via Unified Sequence
Submodular Optimization
Linxiao Yang
linxiao.ylx@alibaba-inc.com
DAMO Academy, Alibaba Group
Hangzhou, Zhejiang, ChinaJingbang Yang
jingbang.yjb@alibaba-inc.com
DAMO Academy, Alibaba Group
Hangzhou, Zhejiang, ChinaLiang Sun
liang.sun@alibaba-inc.com
DAMO Academy, Alibaba Group
Hangzhou, Zhejiang, China
ABSTRACT
Interpretable models are crucial in many high-stakes decision-
making applications. In this paper, we focus on learning a decision
rule list for binary and multi-class classification. Different from
rule set learning problems, learning an optimal rule list involves
not only learning a set of rules, but also their orders. In addition,
many existing algorithms rely on rule pre-mining to handle large-
scale high-dimensional data, which leads to suboptimal rule list
model and degrades its generalization accuracy and interpretablity.
In this paper, we learn a rule list from the sequence submodular
perspective. We consider the rule list as a sequence and define the
cover set for each rule. Then we formulate a sequence function
which combines both model complexity and classification accuracy.
Based on its appealing sequence submodular property, we propose
a general distorted greedy insert algorithm under Minorization-
Maximization (MM) framework, which gradually inserts rules with
highest inserting gain to the rule list. The rule generation process
is treated as a subproblem, allowing our method to learn the rule
list through a unified framework which avoids rule pre-mining.
We further provide a theoretical lower bound of our greedy insert
algorithm in rule list learning. Experimental results show that our
algorithm achieves better accuracy and interpretability than the
state-of-the-art rule learning methods, and in particular it scales
well on large-scale datasets, especially on high-dimensional data.
CCS CONCEPTS
‚Ä¢Computing methodologies ‚ÜíRule learning.
KEYWORDS
Rule list, interpretability, sequence submodular optimization
ACM Reference Format:
Linxiao Yang, Jingbang Yang, and Liang Sun. 2024. Efficient Decision Rule
List Learning via Unified Sequence Submodular Optimization. In Proceedings
of the 30th ACM SIGKDD Conference on Knowledge Discovery and Data
Mining (KDD ‚Äô24), August 25‚Äì29, 2024, Barcelona, Spain. ACM, New York,
NY, USA, 12 pages. https://doi.org/10.1145/3637528.3671827
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
¬©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.36718271 INTRODUCTION
With the proliferation of enterprise artificial intelligence (AI) ap-
plications, model interpretablity has received more attention, es-
pecially in the high-risk decision-making scenarios, such as health
care [ 6,20] and societal problems [ 25,34]. Despite high classifica-
tion accuracy of the black box models, generally they are too com-
plicated for human to understand and difficult to troubleshoot [ 44],
and even be biased [ 17]. In contrast to black box models, inter-
pretable models, such as decision trees and logistic regression, are
able to provide not only predictions but also the underlying process
of how the prediction is derived. Moreover, interpretable models
bring insights into the tasks, such as how high-order feature inter-
actions drive the target variables [ 8], and how samples are breaking
down into subgroups [ 7]. These insights are beneficial for under-
standing the underlying mechanisms of the systems and further
decision making.
In this paper, we focus on rule list, which is composed of a se-
quence of ordered if-then rules. For a rule list, a sample is classified
by sequentially checking whether a rule is satisfied according to
a particular order. The prediction label of the first rule that the
sample satisfies is treated as the output of the rule list. Although
sharing many similarities with decision tree, rule list considers
multiple features together in each rule, while in decision tree, each
internal node only considers a single feature. When comparing
with rule set [ 15], rule list introduces priority for each rule, while
in a rule set, all rules are treated with equal priority. Thus, rule list
is more predictive than rule set and decision tree [ 43], and tends to
produce more compact models with comparable classification accu-
racy. Meanwhile, rule list is interpretable and user-friendly as its
classification process is analogous to the decision process of human
beings. As a result, its superior predictive and interpretable per-
formance makes it applicable and attractive in many classification
scenarios, such as treatment estimation [ 31,37,54] and bank loan
classification [ 16]. For example, rule list can be applied as a symp-
tom checking flowchart to help doctors diagnose and determine
the treatment in healthcare.
Although rule list learning has attracted many attentions in re-
cent years [ 5,41,48,52,53], it remains a challenging task. Firstly,
it involves optimizing not only a set of rules but also their or-
ders, and essentially is an NP-hard problem [ 45]. To alleviate this
difficulty, most existing methods learn a rule list by sequentially
appending rules, starting from an empty list, and thus reduce the
problem to a rule generation and selection problem. Nevertheless,
for appending-based methods, a rule is appended to the list with-
out considering the rules following it. As no further refinement
or modification can be performed once a rule is appended, sub-
optimal solutions are returned which degrade the generalization
3758
KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
accuracy and interpretablity of the rule list. To address this issue, a
few Monte Carlo simulation based works were proposed [ 48,52].
These stochastic methods, however, have slow convergence rate
and unstable outputs. Methods based on integer programming are
also proposed [ 13,45], while most of them suffer from high com-
putational complexity and fail to deal with large-scale dataset in
practice. The second challenge is the lack of the unified rule list
learning framework especially for high-dimensional data. Most
existing methods, including the recent ones [ 13,45,48,52], typi-
cally rely on a two-stage process which first pre-mines candidate
rules based on predefined metrics and then generates the final rule
list based on candidate rules. This approach inherently leads to
suboptimal rule list model due to the two-stage process. As the
metrics used usually measure the goodness of candidate rules on
the whole dataset, but fail to characterize how they work altogether
in a rule list. In addition, tuning the global threshold for pre-mining
is quite difficult in practice and inappropriate thresholding may
select redundant and unused candidate rules or miss some critical
candidates. Therefore, it is desirable to develop a global rule list
learning algorithm that seamlessly integrates rule list construction
and rule generation in a unified framework.
In this paper, we introduce a novel and general algorithm for de-
cision rule list learning from the submodular perspective, formally
SSRL (Sequence Submodular optimization based Rule List learning).
Firstly, we redefine the rule list learning problem by treating the rule
list as a sequence and defining a cover set for each rule. We then for-
mulate an objective function that blends the complexity of the rule
list with the classification accuracy of both prefix and default rules.
A key innovation of our method is its use of sequence submodular-
ity [3,28] to prioritize rules, which allows for a greedy optimization
approach. To the best of our knowledge, it is the first application
of sequence submodularity in rule list learning. Secondly, we de-
velop a distorted greedy insert algorithm for maximizing a general
regularized sequence submodular function. By incorporating the
concept of backward ùúÇ-monotonicity, we establish a performance
lower bound for this method. When applied to the rule list learning
problem within the Minorization-Maximization (MM) framework,
our greedy insert method ensures forward sequence submodular-
ity and possesses a local backward 1/(ùêæ‚àí1)-monotone property,
whereùêæis the number of classes. These properties enable us to de-
rive a performance lower bound for the algorithm in the context of
rule list learning. Thirdly, we conceptualize the problem of finding
the best rule to insert as a subproblem, which admits a difference
of submodular function decomposition and can thus be solved by
the Mod-Mod algorithm [ 27]. This unified optimization framework,
which does not separate rule insertion from rule generation, en-
dows our method with superior performance relative to two-stage
methods. In addition, our method‚Äôs exclusive use of set operations
makes it adept at handling high-dimensional data efficiently with-
out the need for rule pre-mining. We substantiate our contributions
through extensive experiments, demonstrating that our method
surpasses state-of-the-art algorithms in terms of classification ac-
curacy, interpretability, and particularly speed when dealing with
high-dimensional data.Table 1: Comparison of some important properties between
proposed method (SSRL) and popular rule-based classifiers,
including whether optimization based, support for multi-
class classification, reliance on rule pre-mining, and support
for handling more than 1k features.
MethodOptimization
basedMulti-classNo
pre-mining‚â•1k
features
SSRL‚àö‚àö‚àö‚àö
SBRL‚àö‚àö ‚àö
CORELS‚àö
CLASSY‚àö‚àö ‚àö
LIBRE‚àö
IDRS‚àö ‚àö‚àö
RIPPER‚àö‚àö‚àö
2 RELATED WORK
In this section we give a brief overview of the so-called sparse
logical models [ 44], which consist of logical statements involving
‚Äúif-then" and other clauses using sparse features. Specifically, we
will review rule list, rule set and decision tree. Moreover, as our
work is related to submodular maximization, we review the use of
submodular maximization for rule learning.
Rule List Learning. Learning rule lists requires establishing both
rules and their hierarchical order. Existing algorithms typically
employ a sequential selection process based on certain criteria to
determine rule priority. Early approaches like FOIL [ 42] and LI-
BRE [ 36] utilize a divide-and-conquer strategy, selecting rules to
classify most data and then removing those data to repeat the pro-
cess. However, this could lead to data fragmentation. More recent
methods optimize a unified objective function, such as Certifiable
optimal rules (CORELS) [ 5], which uses branch and bound with
bounds to narrow the search space but struggles with computa-
tional complexity and multi-class problems. Heuristic modifications
can improve efficiency yet compromise optimality. Bayesian meth-
ods like SBRL [ 52] optimize rule lists directly but suffer from slow
convergence due to reliance on Monte Carlo sampling. Minimum
description length (MDL) principle-based methods avoid hyperpa-
rameters, with CLASSY [ 41] being a notable MDL algorithm for
parameter-free multi-class rule list learning. In particular, we would
like to point out that all aforementioned models such as CORELS,
SBRL and MDL-based models rely on rule pre-mining using item
miners. The separation of rule pre-mining steps and rule generation
and selection steps leads to sub-optimal solutions and hence influ-
ence the model performance. Several mathematical programming
methods [ 13,45] are also proposed to find optimal rule list. How-
ever, they are limited by the large number of variables required,
making them impractical for large datasets despite advancements
in solvers. Logic-based methods [ 23,35] convert rule list learning
into Boolean satisfiability problems; however, they face scalabil-
ity issues. An incremental approach proposed by [ 24] addresses
scalability but at the cost of solution optimality and classification
accuracy.
Rule Set Learning. Unlike rule list models, rule set models have
no requirement for rule orders. Generally, if a sample satisfies
at least one rule in a rule set, it will be classified as a specific
3759Efficient Decision Rule List Learning via Unified Sequence Submodular Optimization KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
Table 2: Comparison of submodular maximization methods.
Method ùúô(ùëÖ) ùúã(ùëÖ)Theoretical
guarantee
[39]S-submodular,
mono, NN- ùúô(ùëÖ)‚â•( 1‚àí1
ùëí)ùúô(ùëÖ‚àó)
[12]S-submodular,
NN- ùúô(ùëÖ)‚â•1
2ùúô(ùëÖ‚àó)
[26]S-submodular,
mono, NNmodularùúô(ùëÖ)‚àíùúã(ùëÖ)
‚â•(1‚àí1
ùëí)ùúô(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó)
[40]S-submodular,
mono, NNS-submodular,
mono, NNùúô(ùëÖ)‚àíùúã(ùëÖ)
‚â•(1‚àíùëêùúã
ùëí)ùúô(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó)
[9, 10]F-submodular,
B-mono, NN- ùúô(ùëÖ)‚â•( 1‚àí1
ùëí)ùúô(ùëÖ‚àó)
class. Rule set models are popular in binary classification problems
rather than multi-class classification. One of the most classic rule
set learning algorithms is RIPPER [ 14], which is a data-covering
method and uses the MDL principle for pruning. Similar to rule
list learning, many rule set learning algorithms rely on rule pre-
mining [ 30,49,50], where candidate rules are extracted first using
frequent-item miners and specific loss functions are then optimized
to learn the rule set. As rule pre-mining is separated from the rule
selection and generation in the later stage, it gains efficiency but
might instead return the sub-optimal solution. To address this issue
caused by pre-mining, some recent research propose to jointly
construct and select rule sets without auxiliary rule miners [ 15,19,
51]. For example, [ 15] formulates an integer programming to train
an optimal rule set model without pre-mined rules; [ 51] proposes
IDRS which builds rule sets by minimizing the misclassification
loss using the submodular optimization approach.
In summary, we compare the key properties of popular rule list
and rule set learning algorithms in Table 1, which shows that our
proposed SSRL algorithm is the only method which not only adopts
a global unified optimization framework and not rely on rule pre-
mining, but also can successfully and efficiently handle multi-class
classification and large-scale data with more than 1k features.
Optimal Decision Tree. Our work is also related to decision tree,
as a decision tree can be considered as a simplified rule list in
which each rule only considers a single feature. Note that greedy
algorithms such as CART cannot generate the optimal decision
tree. Recently, several optimal decision tree algorithms [ 1,2,11,33,
38,56] have been proposed. Most of them solve the optimal tree
problem via mixed integer programming. Nevertheless, due to the
nonlinear structure of the problem, these methods are less scalable
with respect to the size of the problem, making them unpractical
on large-scale datasets.
Submodular Optimization in Rule Learning. Rule learning in-
volves searching for an optimal rule in a potential discrete search
space, making it a discrete optimization problem. Submodular opti-
mization, a classic approach for such problems, has been applied in
the rule learning domain. Specifically, [ 30] proposes a method to
learn a rule set by maximizing a non-negative, non-monotone sub-
modular set function by utilizing smooth local search [ 21], achiev-
ing a 2/5approximation ratio. Additionally, [ 51] developes an ap-
proach to learn a rule set by maximizing a non-negative, monotone
submodular function minus a modular function, with theoreticalguarantees also established. In general, the task of learning an op-
timal rule set/list ùëÖcan formulated as the following optimization
problem:
max
ùëÖùúô(ùëÖ)‚àíùúã(ùëÖ), (1)
where functions ùúô(ùëÖ)andùúã(ùëÖ)are defined differently and may sat-
isfy different properties in different applications. Correspondingly,
different submodular maximization algorithms can be applied to
solve the problem in the form of Eq. (1).
We delay the detailed introduction to sequence submodular in
Section 3. We emphasize that compared to set submodular optimiza-
tion, sequence submodular methods often require more stringent
properties of the functions, limiting their applicability in rule learn-
ing. We list several submodular maximization methods that have
been proposed to solve the problem in the form of Eq. (1), along with
their theoretical guarantees, in Table 2. Here, ‚ÄúS-submodular‚Äù, ‚ÄúF-
submodular‚Äù, ‚Äúmono‚Äù, ‚ÄúB-mono‚Äù, and ‚ÄúNN‚Äù are abbreviations for set
submodular, forward sequence submodular, monotonic, backward
monotonic, and nonnegativity, respectively.
3 BASICS OF SEQUENCE SUBMODULARITY
We first provide a brief review on sequence submodularity [ 3,9,10],
which is also known as string submodularity [ 55]. LetŒ©denote the
ground set of all possible states. A sequence ùëÖof lengthùëòis defined
as a string formed by ùëòstates{ùëüùëñ‚ààŒ©}ùëò
ùëñ=1, i.e.,(ùëü1,...,ùëüùëò), and
the number of elements contained in the sequence is equivalently
defined as its length. Appending a sequence ùëÖ2=(ùëü2
1,ùëü2
2,...,ùëü2
|ùëÖ2|)
after another sequence ùëÖ1=(ùëü1
1,ùëü1
2,...,ùëü1
|ùëÖ1|)is denoted by ùëÖ1‚äïùëÖ2
and defined as
ùëÖ1‚äïùëÖ2=(ùëü1
1,ùëü1
2,...,ùëü1
|ùëÖ1|,ùëü2
1,ùëü2
2,...,ùëü2
|ùëÖ2|). (2)
Similarly, appending a state ùëü‚Ä≤after a sequence ùëÖ=(ùëü1,ùëü2,...,ùëü|ùëÖ|)
is denoted by ùëÖ‚äïùëü‚Ä≤and defined as
ùëÖ‚äïùëü‚Ä≤=(ùëü1,ùëü2,...,ùëü|ùëÖ|,ùëü‚Ä≤). (3)
The operation of inserting a state ùëü‚Ä≤after theùëñ-th position of a
sequenceùëÖ=(ùëü1,ùëü2,...,ùëüùëñ,ùëüùëñ+1,...,ùëü|ùëÖ|)is written asI(ùëÖ,ùëñ,ùëü‚Ä≤)
and defined as
I(ùëÖ,ùëñ,ùëü‚Ä≤)=(ùëü1,ùëü2,...,ùëüùëñ,ùëü‚Ä≤,ùëüùëñ+1,...,ùëü|ùëÖ|). (4)
A sequence ùëÖ2is a subsequence of ùëÖ1, denoted by ùëÖ1‚âΩùëÖ2, ifùëÖ2
can be derived by eliminating some states of ùëÖ1.
A function ùëì(ùëÖ)from sequences to real numbers is said to be
backward monotonic if
ùëì(ùëÖ1‚äïùëÖ2)‚â•ùëì(ùëÖ2) ‚àÄùëÖ1,ùëÖ2 (5)
and forward monotonic if
ùëì(ùëÖ1‚äïùëÖ2)‚â•ùëì(ùëÖ1) ‚àÄùëÖ1,ùëÖ2 (6)
A function is sequence submodular if it has diminishing-return
property along some order. Specifically, we say a function ùëì(ùëÖ)is
forward sequence submodular if for any ùëü1,ùëü2‚ààŒ©,ùëÖ,
ùëì(ùëÖ‚äïùëü1‚äïùëü2)‚àíùëì(ùëÖ‚äïùëü1)‚â§ùëì(ùëÖ‚äïùëü2)‚àíùëì(ùëÖ). (7)
Apart from forward sequence submodularity, a more general se-
quence submodularity based on the definition of subsequence can
3760KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
Table 3: The cover set, label set, and number of samples cor-
rectly classified of each rule in an example rule list.
Rule Rule ListCover
setLabel
setNumber of samples
correctly classified
ùëü1 IFùë•1>5THENùë¶=0C1L1|C1‚à©L 1|
ùëü2ELIFùë•2>1ANDùë•1>3
THENùë¶=1C2L2|C1‚à©C 2‚à©L 2|
ùëü3 ELIFùë•1<1THENùë¶=2C3L3|C<3‚à©C 3‚à©L 3|
ùëüùëë ELSEùë¶=0 Lùëë|C<4‚à©Lùëë|
be defined for function ùëìif it satisfies
ùëì(ùëÖ1‚äïùëü)‚àíùëì(ùëÖ1)‚â§ùëì(ùëÖ2‚äïùëü)‚àíùëì(ùëÖ2) ‚àÄùëü‚ààŒ©,ùëÖ 1‚âΩùëÖ2.(8)
Different from sequence submodularity, a set function defined
onŒ©is called set submodular [29] if for any ùê¥‚äÜùêµ‚äÜŒ©,ùëü‚ààŒ©,
ùëì(ùê¥‚à™{ùëü})‚àíùëì(ùê¥)‚â•ùëì(ùêµ‚à™{ùëü})‚àíùëì(ùêµ). (9)
ùëì(ùëã)is called modular function if the inequality in Eq. (9)becomes
equality. We now introduce two tight upper modular bounds and
one tight lower modular bound for set submodular functions that
widely used in submodular optimization. As shown in [ 27], given
a submodular function ùëì(ùëã), two tight upper modular bounds at
‚àÄùëå‚äÜŒ©are given as
ùëì1(ùëã;ùëå)Bùëì(ùëå)‚àí‚àëÔ∏Å
ùëó‚ààùëå\ùëãùëì(ùëó|ùëå\{ùëó})+‚àëÔ∏Å
ùëó‚ààùëã\ùëåùëì(ùëó|‚àÖ),(10)
ùëì2(ùëã;ùëå)Bùëì(ùëå)‚àí‚àëÔ∏Å
ùëó‚ààùëå\ùëãùëì(ùëó|Œ©\{ùëó})+‚àëÔ∏Å
ùëó‚ààùëã\ùëåùëì(ùëó|ùëå),(11)
whereùëì(ùëó|ùëã)is short for ùëì(ùëã‚à™{ùëó})‚àíùëì(ùëã). Again from [ 27], a
tight lower bound of ùëì(ùëã)at‚àÄùëå‚äÜŒ©is given as
ùëìùúÖ(ùëã;ùëå)=‚àëÔ∏Å
ùëñ‚ààùëãùëìùúÖ(ùëñ;ùëå) (12)
where
ùëìùúÖ(ùëñ;ùëå)=ùëì(ùëÜùúÖ
ùúÖ‚àí1(ùëñ))‚àíùëì(ùëÜùúÖ
ùúÖ‚àí1(ùëñ)‚àí1), (13)
ùúÖis a permutation of the ground set Œ©, andùëÜùúÖ
ùëñis a set with ùëÜùúÖ
0=‚àÖ,
ùëÜùúÖ
ùëó={ùúÖ(1),...,ùúÖ(ùëó)}, andùëÜùúÖ
|ùëå|=ùëå.
4 PROBLEM FORMULATION
We focus on the ùêæ-class classification problem and specifically
consider the scenario where all features of samples are binary.
Noted that although only binary features are considered here, it is
easy to extend our model to non-binary categorical and numerical
features using one-hot encoding and discretization techniques, re-
spectively. Let{(ùíôùëñ,ùë¶ùëñ)}ùëõ
ùëñ=1denote a set of training samples, where
ùíôùëñ=[ùë•ùëñ,1,ùë•ùëñ,2,...,ùë•ùëñ,ùê∑]ùëáis aùê∑-dimensional binary vector indi-
cating the presence of the ùê∑features, and ùë¶ùëñ‚àà{1,...,ùêæ}is the
corresponding label. Define Œìas a collection of the ùê∑features, we
say that the ùëñ-th sample has the ùëó-th feature in Œìifùë•ùëñùëó=1. We aim
to learn a rule list which is a classifier of the form ‚ÄúIF ùëê1THENùë¶=ùëô1
ELIFùëê2THENùë¶=ùëô2...ELIFùëêùëöTHENùë¶=ùëôùëöELSEùë¶=ùëôùëë‚Äù, where
{ùëêùëñ}ùëö
ùëñ=1denote the conditions by which each samples are tested, and
{ùëôùëñ}ùëö
ùëñ=1‚à™{ùëôùëë}denote the corresponding labels. Here the condition
ùëêùëñis a set of features. A sample is said to satisfy a condition if and
only if it has all the features in the condition. Obviously, a rule list
is a sequence of ‚ÄúIF ... THEN ... ‚Äù clauses with order, and end with an‚ÄúELSE... ‚Äù clause. Mathematically, we write ‚ÄúIF ùëêTHENùë¶=ùëô‚Äù clauses
as a ruleùëü=(ùëê,ùëô)and ‚ÄúELSE‚Äù clause as ùëüùëë=(ùëêùëë,ùëôùëë). Then a rule
list of length ùëö+1can be written as a sequence (ùëü1,ùëü2,¬∑¬∑¬∑,ùëüùëö,ùëüùëë).
We call the sequence ùëÖ=(ùëü1,ùëü2,¬∑¬∑¬∑,ùëüùëö)a prefix, defined as a rule
list without the final "ELSE" clause. The last rule ùëüùëëin a rule list is
called the default rule, whose condition is empty. Given a rule (ùëê,ùëô),
we define its cover set Cas a collection of samples that satisfies
conditionùëê. We also define cover set Lfor labelùëôcomprised of
samples whose label is ùëô. Letùëüùëñ=(ùëêùëñ,ùëôùëñ)be theùëñth rule in a rule
list, a sample is correctly classified by ùëüùëñif and only if the sample
does not satisfy conditions of any rules in front of ùëüùëñ, i.e.,{ùëêùëó}ùëó<ùëñ,
meanwhile satisfies the condition of ùëüùëñ, i.e.,ùëêùëñ, and has label ùëôùëñ.
Hence, forùëüùëñ, the number of correctly classified samples can be
computed asC<ùëñ‚à©Cùëñ‚à©Lùëñ, whereCùëñandLùëñare the cover set of
conditionùëêùëñand labelùëôùëñ, respectively,C<ùëñB√êùëñ‚àí1
ùëó=1Cùëódenotes the
set of samples that covered by the first ùëñ‚àí1rules in the rule list, and
Cdenotes the complementary set of C. As a result, for a rule list
(ùëü1,ùëü2,¬∑¬∑¬∑,ùëüùëö,ùëüùëë), the number of correctly classified samples are
given as√çùëö
ùëñ=1C<ùëñ‚à©Cùëñ‚à©Lùëñ+C‚â§ùëö‚à©Lùëë, where the first term
denotes the number of samples correctly classified by rules {ùëüùëñ}ùëö
ùëñ=1,
and the second term denotes the number of samples correctly classi-
fied by the default rule ùëüùëë. Table 3 provides an example rule list and
its cover set, label set, and number of samples correctly classified
of each rule.
Our objective is to learn a rule list that can classify correctly as
many samples as possible, while still maintaining low complexity.
Formally, given a default rule ùëüùëë, our objective is to find a prefix ùëÖ
whose length no larger than ùúàand maximizes
ùëì(ùëÖ)=|ùëÖ|‚àëÔ∏Å
ùëñ=1C<ùëñ‚à©Cùëñ‚à©Lùëñ+C‚â§|ùëÖ|‚à©Lùëë‚àíùúÜùë¢(ùëÖ)
=ùëù(ùëÖ)‚àíùëë(ùëÖ)‚àíùúÜùë¢(ùëÖ)+ùëõ, (14)
whereùëù(ùëÖ)=√ç|ùëÖ|
ùëñ=1C<ùëñ‚à©Cùëñ‚à©Lùëñ, and it measures the number of
samples correctly classified by prefix ùëÖ; andùëë(ùëÖ)represents the size
of the complement of the set of samples that are correctly classified
by the default rule, i.e., ùëë(ùëÖ)=C‚â§|ùëÖ|‚à©Lùëë=C‚â§|ùëÖ|‚à™Lùëë. In
other words, ùëë(ùëÖ)measures how the rule prefix ùëÖreduces the
number of samples that would otherwise be correctly classified by
the default rule. Here ùúÜis a parameter that controls the trade-off
between the classification accuracy and the complexity of the rule
list, andùë¢(ùëÖ)measures the complexity of ùëÖ, counting the number
of featuresùëÖused, i.e.,ùë¢(ùëÖ)=√ç
ùëü‚ààùëÖ|ùëü|, where|ùëü|is defined as the
number of features in the condition of ùëü. Obviously, ùëì(ùëÖ),ùëù(ùëÖ)and
ùëë(ùëÖ)are sequence functions [ 4,9,55] from sequences to real value,
and we summarize their properties in Lemma 1.
Lemma 1. Withùëù(ùëÖ)andùëë(ùëÖ)defined above, we have: 1) ùëù(ùëÖ)
is a forward sequence submodular function; 2) ùëù(ùëÖ)is a forward-
monotone function; 3) ùëù(ùëÖ)is not a backward-monotone function; 4)
ùëë(ùëÖ)is a submodular function; 5) ùë¢(ùëÖ)is a modular function.
The above lemma implies that the objective function can be
viewed as the difference between a sequence submodular function
ùëù(ùëÖ)and a set submodular function ùëë(ùëÖ)+ùúÜùë¢(ùëÖ). Fig. 1 illustrates
the forward sequence submodularity of a sample prefix. Given
3761Efficient Decision Rule List Learning via Unified Sequence Submodular Optimization KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
Figure 1: Illustration of forward sequence submodularity of prefix of the rule list. ùëù(ùëÖ)denotes the number of samples correctly
classified by prefix ùëÖ.
the review of current submodular maximization algorithms in the
literature in Table 2, we highlight two difficulties arising from
maximizing ùëì(ùëÖ)in Eq. (14). On the one hand, maximizing the dif-
ference between two submodular functions is non-trivial. Although
several works have been proposed to maximize the difference of
two set submodular functions, few works are able to deal with
the difference between a sequence submodular function and a set
submodular function. On the other hand, the lack of backward-
monotonic property of ùëù(ùëÖ)makes the problem more challenging.
The requirements of both forward sequence submodularity and
backward monotonicity by most existing sequence subumodular
maximization methods make them inapplicable to our problem.
5 ALGORITHMS
In this section, we propose a greedy method to learn a rule list
efficiently. As discussed above, one difficulty of maximizing the
objective function arises from the difference of a sequence submod-
ular function and a set submodular function. To overcome this, we
resort to the Minorization-Maximization (MM) approach, where
we iteratively maximize a simple surrogate function minorizing the
original objective function. To this end, the submodular function
ùëë(ùëÖ)is first approximated using its modular upper bounds based on
current estimation. As shown in [ 27], given a submodular function
ùëì(ùëã), two tight upper modular bounds at ‚àÄùëå‚äÜŒ©are given as
ùëì1(ùëã;ùëå)Bùëì(ùëå)‚àí‚àëÔ∏Å
ùëó‚ààùëå\ùëãùëì(ùëó|ùëå\{ùëó})+‚àëÔ∏Å
ùëó‚ààùëã\ùëåùëì(ùëó|‚àÖ),(15)
ùëì2(ùëã;ùëå)Bùëì(ùëå)‚àí‚àëÔ∏Å
ùëó‚ààùëå\ùëãùëì(ùëó|Œ©\{ùëó})+‚àëÔ∏Å
ùëó‚ààùëã\ùëåùëì(ùëó|ùëå),(16)
whereùëì(ùëó|ùëã)is short forùëì(ùëã‚à™{ùëó})‚àíùëì(ùëã). Substituting two upper
bounds ofùëë(ùëÖ), denoted by ùëë1(ùëÖ;ùëÖ(ùë°))andùëë2(ùëÖ;ùëÖ(ùë°)), to Eq. (14),
we arrive at two surrogate functions of ùëì(ùëÖ)as
ùëì1(ùëÖ;ùëÖ(ùë°))=ùëù(ùëÖ)‚àíùëë1(ùëÖ;ùëÖ(ùë°))‚àíùúÜùë¢(ùëÖ), (17)
ùëì2(ùëÖ;ùëÖ(ùë°))=ùëù(ùëÖ)‚àíùëë2(ùëÖ;ùëÖ(ùë°))‚àíùúÜùë¢(ùëÖ), (18)
whereùëÖ(ùë°)denotes the estimate of ùëÖat theùë°-th MM iteration, and
we ignore the terms independent of ùëÖ.
5.1 Proposed Greedy Insert Method
In this subsection, we present a greedy insertion method to optimize
the objectives formulated in Eqs. (17, 18). For streamlined problem-
solving, we consolidate the maximization challenge of Eqs. (17, 18)
into the subsequent unified expression:
max
|ùëÖ|‚â§ùúàÀúùëì(ùëÖ)=ùúì(ùëÖ)‚àíùúã(ùëÖ), (19)
whereùúì(ùëÖ)=ùëù(ùëÖ), andùúàis a predefined cardinality constraint on
the number of rules in ùëÖ. The termùúã(ùëÖ)is specified as ùëë1(ùëÖ;ùëÖ(ùë°))+
ùúÜùë¢(ùëÖ)for the optimization of Eq. (17), and asùëë2(ùëÖ;ùëÖ(ùë°))+ùúÜùë¢(ùëÖ)
when targeting Eq. (18). Importantly, ùúì(ùëÖ)quantifies the count ofAlgorithm 1: Distorted Greedy Insert (DGI)
Input : Ground set Œ©, cardinality constraint ùúà, sequence
submodular function ùúì, and modular function ùúã.
Output: SequenceùëÖ.
1InitializeùëÖas empty;
2forùëñ=1,...,ùúà do
3ùõºùëñ‚Üê(1‚àí1
ùúà)(ùúà‚àíùëñ);
4ùúì(ùëü,ùëò|ùëÖ)‚Üêùúì(I(ùëÖ,ùëò,ùëü))‚àíùúì(ùëÖ);
5(ùëü‚àó,ùëò‚àó)‚Üê arg max(ùëü,ùëò)‚ààŒ©√ó{ùëò}|ùëÖ|
ùëò=0ùõºùëñùúì(ùëü,ùëò|ùëÖ)‚àíùúã(ùëü);
6 ifùõºùëñùúì(ùëü‚àó,ùëò‚àó|ùëÖ)‚àíùúã(ùëü)‚â•0then
7 Insert element ùëüinto theùëòth position of ùëÖ
8Return R
samples accurately classified by the prefix ùëÖalone, while ùúã(ùëÖ)mea-
sures the extent to which prefix ùëÖreduces the number of samples
correctly classified by the default rule, in addition to the quantity
of features employed by prefix ùëÖ.
Our method harnesses computational efficiency through the
use of a greedy algorithm. In each iteration, for a chosen inser-
tion position ùëò, we select an optimal rule ùëübased on its insertion
gain, which affects both ùúì(ùëÖ)andùúã(ùëÖ). The gain is computed as
ùúì(ùëü,ùëò|ùëÖ)=ùúì(I(ùëÖ,ùëò,ùëü))‚àíùúì(ùëÖ)andùúã(ùëü,ùëò|ùëÖ)=ùúã(ùëü).
The ideal outcome is that all samples sharing the label of the
default rule are correctly classified by it, which would naturally
result in shorter and more efficient rule lists. To guide the algorithm
towards this ideal goal, we adjust the importance of ùúì(ùëü,ùëò|ùëÖ)and
ùúã(ùëü)dynamically. In the ùëñth iteration, we seek a rule ùëüand a position
ùëòby maximizing the following:
ùõºùëñùúì(ùëü,ùëò|ùëÖ)‚àíùúã(ùëü). (20)
Initially, the weight ùõº1is set to a small value, (1‚àí1/ùúà)(ùúà‚àí1),
to prevent the prefix from incorrectly classifying samples that
should be correctly classified by the default rule. To ensure op-
timal performance, we incrementally increase the weight with each
iteration by a factor of (1‚àí1/ùúà), yielding an iterative weight of
ùõºùëñ=(1‚àí1/ùúà)(ùúà‚àíùëñ). Our method, named Distorted Greedy Insert,
is summarized in Algorithm 1.
Discussion: As discussed earlier, ùúì(ùëÖ)is a nonnegative forward
sequence submodular function, and ùúã(ùëÖ)is a nonnegative modular
function. Thus the problem in Eq. (19)is maximizing a nonnegative
sequence submodular function with modular cost regularization
under cardinality constraints. Although efficient algorithms [ 9,46]
have been proposed to maximize sequence submodular functions
under modular constraints, their extension to maximize the se-
quence submodular function with regularization, i.e., problem in
Eq.(19), is not trivial. The reason is due to the presence of the modu-
lar regularization ùúã(ùëÖ)that breaks the non-negativity as well as the
backward monotone of Àúùëì(ùëÖ). Another difficulty comes from the re-
quirement of the backward monotonic. Most sequence submodular
3762KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
Figure 2: Illustration of theoretical guarantee of respective
methods as well as the properties of the function required by
these methods when dealing with binary class classification
problem.
maximization methods requires the presence of forward sequence
submodular and backward monotone. Clearly, Àúùëì(ùëÖ)does not ex-
hibits backward monotone. As we will show below, our proposed
method is the first method that does not require the monotonicity
of the function while remain exists performance guarantee.
5.1.1 Theoretical analysis. Asùúì(ùëÖ)is non-monotonic, we intro-
duce a notation, named monotonic ratio, to measure how close
the function is to a monotone function. Specifically, we define the
backward monotone ratio for ùúì(ùëÖ)as
ùúÇ‚âúmin
ùëÖ1,ùëÖ2‚â†‚àÖùúì(ùëÖ1‚äïùëÖ2)
ùúì(ùëÖ2). (21)
We callùúì(ùëÖ)backwardùúÇ-monotone. Obviously, if ùúÇ‚â•1, we can
conclude that ùúì(ùëÖ)is backward monotone, and if ùúÇ<1, we seeùúì(ùëÖ)
is weak monotone. The following result provides a lower bound
on performance of the proposed method for forward sequence
submodular and backward ùúÇ-monotoneùúì(ùëÖ)and modular ùúã(ùëÖ).
Theorem 2. Assumeùúì(ùëÖ)is forward sequence submodular and
backwardùúÇ-monotone,ùúã(ùëÖ)is modular. Let ÀÜùëÖdenote the output of
Algorithm 1, ùëÖ‚àóbe the optimal solution maximizing Àúùëì(ùëÖ), then
ùúì(ÀÜùëÖ)‚àíùúã(ÀÜùëÖ)‚â•ùúÇ(1‚àí1
ùëí)ùúì(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó). (22)
The above theorem requires ùúì(ùëÖ)to be global monotonic or
globalùúÇ‚àímonotonic, and the following corollary provides an algo-
rithmic property based guarantee for performance which relaxes
the requirement of global monotonicity.
Corollary 1. Assumeùúì(ùëÖ)is forward sequence submodular and
ùúã(ùëÖ)is modular. ÀÜùëÖ(ùëñ)is the sequence generated by Algorithm 1 at the
ùëñ-th iteration. If ùúì(ùëÖ)is backward ùúÇ-monotone on the set {ÀÜùëÖ(ùëñ)}ùúà
ùëñ=1‚à™
{ùëÖ‚àó}, whereùëÖ‚àódenotes the optimal solution of problem in Eq. (19),
then Eq. (22)still holds with ÀÜùëÖbeing the output of Algorithm 1.
Corollary 1 shows that if ùúìexhibits the local backward weak
monotonicity on set {ÀÜùëÖ(ùëñ)}ùúà
ùëñ=1‚à™{ùëÖ‚àó}, the performance guarantee
shown in Theorem 2 is still valid.
We have introduced a theoretical guarantee for our proposed
method with notation ùúÇ. To determine the value of ùúÇfor global
backwardùúÇ-monotone is difficult. Fortunately, if we restrict the
labels of the rules in ùëÖto be different to ùëôùëë, the following lemma
shows thatùúì(ùëÖ)exhibits backward 1/(ùêæ‚àí1)-monotonicity locally.Lemma 3. LetÀÜùëÖ(ùëñ)be the generated prefix by Algorithm 1 in
theùëñ-th iteration while optimizing Eq. (19) over all possible pre-
fixes. If{ÀÜùëÖ(ùëñ)}ùúà
ùëñ=1are not all empty, then ùúì(ùëÖ)is at least backward
(1/(ùêæ‚àí1))-monotone on the set {ÀÜùëÖ(ùëñ)}ùúà
ùëñ=1‚à™{ùëÖ‚àó}, whereùëÖ‚àódenotes
the maximizer of Eq. (19)under the cardinality constraint |ùëÖ|‚â§ùúà.
As an immediate result of Corollary 1 and Lemma 3, we arrive
at the performance guarantee of Algorithm 1 when optimizing
Eq. (19).
Theorem 4. LetÀÜùëÖbe the output of Algorithm 1 for optimizing
Eq.(19)over all the possible prefixes, and ùëÖ‚àóbe the optimal prefix
that maximizing Eq. (19)under constrain|ùëÖ|‚â§ùúà. IfÀÜùëÖis not empty
then
ùúì(ÀÜùëÖ)‚àíùúã(ÀÜùëÖ)‚â•1
ùêæ‚àí1
1‚àí1
ùëí
ùúì(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó). (23)
The above theorem shows that although ùúì(ùëÖ)may not exhibit
global monotonicity, we can still optimize Eq. (19)using Algorithm 1
and achieve certain performance guarantee.
Discussion: We observe that our approach bears a relation to
the work presented in [ 26], which introduces a distorted greedy
algorithm for maximizing a set submodular function. The method
in [26] not only depends on the set submodularity property but also
necessitates global monotonicity of the functions. Consequently,
adapting the strategy proposed in [ 26] to sequence submodular
functions‚Äîwhich represent a more general notion than set submod-
ularity‚Äîposes a non-trivial challenge. In contrast, our method is
adept at handling sequence submodular functions without requir-
ing function monotonicity. Surprisingly, when addressing binary
classification problems, i.e., ùêæ=2, our model achieves theoreti-
cal guarantees that are on par with those of [ 26], despite the less
stringent conditions imposed by our approach. Fig. 2 illustrates the
distinctions between our method and the one in [ 26] under binary
classification problem.
Based on the distorted greedy insert algorithm with performance
guarantee, we propose our rule list learning algorithm SSRL (Se-
quence Submodular optimization based Rule List learning), as sum-
marized in Algorithm 2. In Algorithm 2, we iteratively find two
tight upper bounds of ùëì(ùëÖ), and optimize them using Algorithm
1. The learned rule list can be further refined using local search
operations, such as exchange and replacement.
5.2 Sub-Problem Solving
The proposed Algorithm 1 involves finding a pair of rule and posi-
tion with maximal insertion gain, which is a combinatorial search
problem with the size of search space exponential to the number of
binary features. In this subsection, we propose an efficient method
to find the optimal rule to insert.
We first discuss the case of finding the optimal condition ùëê‚àówhen
fixing the position ùëòand labelùëô, such that inserting the rule (ùëê‚àó,ùëô)
to theùëòth position of ùëÖachieves maximal insertion gain. Without
loss of generality, we only discuss the scenario that ùúì(R) andùúã(ùëÖ)
in Algorithm 1 are set to ùëù(ùëÖ)andùëë1(ùëÖ;ùëÖ(ùë°))+ùúÜùë¢(ùëÖ), respectively.
Letùê∫(ùëü,ùëò)denote the distorted gain of inserting a rule ùëü=(ùëê,ùëô)to
theùëòth position of ùëÖas presented as the 4-th line in Algorithm 1,
3763Efficient Decision Rule List Learning via Unified Sequence Submodular Optimization KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
Table 4: Binary-class Performance: Predicting accuracy (%, standard deviation in parentheses).
Dataset #
samples #
features SSRL SBRL CORELS‚àóCLASSY IDRS RIPPER
FICO-binar
y 10459 34 72.03(0.7) 71.21(1.0) 70.70(0.8) 71.78(1.5) 71.2(1.1) 60.1(1.2)
FICO 10459 312 71.90(1.5) 70.37(1.2) 69.86(1.1) 70.83(1.5) 70.4(1.4) 69.1(1.9)
WDBC 569 540 95.79(3.6) 92.98(4.1) 94.39(4.1) 94.73(3.3) 94.0(4.8) 94.7(1.6)
gas 13910 2304 98.63(0.2) 95.26(0.6) 87.72(1.4) 99.01(0.3) 98.20.4 99.0(0.4)
magic 19020 180 86.28(0.6) 81.66(0.9) 81.27(0.8) 85.79(0.5) 84.6(0.8) 82.2(1.3)
adult 48842 262 84.31(0.7) 83.76(0.5) 82.94(0.6) 83.97(0.6) 84.4(0.6) 83.3(0.9)
COMP
AS-binary 6907 24 67.12(1.4) 66.21(1.4) 66.60(1.3) 66.72(1.5) 67.0(1.5) 56.0(0.6)
then
we have
ùê∫(ùëü,ùëò)=ùõºùëù(ùëü,ùëò|ùëÖ)‚àíùëë1(ùëü;ùëÖ(ùë°))
‚àíùúÜ|ùëê|, (24)
whereùëë1(ùëü;ùëÖ(ùë°))=ùëë(ùëü|ùëÖ(ùë°)\{ùëü})forùëü‚ààùëÖ(ùë°),ùëë1(ùëü;ùëÖ(ùë°))=
ùëë(ùëü|‚àÖ)forùëü‚ààŒ©\ùëÖ(ùë°)andùëù(ùëü,ùëò|ùëÖ)=ùëù(I(ùëÖ,ùëò,ùëü))‚àíùëù(ùëÖ). We
further define
ùê∫1(ùëü,ùëò)=ùõºùëù(ùëü,ùëò|ùëÖ)‚àíùëë(ùëü|ùëÖ(ùë°)\{ùëü})‚àíùúÜ|ùëê|, (25)
ùê∫2(ùëü,ùëò)=ùõºùëù(ùëü,ùëò|ùëÖ)‚àíùëë(ùëü|‚àÖ)‚àíùúÜ|ùëê|. (26)
Sinceùê∫(ùëü,ùëò)has different evaluations for rules from ùëÖ(ùë°)orŒ©\ùëÖ(ùë°),
a straightforward strategy is to separately compute the optimal
rules inùëÖ(ùë°)andŒ©\ùëÖ(ùë°), and choose the one with larger gain as
the solution. Nevertheless, the presence of the constraint Œ©\ùëÖ(ùë°)
makes the optimization of ùê∫2(ùëü,ùëò)difficult. Fortunately, due to the
submodularity of ùëë(ùëÖ), the following lemma justifies the removal
of this constraint.
Lemma 5. Letùëü1‚ààarg maxùëü‚ààùëÖ(ùë°)ùê∫1(ùëü,ùëò),ùëü2‚ààarg maxùëü‚ààŒ©ùê∫2(ùëü,ùëò),
andùëü‚ààarg maxùëü‚àà{ùëü1,ùëü2}ùê∫(ùëü,ùëò). Then we have ùëü‚ààarg maxùëü‚ààŒ©ùê∫(ùëü,ùëò).
As the size of ùëÖ(ùë°)is smaller than a predefined parameter ùúà, the
maximizer of ùê∫1(ùëü,ùëò)can be found by testing all the rules in ùëÖ(ùë°).
Figure 3: Illustration of insert ùëü=(ùëê,ùëô)into the position ùëò,
whereCandLdenote the cover set of ùëêandùëô, respectively.
S>ùëòis defined in Lemma 6.
We next discuss the optimization of ùê∫2(ùëü,ùëò), which quantifies the
benefit of inserting a rule ùëüat positionùëò. As depicted in Fig. 3, the
advantages conferred by the inclusion of rule ùëücan be segregated
into three distinct aspects. Firstly, the insertion of ùëüenables correct
classification of certain samples that were previously misclassified.
Secondly, the introduction of ùëüaffects the subsequent rules in the
list,{ùëüùëñ}|ùëÖ|
ùëñ=ùëò+1, by reducing their sample processing load, which
consequently may decrease the number of samples they correctly
classify. The third aspect pertains to the impact of ùëüon the default
rule‚Äôs performance. The following lemma encapsulates these three
facets of the influence exerted by the insertion of rule ùëüat position
ùëò. It establishes that ùê∫2(ùëü,ùëò)can be formulated as the difference
between two submodular functions.
Lemma 6. LetS>ùëò=√ê|ùëÖ|
ùëñ=ùëò+1
C<ùëñ‚à©
Cùëñ‚à©Lùëñ
, we haveùê∫2(ùëü,ùëò)‚àù
ùúî(ùëê)‚àíùë£(ùëê)where
ùúî(ùëê)=ùõºS>ùëò‚à©
‚à™ùëí‚ààùëêE+
‚à™ùëí‚ààùëêE
‚à©
Lùëë,
ùë£(ùëê)=ùõºC‚â§ùëò‚à©
‚à™ùëí‚ààùëêE
‚à©
L+ùúÜ|ùëê|.
HereEdenotes the set of samples containing feature ùëí,C=‚à©ùëí‚ààùëêE,
andC=‚à™ùëí‚ààùëêE.
Due to the property of union operation, we can conclude that
bothùúî(ùëê)andùë£(ùëê)are nonnegative monotone submodular func-
tions andùê∫2(ùëü,ùëò)is the difference of two submodular functions.
Several works have been proposed to maximize the difference be-
tween two set submodular functions in the literature. In this paper,
we utilize the ModMod procedure proposed in [ 27] due to its effi-
ciency. Based on the MM algorithm [ 47], in each iteration ModMod
finds a lower modular bound for ùúî(ùëê)and two upper modular
bounds forùë£(ùëê). Bringing them together, two tight modular lower
3764KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
Table 5: Multi-class Performance: Predicting accuracy (%, standard deviation in parentheses).
Dataset(#classes) # samples # features SSRL SBRL CLASSY RIPPER
iris(3) 150 41 98.0(3.1) 98.0(3.2) 98.0(3.2) 98.0(3.2)
cmc(3) 1473 59 55.26(3.2) 52.75(3.1) 53.29(4.0) 51.73(4.0)
cardio(3) 2126 177 90.40(2.0) 89.27(2.5) 90.12(1.9) 89.70(1.8)
page-blocks(5) 5473 174 96.86(0.6) 95.69(0.8) 96.58(0.7) 96.51(0.7)
dry-bean(7) 13611 288 90.98(0.6) 89.32(0.4) 88.87(0.8) 91.04(0.9)
pendigits(10) 10992 268 96.23(0.5) 89.42(0.7) 95.49(0.8) 96.47(0.5)
Table 6: Interpretability for Binary-class datasets: Number of rules and literals (standard deviation in parentheses).
DatasetSSRL SBRL CORELS‚àóCLASSY IDRS RIPPER
#
rules #
literals #
rules #
literals #
rules #
literals #
rules #
literals #
rules #
literals #
rules #
literals
FICO-binar
y 7.3(1.7) 18.4(4.2) 14.4(0.8) 23.2(1.8) 4.5(0.7) 14.9(2.4) 19.4(1.7) 65.3(5.1) 21.6(3.3) 134.0(23.8) 16.7(2.1) 106.8(14.3)
FICO 11.6(4.2) 28.2(5.8) 11.7(1.4) 20.3(3.5) 3.9(0.6) 12.7(2.2) 18.2(1.2) 64.9(3.6) 16.0(5.5) 118.6(39.3) 16.0(5.5) 118.6(39.3)
WDBC 5.9(0.7) 10.7(0.9) 3.1(0.9) 5.2(1.5) 6.3(1.4) 18.2(6.4) 4.9(0.3) 7.2(0.6) 8.0(1.1) 27.7(3.0) 5.0(1.1) 10.6(3.0)
gas 10.9(0.8) 27.1(1.8) 42.9(3.6) 85.4(7.3) 7.3(1.2) 25.2(4.4) 27.9(2.1) 71.3(5.8) 13.1(1.0) 74.2(4.2) 24.2(1.8) 106.8(11.6)
magic 33.0(2.8) 90.0(8.0) 27.9(1.9) 51.2(3.4) 6.7(0.5) 21.1(1.8) 72.0(2.5) 226.0(0.9) 19.1(6.6) 136.1(49.2) 52.3(10.6) 391.3(75.0)
adult 10.6(2.2) 45.0(6.0) 39.0(2.9) 73.5(6.3) 4.4(0.7) 14.7(3.1) 98.4(3.0) 368.3(8.7) 9.1(3.1) 83.4(30.7) 42.7(15.2) 337.0(128.9)
COMP
AS-binary 7.7(1.6) 14.6(3.3) 7.8(0.9) 12.7(1.3) 3.3(0.5) 12.3(2.2) 11.7(0.8) 22.6(1.9) 11.4(1.3) 42.2(6.3) 12.0(1.7) 48.1(8.8)
Table 7: Interpretability for Multi-class Datasets: Number of rules and literals (standard deviation in parentheses).
DatasetSSRL SBRL CLASSY RIPPER
# rules # literals # rules # literals # rules # literals # rules # literals
iris 3.0(0.) 3.0(0.) 3.0(0.) 4.0(0.) 3.0(0.) 3.0(0.) 3.1(0.3) 4.8(1.2)
cmc 6.2(1.5) 6.5(1.5) 3.9(0.9) 6.6(1.5) 6.4(1.1) 11.5(1.9) 3.9(0.9) 10.7(3.2)
cardio 8.9(1.2) 19.1(3.0) 9.7(1.1) 18.7(2.2) 13.6(0.9) 39.1(3.6) 14.9(3.0) 55.5(12.6)
page-blocks 9.0(0.89) 18.3(1.27) 11.0(0.8) 21.7(1.7) 19.5(1.2) 56.6(4.3) 16.6(2.2) 60.2(7.5)
dry-bean 16.8(1.2) 46.5(3.1) 27.2(1.4) 54.3(2.9) 42.1(3.1) 115.0(10.5) 51.6(6.2) 223.2(31.6)
pendigits 33.5(1.36) 126.3(4.28) 35.8(2.1) 71.5(4.3) 56.1(3.9) 187.9(10.7) 82.1(2.3) 333.9(15.3)
bounds forùê∫2(ùëü,ùëò)are obtained. By maximizing it, ModMod can
gradually improve the value of ùê∫2(ùëü,ùëò). As the global maximizer of
a modular function can be easily derived by collecting all the entries
with positive function values, ModMod can find a local optimum
efficiently.
So far we have discussed how to find an optimal condition given
a positionùëòand a label ùëô. By enumerating all possible positions
and labels, and finding the corresponding optimal conditions, the
optimal rule can be selected with highest insertion gain. The method
of finding the optimal solution for maximizing ùê∫(ùëü,ùëò)is presented
as Algorithm 3. As shown in Algorithm 3, we maintain a set ùëÉ
which contains the rule and position pair candidates. Given an
insert position ùëò, we first select the best rule from set ùëÖ(ùë°)and add
it toùëÉas stated in the 3th and 4th lines in Algorithm 3. Then for
each possible label, we run the ModMod method to learn optimal
condition. We finally get the optimal rule ùëüand position ùëòby testing
all the pairs of rule and position in ùëÉ. We note that as inserting
rules to different positions of ùëÖis independent with each other,
Algorithm 3 can run in a parallel manner to speedup.
Next, we present a sketch for ModMod method. In the ùëñth it-
eration of ModMod method, we first generate a modular lower
bound forùúî(ùëê)according to Eq. (12), denoted by ùúîùúÖ(ùëñ;ùëê(ùëñ)), and
two upper bounds for ùë£(ùëê), denoted by ¬Øùë£ùúÖ
1(ùëñ;ùëê(ùëñ))and ¬Øùë£ùúÖ
2(ùëñ;ùëê(ùëñ)),
according to Eq. (10)and Eq. (11), respectively. Combining these
bounds together, we achieve two modular bounds of the original
function, and maximizing these bounds can gradually improve the
value of the original function. We note that the maximizer of a
modular function can be easily obtained by collecting all the ele-
ments with positive values. The pseudocode of ModMod method is
present at Algorithm 4.Algorithm 4: ModMod
Input : Submodular function ùë§(ùëê)andùë£(ùëê)
Output: Best condition ùëê
1Initializeùëê(0);
2forj=0,. . . do
3 Choose a permutation ùúÖof[|Œì|]and formùëÜùúÖ;
4ùëê1‚Üê{ùëñ|ùúîùúÖ(ùëñ;ùëê(ùëó))‚àíùë£1(ùëñ;ùëê(ùëó))‚â•0};
5ùëê2‚Üê{ùëñ|ùúîùúÖ(ùëñ;ùëê(ùëó))‚àíùë£2(ùëñ;ùëê(ùëó))‚â•0};
6ùëê(ùë°+1)‚Üêarg maxùëê‚àà{ùëê1,ùëê2}ùê∫2((ùëê,ùëô),ùëò);
7 ifùëê(ùëó+1)=ùëê(ùëó)then break;
8Return c
6 EXPERIMENTS
In this section, we conduct experiments to demonstrate advan-
tages of the proposed sequence submodular optimization based
rule list learning method, which is referred to as SSRL. We report
the performance of our algorithm in terms of predicting accuracy,
interpretability and scalability.
6.1 Experimental Setup
Datasets. Most datasets in our experiments are from the UCI repos-
itory [ 18] and a few are the variants of the ProPublic recidivism
dataset [ 32] and the Fair Issac credit risk dataset [ 22]. Furthermore,
7 binary datasets and 6 multi-class datasets are included in the ex-
periments, where the number of classes of the multi-class datasets
are3,3,3,5,7,10, respectively. For all models compared in this paper,
we pre-process the features in the same way such that categorical
features are one-hot encoded as ùëêùëñ=ùë°andùëêùëñ‚â†ùë°and numerical
3765Efficient Decision Rule List Learning via Unified Sequence Submodular Optimization KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
features are divided using the sample deciles as thresholds with
binarized features created like ùëêùëñ<ùë°andùëêùëñ‚â•ùë°.
Baselines. Considering that our proposed algorithm is in the
field of rule list learning, we compare with 3 recent rule list mod-
els as baseline models, including SBRL [ 52], CORELS [ 5], and
CLASSY [ 41]. Both SBRL and CLASSY naturally support multi-
class classifications and all three methods resort to item miners
for candidate rules creation. Notice that, since the performance of
CORELS depends on the maximal number of nodes to search, the
process can be time-consuming when the number of features is
greater than 100, resulting in the average training time of CORELS
larger than an hour to get a decent rule list. To accelerate the train-
ing process of CORELS, we use Random Forest to select the top
30 important features as the input for CORELS. This modification
is denoted as CORELS‚àó. In addition to these 3 rule list models, 2
rule set models, IDRS [ 51] and RIPPER [ 14], are also included in
our baseline models.
Parameters Tuning. We evaluate the performance of mod-
els using 10-fold stratified cross validation, where the parameters
for all models are tuned. For SBRL, we choose the maximal num-
ber of features from {2,3}avoiding training time longer than our
limit. The minimum support ratio for pre-mining is chosen from
{0.001,0.0001}. For CORELS, the search policy for traversing the
tree is set to objective. The maximal cardinality and the minimal
support when mining the rules are set to 4and0.001, respectively.
To ensure that a sound rule can be achieved, the maximum trie
(cache) size is set to 5√ó105for all datasets. As for the Random
Forest model used before CORELS training, we fix the parameter
max_depth as 10, and other parameters as default. For CLASSY,
the default parameters setting is used, where the maximal num-
ber of features included in a rule is 5 and the model keeps finding
rules until no more compression can be achieved. For IDRS and
RIPPER, we tune the parameters following the same scheme in [ 51].
For the proposed method, we select the major class of the dataset
as the default class. The trade-off parameter ùúÜis selected from
{0.5,1,5,7,10}using cross validation. The maximal rules allowed ùúà
are chosen from{10,20,30,40}.
6.2 Classification Accuracy
The classification accuracy for binary and multi-class datasets are
presented in Table 4 and Table 5, respectively. As shown in Table 4,
the proposed SSRL achieves the highest classification accuracy on
most binary datasets. Rule list based methods SSRL and CLASSY
outperform rule set based methods IDRS and RIPPER on most
datasets, which is consistent with the claim that rule lists are more
expressive than rule sets. The proposed SSRL outperforms SBRL
and CORELS by a big margin. As the search space is restricted
to make it applicable to large-scale dataset, CORELS works the
worst among the rule list learning methods on all the large dataset
(number of samples greater than 10000). From Table 5, it is shown
that the proposed SSRL achieves the highest classification accuracy
on all multi-class datasets. All algorithms work well on the small
dataset iris, while performance of SBRL degrades significantly on
the large dataset ‚Äúpendigits‚Äù.6.3 Interpretability
To compare the interpretability of each algorithm, we report the
average length of the rule lists learned by respective methods, i.e.,
|ùëÖ|, as well as the literals used in the rule list, i.e.,√ç
ùëü‚ààùëÖ|ùëü|, presented
in Table 6 and Table reftab:main-result-rule2. As shown in Table
6, except dataset WDBC, the proposed SSRL generates much less
literals than rule set based models IDRS and RIPPER, which is again
due to the better expressiveness of rule lists. Since the proposed
method employs a greedy insert method which is more flexible
than appending, the rules learned by the proposed SSRL are more
compact as compared with CLASSY, i.e., less rules and less literals
involved.
6.4 Scalability
To demonstrate the scalability of the proposed method, we report
the running time of respective rule list learning algorithms on
datasets gasandWDBC under different numbers of features. Specif-
ically, we create new datasets by randomly selecting a fraction of
features from the binarized datasets, and then train the correspond-
ing rule list methods on it and also record their training times. The
process is repeated for 5 times and the average training time of
SSRL, SBRL and CLASSY under different numbers of features are
shown in Fig. 4a. From Fig. 4a, we observe that the proposed SSRL
requires much less training time than SBRL and CLASSY when the
number of features is large. CLASSY slightly outperforms SBRL
when the number of features are larger than 620. We do not in-
clude the comparison of running time with CORELS, as it fails to
learn models with comparable classification accuracy within sev-
eral hours. As shown in Fig. 4b, SSRL achieves a roughly linear
relationship between the training time and the data dimension,
which verifies the sound scalability of our algorithm further.
500 550 600 650 700 750
#features500600700800900100011001200Training time(s)
gas: training time vs number of features
SSRL
CLASSY
SBRL
(a) Training time on gas.
100 200 300 400 500
#features468101214161820time (sec)WDBC: training time vs number of features
SSRL (b) Training time on WDBC.
Figure 4: Scalability Study.
7 CONCLUSION
In this paper, we propose an efficient rule list learning method
based on sequence submodular optimization for both binary and
multi-class classification. By formulating the classification accuracy
as a sequence function which is shown to exhibit forward sequence
submodularity and local backward 1/(ùêæ‚àí1)-monotonicity, we
propose a unified optimization framework to learn the rule list. A
MM-based method is proposed where two tight lower bounds of
the original sequence function are iteratively maximized using the
proposed greedy insert procedure. Performance lower bound of the
proposed greedy insert method is also provided. Extensive experi-
mental results are provided to show the superiority of our method
in terms of both model classification ability and interpretability.
3766KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
REFERENCES
[1]Sina Aghaei, Andres Gomez, and Phebe Vayanos. 2020. Learning optimal clas-
sification trees: Strong max-flow formulations. arXiv preprint arXiv:2002.09142
(2020).
[2]Ga√´l Aglin, Siegfried Nijssen, and Pierre Schaus. 2020. Learning optimal decision
trees using caching branch-and-bound search. In Proceedings of the AAAI, Vol. 34.
3146‚Äì3153.
[3]Saeed Alaei, Ali Makhdoumi, and Azarakhsh Malekian. 2021. Maximizing
sequence-submodular functions and its application to online advertising. Man-
agement Science 67, 10 (2021), 6030‚Äì6054.
[4]Saeed Alaei and Azarakhsh Malekian. 2010. Maximizing sequence-submodular
functions. arXiv preprint arXiv:1009.4153 (2010).
[5]Elaine Angelino, Nicholas Larus-Stone, Daniel Alabi, Margo Seltzer, and Cynthia
Rudin. 2017. Learning Certifiably Optimal Rule Lists. In Proceedings of the 23rd
ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.
35‚Äì44.
[6]Onur Asan, Alparslan Emrah Bayrak, and Avishek Choudhury. 2020. Artificial
intelligence and human trust in healthcare: focus on clinicians. Journal of medical
Internet research 22, 6 (2020), e15154.
[7]Martin Atzmueller. 2015. Subgroup Discovery. Wiley Interdisciplinary Reviews:
Data Mining and Knowledge Discovery 5, 1 (2015), 35‚Äì49.
[8]Sumanta Basu, Karl Kumbier, James B Brown, and Bin Yu. 2018. Iterative random
forests to discover predictive and stable high-order interactions. Proceedings of
the National Academy of Sciences 115, 8 (2018), 1943‚Äì1948.
[9]Sara Bernardini, Fabio Fagnani, and Chiara Piacentini. 2020. Through the lens
of sequence submodularity. In Proceedings of the International Conference on
Automated Planning and Scheduling, Vol. 30. 38‚Äì47.
[10] Sara Bernardini, Fabio Fagnani, and Chiara Piacentini. 2021. A unifying look at
sequence submodularity. Artificial Intelligence 297 (2021), 103486.
[11] Dimitris Bertsimas and Jack Dunn. 2017. Optimal classification trees. Machine
Learning 106, 7 (2017), 1039‚Äì1082.
[12] Niv Buchbinder, Moran Feldman, Joseph Naor, and Roy Schwartz. 2014. Submod-
ular maximization with cardinality constraints. In Proceedings of the twenty-fifth
annual ACM-SIAM symposium on Discrete algorithms. SIAM, 1433‚Äì1452.
[13] Allison Chang, Dimitris Bertsimas, and Cynthia Rudin. 2012. An Integer Optimiza-
tion Approach to Associative Classification. In Advances in Neural Information
Processing Systems. 269‚Äì277.
[14] William W Cohen. 1995. Fast Effective Rule Induction. In Proceedings of the 12th
International Conference on Machine Learning. 115‚Äì123.
[15] Sanjeeb Dash, Oktay Gunluk, and Dennis Wei. 2018. Boolean Decision Rules
via Column Generation. In Advances in Neural Information Processing Systems.
4655‚Äì4665.
[16] J Richard Dietrich and Robert S Kaplan. 1982. Empirical analysis of the commercial
loan classification decision. Accounting Review (1982), 18‚Äì38.
[17] Julia Dressel and Hany Farid. 2018. The accuracy, fairness, and limits of predicting
recidivism. Science advances 4, 1 (2018), eaao5580.
[18] Dheeru Dua and Casey Graff. 2017. UCI Machine Learning Repository. http:
//archive.ics.uci.edu/ml
[19] Jonathan Eckstein, Noam Goldberg, and Ai Kagawa. 2017. Rule-enhanced penal-
ized regression by column generation using rectangular maximum agreement.
InICML. PMLR, 1059‚Äì1067.
[20] Radwa ElShawi, Youssef Sherif, Mouaz Al-Mallah, and Sherif Sakr. 2020. Inter-
pretability in healthcare: A comparative study of local machine learning inter-
pretability techniques. Computational Intelligence (2020).
[21] Uriel Feige, Vahab S Mirrokni, and Jan Vondr√°k. 2011. Maximizing non-monotone
submodular functions. SIAM J. Comput. 40, 4 (2011), 1133‚Äì1153.
[22] FICO, Google, Imperial College London, MIT, University of Oxford, UC Irvine,
and UC Berkeley. 2018. Explainable Machine Learning Challenge. https:
//community.fico.com/s/explainable-machine-learning-challenge
[23] Bishwamittra Ghosh, Dmitry Malioutov, and Kuldeep S. Meel. 2020. Classification
Rules in Relaxed Logical Form. In Proc. of ECAI.
[24] Bishwamittra Ghosh and Kuldeep S. Meel. 2019. IMLI: An Incremental Framework
for MaxSAT-Based Learning of Interpretable Classification Rules. In Proc. of AIES.
[25] Leilani H Gilpin, David Bau, Ben Z Yuan, Ayesha Bajwa, Michael Specter, and
Lalana Kagal. 2018. Explaining explanations: An overview of interpretability of
machine learning. In 2018 IEEE 5th International Conference on data science and
advanced analytics (DSAA). IEEE, 80‚Äì89.
[26] Chris Harshaw, Moran Feldman, Justin Ward, and Amin Karbasi. 2019. Sub-
modular maximization beyond non-negativity: Guarantees, fast algorithms, and
applications. In ICML. PMLR, 2634‚Äì2643.
[27] Rishabh Iyer, Stefanie Jegelka, and Jeff Bilmes. 2013. Fast semidifferential-based
submodular function optimization. In ICML. PMLR, 855‚Äì863.
[28] Jon Kleinberg, Emily Ryu, and √âva Tardos. 2022. Ordered submodularity and its
applications to diversifying recommendations. arXiv preprint arXiv:2203.00233
(2022).
[29] Andreas Krause and Daniel Golovin. 2014. Submodular function maximization.
Tractability 3 (2014), 71‚Äì104.[30] Himabindu Lakkaraju, Stephen H Bach, and Jure Leskovec. 2016. Interpretable
decision sets: A joint framework for description and prediction. In Proceedings of
the 22nd ACM SIGKDD international conference on knowledge discovery and data
mining. 1675‚Äì1684.
[31] Himabindu Lakkaraju and Cynthia Rudin. 2017. Learning cost-effective and
interpretable treatment regimes. In Artificial intelligence and statistics. PMLR,
166‚Äì175.
[32] Jeff Larson, Surya Mattu, Lauren Kirchner, and Julia Angwin. 2016. How We
Analyzed the COMPAS Recidivism Algorithm. ProPublica (2016).
[33] Jimmy Lin, Chudi Zhong, Diane Hu, Cynthia Rudin, and Margo Seltzer. 2020.
Generalized and scalable optimal sparse decision trees. In ICML. PMLR, 6150‚Äì
6160.
[34] Pantelis Linardatos, Vasilis Papastefanopoulos, and Sotiris Kotsiantis. 2021. Ex-
plainable AI: A Review of Machine Learning Interpretability Methods. Entropy
23, 1 (2021), 18.
[35] Dmitry Malioutov and Kuldeep S. Meel. 2018. MLIC: A MaxSAT-Based framework
for learning interpretable classification rules. In Proceedings of International
Conference on Constraint Programming (CP).
[36] Graziano Mita, Paolo Papotti, Maurizio Filippone, and Pietro Michiardi. 2020.
LIBRE: Learning interpretable boolean rule ensembles. In ICAIS. PMLR, 245‚Äì255.
[37] Susan A Murphy. 2003. Optimal dynamic treatment regimes. Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 65, 2 (2003), 331‚Äì355.
[38] Nina Narodytska, Alexey Ignatiev, Filipe Pereira, Joao Marques-Silva, and IS RAS.
2018. Learning Optimal Decision Trees with SAT.. In Ijcai. 1362‚Äì1368.
[39] George L Nemhauser, Laurence A Wolsey, and Marshall L Fisher. 1978. An analysis
of approximations for maximizing submodular set functions‚ÄîI. Mathematical
programming 14 (1978), 265‚Äì294.
[40] Pierre Perrault, Jennifer Healey, Zheng Wen, and Michal Valko. 2021. On the
approximation relationship between optimizing ratio of submodular (rs) and
difference of submodular (ds) functions. arXiv preprint arXiv:2101.01631 (2021).
[41] Hugo M Proen√ßa and Matthijs van Leeuwen. 2020. Interpretable multiclass
classification by MDL-based rule lists. Information Sciences 512 (2020), 1372‚Äì
1393.
[42] J Ross Quinlan and R Mike Cameron-Jones. 1993. FOIL: A midterm report. In
ECML. Springer, 1‚Äì20.
[43] Ronald L Rivest. 1987. Learning decision lists. Machine learning 2, 3 (1987),
229‚Äì246.
[44] Cynthia Rudin, Chaofan Chen, Zhi Chen, Haiyang Huang, Lesia Semenova, and
Chudi Zhong. 2021. Interpretable Machine Learning: Fundamental Principles
and 10 Grand Challenges. arXiv:2103.11251 [cs.LG]
[45] Cynthia Rudin and ≈ûeyda Ertekin. 2018. Learning customized and optimized
lists of rules with mathematical programming. Mathematical Programming
Computation 10, 4 (2018), 659‚Äì702.
[46] Matthew Streeter and Daniel Golovin. 2008. An online algorithm for maximizing
submodular functions. NeurIPS 21 (2008).
[47] Ying Sun, Prabhu Babu, and Daniel P. Palomar. 2017. Majorization-Minimization
Algorithms in Signal Processing, Communications, and Machine Learning. IEEE
Transactions on Signal Processing 65, 3 (2017), 794‚Äì816. https://doi.org/10.1109/
TSP.2016.2601299
[48] Fulton Wang and Cynthia Rudin. 2015. Falling Rule Lists. In Proceedings of
Artificial Intelligence and Statistics (AISTATS).
[49] Tong Wang and Cynthia Rudin. 2015. Learning Optimized Or‚Äôs of And‚Äôs.
arXiv:1511.02210 [cs.AI]
[50] Tong Wang, Cynthia Rudin, Finale Doshi-Velez, Yimin Liu, Erica Klampfl, and
Perry MacNeille. 2017. A bayesian framework for learning rule sets for inter-
pretable classification. The Journal of Machine Learning Research 18, 1 (2017),
2357‚Äì2393.
[51] Fan Yang, Kai He, Linxiao Yang, Hongxia Du, Jingbang Yang, Bo Yang, and Liang
Sun. 2021. Learning Interpretable Decision Rule Sets: A Submodular Optimization
Approach. NeurIPS 34 (2021).
[52] Hongyu Yang, Cynthia Rudin, and Margo Seltzer. 2017. Scalable Bayesian Rule
Lists. In Proceedings of the 34th International Conference on Machine Learning.
3921‚Äì3930.
[53] Jinqiang Yu, Alexey Ignatiev, Pierre Le Bodic, and Peter J Stuckey. 2020. Optimal
decision lists using SAT. arXiv preprint arXiv:2010.09919 (2020).
[54] Yichi Zhang, Eric B Laber, Anastasios Tsiatis, and Marie Davidian. 2015. Using
decision lists to construct interpretable and parsimonious treatment regimes.
Biometrics 71, 4 (2015), 895‚Äì904.
[55] Zhenliang Zhang, Edwin KP Chong, Ali Pezeshki, and William Moran. 2015.
String submodular functions with curvature constraints. IEEE Trans. Automat.
Control 61, 3 (2015), 601‚Äì616.
[56] Haoran Zhu, Pavankumar Murali, Dzung Phan, Lam Nguyen, and Jayant
Kalagnanam. 2020. A scalable MIP-based method for learning optimal mul-
tivariate decision trees. NeurlIPS 33 (2020), 1771‚Äì1781.
3767Efficient Decision Rule List Learning via Unified Sequence Submodular Optimization KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain
A APPENDIX
A.1 Proof of Lemmas
A.1.1 Proof of Lemma 1.
Proof. (1). We prove the first statement of Lemma 1. Let ùëÖbe
a prefix and ùëü1=(ùëê1,ùëô1)andùëü2=(ùëê2,ùëô2)be two rules,CùëÖandSùëÖ
as the set of samples that covered and correctly classified by ùëÖ,
respectively. We have
ùëù(ùëÖ‚äïùëü1)=|SùëÖ|+|CùëÖ‚à©C1‚à©L 1| (27)
ùëù(ùëÖ‚äïùëü1‚äïùëü2)=|SùëÖ|+|CùëÖ‚à©C1‚à©L 1|+|CùëÖ‚à©C1‚à©C2‚à©L 2|
which brings us
ùëù(ùëÖ‚äïùëü1‚äïùëü2)‚àíùëù(ùëÖ‚äïùëü1)=|CùëÖ‚à©C1‚à©C2‚à©L 2|
‚â§|CùëÖ‚à©C2‚à©L 2|
=|SùëÖ|+|CùëÖ‚à©C2‚à©L 2|‚àí|SùëÖ|
=ùëù(ùëÖ‚äïùëü2)‚àíùëù(ùëÖ). (28)
Then we conclude that ùëù(ùëÖ)is forward sequence submodular func-
tion.
(2). Next we prove that ùëù(ùëÖ)is forward monotone function. Let
SùëÖ1andSùëÖ2be the set of samples that correctly classified by ùëÖ1
andùëÖ2, respectively. LetCùëÖ1denote the set of samples covered by
ùëÖ1, then the statement can be easily proven by
ùëù(ùëÖ1‚äïùëÖ2)‚àíùëù(ùëÖ1)=|SùëÖ1|+|CùëÖ1‚à©SùëÖ2|‚àí|SùëÖ1|
=|CùëÖ1‚à©SùëÖ2|‚â•0. (29)
(3). The third statement is proven by contradiction. As
ùëù(ùëÖ1‚äïùëÖ2)‚àíùëù(ùëÖ2)=|SùëÖ1|+|CùëÖ1‚à©SùëÖ2|‚àí|SùëÖ2|
=|SùëÖ1|‚àí|CùëÖ1‚à©SùëÖ2|. (30)
LetùëÖ1andùëÖ2be the rule lists that cover all the samples, then
anyùëÖ2with higher classification accuracy than ùëÖ1will leads to
|SùëÖ1|‚àí|CùëÖ1‚à©SùëÖ2|=|SùëÖ1|‚àí|SùëÖ2|<0.
(4). The submodularity of ùëë(ùëÖ)comes from the property of union
operation.
(5). Asùë¢(ùëÖ)is a summation over all the gains of elements in ùëÖ,
it is a modular function. ‚ñ°
A.1.2 Proofs of Theorem 2 and Corollary 1. We only prove Corol-
lary 1, as Theorem 2 holds naturally if Corollary 1 holds.
Proof. LetÀÜùëÖ(ùëñ)and ÀÜùëÖ(ùëñ+1)denote the sequences generated by
Algorithm 1 at the ùëñ-th and(ùëñ+1)-th iteration, respectively. Assume
ÀÜùëÖ(ùëñ+1)is obtained by inserting element ùëü‚Ä≤to theùëó-th position of ÀÜùëÖ(ùëñ).
LetùëÖ‚àó=(ùëü‚àó
1,...,ùëü‚àó
|ùëÖ‚àó|)be the optimal sequence that maximizes
Àúùëì(ùëÖ). Then we have
ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ)‚äïùëÖ‚àó)‚àíùúì(ÀÜùëÖ(ùëñ)))‚àíùúã(ùëÖ‚àó)
=|ùëÖ‚àó|‚àëÔ∏Å
ùë°=1ùõºùëñ+1(ùúì(ùëÇùë°)‚àíùúì(ùëÇùë°‚àí1))‚àíùúã(ùëü‚àó
ùë°)=|ùëÖ‚àó|‚àëÔ∏Å
ùë°=1ùõΩùë°, (31)
whereùõΩùë°=ùõºùëñ+1(ùúì(ùëÇùë°)‚àíùúì(ùëÇùë°‚àí1))‚àíùúã(ùëü‚àó
ùë°),ùëÇùë°denotes the sequence
obtained by appending (ùëü‚àó
1,...,ùëü‚àó
ùë°)toÀÜùëÖ(ùëñ), withùëÇ0=ÀÜùëÖ(ùëñ)andùëÇ|ùëÖ‚àó|=ÀÜùëÖ(ùëñ)‚äïùëÖ‚àó. LetùõΩùúâbe the maximal of set {ùõΩùë°}|ùëÖ‚àó|
ùë°=1, then we
have
ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ)‚äïùëÖ‚àó)‚àíùúì(ÀÜùëÖ(ùëñ)))‚àíùúã(ùëÖ‚àó)
=|ùëÖ‚àó|‚àëÔ∏Å
ùë°=1ùõºùëñ+1(ùúì(ùëÇùë°)‚àíùúì(ùëÇùë°‚àí1))‚àíùúã(ùëü‚àó
ùë°)
(ùëé)
‚â§|ùëÖ‚àó|(ùõºùëñ+1(ùúì(ùëÇùúâ)‚àíùúì(ùëÇùúâ‚àí1))‚àíùúã(ùëü‚àó
ùúâ))
(ùëè)
‚â§ùúà(ùõºùëñ+1(ùúì(ùëÇùúâ)‚àíùúì(ùëÇùúâ‚àí1))‚àíùúã(ùëü‚àó
ùúâ))
(ùëê)
‚â§ùúà(ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ)‚äïùëü‚àó
ùúâ))‚àíùúì(ÀÜùëÖ(ùëñ))‚àíùúã(ùëü‚àó
ùúâ))
=ùúà(ùõºùëñ+1ùúì(ùëü‚àó
ùúâ,ùëñ+1|ÀÜùëÖ(ùëñ))‚àíùúã(ùëü‚àó
ùúâ))
(ùëë)
‚â§ùúà(ùõºùëñ+1ùúì(ùëü‚Ä≤,ùëó|ÀÜùëÖ(ùëñ))‚àíùúã(ùëü‚Ä≤))
=ùúà(ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ+1))‚àíùúì(ÀÜùëÖ(ùëñ)))‚àíùúã(ÀÜùëÖ(ùëñ+1))+ùúã(ÀÜùëÖ(ùëñ)))),(32)
where(ùëé)comes from the assumption that ùõΩùúâis the maximal of
{ùõΩùë°}|ùëÖ‚àó|
ùë°=1,(ùëè)comes from|ùëÖ‚àó| ‚â§ùúà,(ùëê)comes from the forward
submodularity of ùúì(ùëÖ), and(ùëë)comes from the optimality of (ùëü‚Ä≤,ùëó).
Recall the assumption that ùúì(ùëÖ)is backward ùúÇ-monotone on the
set{ÀÜùëÖ(ùëñ)}ùúà
ùëñ=1‚à™{ùëÖ‚àó}, then we have ùúì(ÀÜùëÖ(ùëñ)‚äïùëÖ‚àó)‚â•ùúÇùúì(ùëÖ‚àó), which
bring us
ùõºùëñ+1(ùúÇùúì(ùëÖ‚àó)‚àíùúì(ÀÜùëÖ(ùëñ)))‚àíùúã(ùëÖ‚àó)
‚â§ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ)‚äïùëÖ‚àó)‚àíùúì(ÀÜùëÖ(ùëñ)))‚àíùúã(ùëÖ‚àó)
‚â§ùúà(ùõºùëñ+1(ùúì(ÀÜùëÖ(ùëñ+1))‚àíùúì(ÀÜùëÖ(ùëñ))‚àíùúã(ÀÜùëÖ(ùëñ+1))+ùúã(ÀÜùëÖ(ùëñ)))). (33)
By rearranging the inequality, we have
ùõºùëñ+1ùúì(ÀÜùëÖ(ùëñ+1))‚àíùõºùëñùúÇùúì(ùëÖ‚àó)‚àíùúã(ÀÜùëÖ(ùëñ+1))
‚â•(1‚àí1
ùúà)ùõºùëñ+1ùúì(ÀÜùëÖ(ùëñ))‚àí( 1‚àí1
ùúà)ùõºùëñ+1ùúÇùúì(ùëÖ‚àó)‚àíùúã(ÀÜùëÖ(ùëñ))‚àí1
ùúàùúã(ùëÖ‚àó)
=ùõºùëñùúì(ÀÜùëÖ(ùëñ))‚àíùõºùëñùúÇùúì(ùëÖ‚àó)‚àíùúã(ÀÜùëÖ(ùëñ))‚àí1
ùúàùúã(ùëÖ‚àó). (34)
Then we have
ùõºùúàùúì(ÀÜùëÖ(ùúà))‚àíùõºùúàùúÇùúì(ùëÖ‚àó)‚àíùúã(ÀÜùëÖ(ùúà))
‚â•ùõº0ùúì(ÀÜùëÖ(0))‚àíùõº0ùúÇùúì(ùëÖ‚àó)‚àíùúã(ÀÜùëÖ(0))‚àíùúã(ùëÖ‚àó)
(ùëé)=‚àí(1‚àí1
ùúà)ùúàùúÇùúì(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó)
‚â•‚àí1
ùëíùúÇùëù(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó), (35)
where(ùëé)comes from the fact that ùúì(‚àÖ)=0andùúã(‚àÖ)=0. As
ùõºùúà=1, we have
ùúì(ÀÜùëÖ(ùúà))‚àíùúã(ÀÜùëÖ(ùúà))=ùõºùúàùúì(ÀÜùëÖ(ùúà))‚àíùúã(ÀÜùëÖ(ùúà))
‚â•(1‚àí1
ùëí)ùúÇùúì(ùëÖ‚àó)‚àíùúã(ùëÖ‚àó), (36)
which completes our proof. ‚ñ°
A.1.3 Proof of Lemma 3. We prove Lemma 3 by first showing that
ùëù(ùëÖ)is generally backward ùúÇ-monotone on a set RùúÇ, and then prove
that all the prefixes generated by Algorithm 1 are lying in R1/(ùêæ‚àí1).
We first have following result.
3768KDD ‚Äô24, August 25‚Äì29, 2024, Barcelona, Spain Linxiao Yang, Jingbang Yang, & Liang Sun
Lemma 7. LetRùúÇbe the set formed by all the prefixes with accuracy
on the samples whose label different to ùëôùëëno less thanùúÇ. Thenùëù(ùëÖ)is
backwardùúÇ-monotone onRùúÇ.
Proof. LetCùëÖbe the set of samples covered by ùëÖ,SùëÖandSùëÖ‚Ä≤de-
note the set of samples correctly classified by ùëÖandùëÖ‚Ä≤, respectively.
Asùëù(ùëÖ)counts the number of samples that correctly classified by
ùëÖ, thenùëù(ùëÖ‚äïùëÖ‚Ä≤)=|SùëÖ|+|CùëÖ‚à©SùëÖ‚Ä≤|andùëù(ùëÖ‚Ä≤)=|SùëÖ‚Ä≤|. Recall
thatùúÇ=|SùëÖ|/|CùëÖ|, then we have
ùëù(ùëÖ‚äïùëÖ‚Ä≤)=|SùëÖ|+|CùëÖ‚à©SùëÖ‚Ä≤|=|SùëÖ‚à©Lùëë|+|CùëÖ‚à©SùëÖ‚Ä≤‚à©Lùëë|
=ùúÇ|CùëÖ‚à©Lùëë|+|CùëÖ‚à©SùëÖ‚Ä≤‚à©Lùëë|
‚â•ùúÇ|CùëÖ‚à©Lùëë|+ùúÇ|CùëÖ‚à©SùëÖ‚Ä≤‚à©Lùëë|
‚â•ùúÇ|CùëÖ‚à©SùëÖ‚Ä≤‚à©Lùëë|+ùúÇ|CùëÖ‚à©SùëÖ‚Ä≤‚à©Lùëë|
=ùúÇ|SùëÖ‚Ä≤‚à©Lùëë|=ùúÇùëù(ùëÖ‚Ä≤), (37)
which complete our proof. ‚ñ°
We then show that all the prefixes generated by Algorithm 1 are
lying onR1/(ùêæ‚àí1).
Lemma 8. LetÀÜùëÖ(ùëñ)be the prefix generated by Algorithm 1 at the
ùëñ-th iteration, if ÀÜùëÖ(ùëñ)is not empty sequence, then the classification
accuracy of ÀÜùëÖ(ùëñ)on samples whose label different to ùëôùëëis no less than
1/(ùêæ‚àí1), whereùêæis the number of classes.
Proof. Our proof is based on induction. Obviously, Lemma 8
holds for ÀÜùëÖ(1), as one can always set the label of the rule in ÀÜùëÖ(1)
to the majority class it covers, in which case, its accuracy is no
less than 1/(ùêæ‚àí1). Assuming the accuracy of ÀÜùëÖ(ùëñ)is no less than
1/(ùêæ‚àí1), we now prove that the accuracy of ÀÜùëÖ(ùëñ+1)is also greater
than 1/(ùêæ‚àí1). Suppose ÀÜùëÖ(ùëñ+1)is obtained by inserting a rule ùëü
into theùëóth position of ÀÜùëÖ(ùëñ). We discuss the accuracy of ÀÜùëÖ(ùë°)‚äïùëü‚Ä≤,
whereùëü‚Ä≤is the rule obtained by changing the label of ùëüsuch that the
accuracy of ÀÜùëÖ(ùë°)‚äïùëü‚Ä≤is greater than 1/ùêæ. Noted that ÀÜùëÖ(ùë°)‚äïùëü‚Ä≤and
ÀÜùëÖ(ùë°+1)share the same values for functions ùëë1(ùëÖ;ÀÜùëÖ(ùëñ)),ùëë2(ùëÖ;ÀÜùëÖ(ùëñ)),
andùë¢(ùëÖ). Hence, the optimality of (ùëü,ùëó)concludes that the accuracy
ofÀÜùëÖ(ùëñ+1)is no less than ÀÜùëÖ(ùëñ)‚äïùëü‚Ä≤and consequently no less than
1/(ùêæ‚àí1). ‚ñ°
Lemma 8 shows that the prefixes generated by Algorithm 1 at
each iteration have accuracy no less than 1/(ùêæ‚àí1), if they are not
empty. Obviously, the accuracy of optimal prefix ùëÖ‚àóis no less than
the prefixes we learned. Then we can conclude that all of them are
lying onR1/(ùêæ‚àí1). Recall the result in Lemma 7, we arrive at the
claim in Lemma 3, which completes our proof.
A.1.4 Proof of Lemma 5.
Proof. We note that as it is trivial to proof the lemma if ùëü2‚àà
Œ©\ùëÖ(ùë°), then we only discuss the scenario ùëü2‚ààùëÖ(ùë°). Letùëü‚Ä≤
2=
arg maxùëü‚ààŒ©\ùëÖ(ùë°)ùê∫2(ùëü,ùëò). Due to the optimality of ùëü2, we haveùê∫2(ùëü2,ùëò)‚â•
ùê∫2(ùëü‚Ä≤
2,ùëò). Asùëëis submodular, then ùëë(ùëü2|‚àÖ) ‚â•ùëë(ùëü2|ùëÖ(ùë°)\{ùëü2}),
which consequently brings ùê∫2(ùëü2,ùëò)‚â§ùê∫1(ùëü2,ùëò)‚â§ùê∫1(ùëü1,ùëò), where
the last inequality comes from the definition of ùëü1. Then it is clear
that ifùëü2‚ààùëÖ(ùë°), one can certainly claim that ùëü1is the maximizer of
ùê∫(ùëü,ùëò), which completes the proof. ‚ñ°Table 8: Learned rule list by SSRL on COMPAS-binary dataset.
conditions label
IFjuvenile-crimes:!=0 AND
juvenile-misdemeanors:=01
EISE IF ‚Äôage:>26 AND priors:2-3‚Äô 0
EISE IF ‚Äôage:<21 AND sex: not Female‚Äô 1
EISE IF ‚Äôpriors:!=0 AND priors:!=1‚Äô 1
EISE 0
Table 9: Learned rule list by SSRL on Iris dataset.
conditions label
IF ‚Äôpetal length <= 2.63‚Äô Iris-setosa
EISE IF ‚Äôpetal length <= 4.9 AND petal width <= 1.6‚Äô Iris-versicolor
EISE Iris-virginica
A.1.5 Proof of Lemma 6.
Proof. Given(C<ùëñ‚à©Cùëñ‚à©Lùëñ)‚à©(C<ùëó‚à©Cùëó‚à©Lùëó)=‚àÖ,‚àÄùëñ‚â†ùëó,
we rewriteùëù(ùëÖ)=|S‚â§ùëò|+|S >ùëò|, where
S‚â§ùëò=ùëò√ò
ùëñ=1
C<ùëñ‚à©Cùëñ‚à©Lùëñ
,S>ùëò=|ùëÖ|√ò
ùëñ=ùëò+1
C<ùëñ‚à©Cùëñ‚à©Lùëñ
.(38)
Then we have the number of correctly classified samples after the
insertion
ùëù(I(ùëÖ,ùëò,ùëü))=|S‚â§ùëò|+|C‚â§ùëò‚à©C‚à©L|+|S >ùëò‚à©C| (39)
and the marginal gain
ùëù(ùëü,ùëò|ùëÖ)=|C‚â§ùëò‚à©C‚à©L|‚àí|S >ùëò‚à©C|. (40)
Consequently,
ùê∫2(ùëü,ùëò)=ùõºùëù(ùëü,ùëò|ùëÖ)‚àíùëë(ùëü|‚àÖ)‚àíùúÜ|ùëê|
=ùõº|C‚â§ùëò‚à©C‚à©L|‚àí ùõº|S>ùëò‚à©C|‚àí|C‚à©L ùëë|‚àíùúÜ|ùëê|
(ùëé)‚àù‚àíùõº|C‚â§ùëò‚à©C‚à©L|+ùõº|S>ùëò‚à©C|+|C‚à©Lùëë|‚àíùúÜ|ùëê|,
(41)
where(ùëé)comes from that|A‚à©C| =|A|‚àí|A‚à©C|‚àù‚àí|A‚à©C|.
We define
ùúî(ùëê)=ùõº|S>ùëò‚à©C|+|C‚à©Lùëë|
=ùõºS>ùëò‚à©
‚à™ùëí‚ààùëêE+
‚à™ùëí‚ààùëêE
‚à©Lùëë, (42)
ùë£(ùëê)=ùõº|C‚â§ùëò‚à©C‚à©L|+ùúÜ|ùëê|
=ùõºC‚â§ùëò‚à©
‚à™ùëí‚ààùëêE
‚à©L+ùúÜ|ùëê|, (43)
whereEdenotes the set of samples containing feature ùëí,C=‚à©ùëí‚ààùëêE,
andC=‚à™ùëí‚ààùëêE, we complete our proof at
ùê∫2(ùëü,ùëò)‚àùùúî(ùëê)‚àíùë£(ùëê). (44)
‚ñ°
A.2 Example rule lists generated by proposed
SSRL
To further illustrate the interpretability of the proposed method,
we present the rule list generated by our method SSRL on datasets
COMPAS-binary and Iris, as summarized in Table 8 and Table 9,
respectively.
3769