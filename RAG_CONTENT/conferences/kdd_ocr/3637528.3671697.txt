Dense Subgraph Discovery Meets Strong Triadic Closure
Chamalee Wickrama Arachchi
University of Helsinki
Helsinki, Finland
chamalee.wickramaarachch@helsinki.fiIiro Kumpulainen
University of Helsinki
Helsinki, Finland
iiro.kumpulainen@helsinki.fiNikolaj Tatti
HIIT, University of Helsinki
Helsinki, Finland
nikolaj.tatti@helsinki.fi
Abstract
Finding dense subgraphs is a core problem with numerous graph
mining applications such as community detection in social net-
works and anomaly detection. However, in many real-world net-
works connections are not equal. One way to label edges as either
strong or weak is to use strong triadic closure (STC). Here, if one
node connects strongly with two other nodes, then those two nodes
should be connected at least with a weak edge. STC-labelings are
not unique and finding the maximum number of strong edges is
NP-hard. In this paper, we apply STC to dense subgraph discovery.
More formally, our score for a given subgraph is the ratio between
the sum of the number of strong edges and weak edges, weighted
by a user parameter 𝜆, and the number of nodes of the subgraph.
Our goal is to find a subgraph and an STC-labeling maximizing the
score. We show that for 𝜆=1, our problem is equivalent to finding
the densest subgraph, while for 𝜆=0, our problem is equivalent to
finding the largest clique, making our problem NP-hard. We pro-
pose an exact algorithm based on integer linear programming and
four practical polynomial-time heuristics. We present an extensive
experimental study that shows that our algorithms can find the
ground truth in synthetic datasets and run efficiently in real-world
datasets.
CCS Concepts
•Theory of computation →Graph algorithms analysis.
Keywords
dense subgraph, strong triadic closure, integer linear programming
ACM Reference Format:
Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti. 2024.
Dense Subgraph Discovery Meets Strong Triadic Closure. In Proceedings of
the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining
(KDD ’24), August 25–29, 2024, Barcelona, Spain. ACM, New York, NY, USA,
11 pages. https://doi.org/10.1145/3637528.3671697
1 Introduction
Many social networks naturally contain both strongly connected
andweakly connected interactions among the entities of the net-
work. A question of particular interest is that given a set of pairwise
user interactions, how to infer the strength of the social ties within
the network? In other words, how to label the edges of an undi-
rected graph as either strong or weak?
This work is licensed under a Creative Commons Attribution
International 4.0 License.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671697(a) (
b) (
c)
Figure 1: Strong (Red) and weak (Blue) edges of the Karate
club dataset maximizing the number of strong edges (a), 𝜆=0
(b), and𝜆=0.5(c) using our integer linear program based
algorithm (STC-ILP). We define our score as the sum of the
number of strong and weak edges weighted by a parameter
𝜆, divided by the size of the subgraph. The scores are 2.0and
2.06for (b) and (c), respectively. We see that (b) is a clique of
size 5.
The problem of inferring the strength of social ties based on
strong triadic closure principle (STC) has drawn attention over the
past decade within the data mining community [ 1,14,16,17,21,24].
The STC property assumes that there exist two types of social ties in
the network: either strong orweak. Let𝐴,𝐵, and𝐶be three entities
in the network. If the entities 𝐴and𝐵are strongly connected
with the entity 𝐶, then there should be at least a weak connection
between𝐴and𝐵. In other words, if both 𝐴and𝐵are strong friends
of𝐶, then some kind of connection between 𝐴and𝐵should also
exist. Note that these labels are not known and the goal is to infer
the labels from the given unlabeled graph.
In this paper, we incorporate the STC property into the prob-
lem of dense subgraph discovery [ 9,24]. More formally, given a
subgraph and a weight parameter 𝜆, we define a score as the ratio
between the sum of the number of strong and weak edges weighted
by𝜆and the number of nodes within the subgraph. Our objective
is to find a subgraph anda labeling that maximize our score while
satisfying the STC property within the subgraph.
We will see that when 𝜆=0finding an optimal subgraph is equal
to finding a maximum clique. On the other hand, for 𝜆=1, finding
an optimal subgraph is equal to finding the densest subgraph, that is,
a subgraph𝑈maximizing the ratio of edges and nodes, |𝐸(𝑈)|/|𝑈|.
Both of these problems are well-studied. Optimizing the score for
0<𝜆<1, yields a problem that is between these two cases. We
expect that for small 𝜆s the returned subgraph resembles a clique
whereas large 𝜆s yield a subgraph similar to the densest subgraph.
Example: We illustrate the difference between our problem and
the original STC problem considered by Sintos and Tsaparas [24] in
Figure 1. The goal of this paper is to find a subgraph that maximizes
our score while satisfying the STC property. In contrast, Sintos and
3334
KDD ’24, August 25–29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
Tsaparas [24] aims to label allthe edges in the graph such that the
number of weak edges is minimized. Figure 1 shows the results
obtained with the Karate club dataset with our exact algorithm. We
should stress that the labeling of the discovered subgraph might
be different from the labeling that maximizes strong edges for the
whole graph. In Figure 1 (c), we see that 4weak edges have been
turned into strong while the labeling of the remaining edges is
unchanged.
We show that our problem is NP-hard when 𝜆<1, and even
inapproximable when 𝜆=0since our problem then reduces to
theMax-Cliqe problem. However, the 𝜆=1case is solvable in
polynomial time. To solve the problem, we first propose an exact
algorithm based on integer linear programming which runs in
exponential time. We consider four other heuristics that run in
polynomial time in the size of the input graph: We propose a linear
linear programming based heuristic in Section 5.2 and a greedy
algorithm in Section 5.4. We also propose two straightforward
algorithms that combine the existing algorithms for solving the
densest subgraph problem and finding STC-compliant labeling in
an entire graph.
The remainder of the paper is organized as follows. First, we
introduce preliminary notation and our problem in Section 2. Next,
we present the related work in Section 3. Next, we show that our
problem is NP-hard in Section 4 and then explain our algorithms
in Section 5. Finally, we present our experimental evaluation in
Section 6 and conclude the paper with a discussion in Section 7.
2 Preliminary notation and problem definition
We begin by providing preliminary notation and formally defining
our problem.
Our input is an unweighted graph 𝐺=(𝑉,𝐸), and we denote
the number of nodes and edges by 𝑛=|𝑉|and𝑚=|𝐸|. Given a
graph𝐺=(𝑉,𝐸)and a set of nodes 𝑈⊆𝑉, we define𝐸(𝑈)⊆𝐸to
be the subset of edges having both endpoints in 𝑈. We denote the
degree of vertex 𝑣asdeg(𝑣). We denote the set of adjacent edges
of vertex𝑣as𝑁(𝑣).
We want to label the set of edges 𝐸as either strong orweak.
To perform the labeling, we use the strong triadic closure (STC)
property [ 24]. We say that the graph is STC satisfied if for any
given triplet of vertices, (𝑥,𝑦,𝑧)the following holds: if (𝑥,𝑦)and
(𝑦,𝑧)are connected and are labeled as strongly connected, then the
edge(𝑥,𝑧)always exists at least as a weak edge.
We call a triplet of vertices (𝑥,𝑦,𝑧)awedge, if(𝑥,𝑦)∈𝐸,(𝑦,𝑧)∈
𝐸, and(𝑥,𝑧)∉𝐸. Awedge graph 𝑍(𝐺)consists of the edges of the
graph𝐺that contribute to at least one wedge as its vertices. If the
two edges𝑒1and𝑒2of𝐺form a wedge, we add an edge between
the two nodes in 𝑍(𝐺)that corresponds to 𝑒1and𝑒2, that is, each
edge of𝑍(𝐺)corresponds to a wedge of 𝐺.
Given a graph 𝐺=(𝑉,𝐸)and a labeling 𝐿of the edges as strong
or weak, we write 𝐸𝑠(𝑈,𝐿)and𝐸𝑤(𝑈,𝐿)to be the set of strong and
weak edges of the graph induced by a set of vertices 𝑈. We also
write𝑚𝑠(𝑈,𝐿)=|𝐸𝑠(𝑈,𝐿)|and𝑚𝑤(𝑈,𝐿)=|𝐸𝑤(𝑈,𝐿)|. Finally, for
a vertex𝑢∈𝑈, we define a strong and weak degree, deg𝑠(𝑢,𝑈,𝐿)
anddeg𝑤(𝑢,𝑈,𝐿)to be the number of strong or weak edges in 𝑈
adjacent to 𝑢. We may omit 𝐿or𝑈from the notation when it is
clear from the context.Given a weight parameter 𝜆where𝜆∈[0,1]and a label assign-
ment𝐿, we define a score
q(𝑈,𝐿;𝜆)=𝑚𝑠(𝑈,𝐿)+𝜆𝑚𝑤(𝑈,𝐿)
|𝑈|.
We may omit 𝐿or𝜆when it is clear from the context.
We consider the following optimization problem.
Problem 1 (stc-den). Given a graph 𝐺=(𝑉,𝐸)and a weight
parameter𝜆, find a subset of vertices 𝑈⊆𝑉and a labeling 𝐿of the
edges as strong or weak such that the STC property is satisfied in
(𝑈,𝐸(𝑈))andq(𝑈,𝐿;𝜆)is maximized.
Note that when 𝜆=1then the labeling does not matter, and
stc-den reduces to dense subgraph discovery, that is, finding 𝑈
with the largest ratio |𝐸(𝑈)|/|𝑈|. On the other hand, if 𝜆=0, then
we only take into account strong edges; we will show in Section 4
that in this case, stc-den is equal to finding a maximum clique.
Note also that the labeling depends on the underlying subgraph
𝑈, that is, we need to find 𝑈and𝐿simultaneously.
3 Related work
The strong triadic closure (STC) property: As an early work
in this line of research, Sintos and Tsaparas [24] considered the
problem of minimizing the number of weak edges (analogously
maximizing the number of strong edges) while labeling the edges
compliant with the STC property. We will refer to this optimization
problem as MinSTC.
Sintos and Tsaparas [24] showed that MinSTC is equivalent to
solving a minimum vertex cover, which we denote by Min-Vertex-
cover, in a wedge graph 𝑍(𝐺). InMin-Vertex-cover, we search
for a minimum number of nodes such that at least one endpoint of
each edge is in the set.
Sintos and Tsaparas [24] proposed the following algorithm for
MinSTC, which we denote by Apr-MinSTC. Given a graph 𝐺they
first construct the wedge graph 𝑍(𝐺)and find its vertex cover. Next,
they label the set of edges of 𝐺that corresponds to the set of vertices
in the vertex cover as weak, and the remaining edges as strong.
Since Min-Vertex-cover isNP-hard, they approximate it with a
maximal matching algorithm [ 6]. The algorithm picks an arbitrary
edge and adds both endpoints of the edge to the cover, and the
edges incident to both endpoints are deleted. It continues until no
edges are left. This algorithm outputs a maximal matching which
is known to yield a 2-approximation since at least one endpoint
should be in the cover.
The problem of finding a labeling of edges that maximizes the
number of strong edges while satisfying the STC property is NP-
hard for general graphs [ 24] and split graphs [ 15]. Nevertheless, it
becomes polynomial-time solvable for proper interval graphs [ 15],
cographs [ 14], and trivially perfect graphs [ 15]. Given communi-
ties, Rozenshtein et al . [21] considered the problem of inferring
strengths while minimizing STC violations with additional con-
nectivity constraints. Oettershagen et al . [17] extended the idea of
inferring tie strength for temporal networks. Matakos and Gionis
[16] considered the problem of strengthening edges to maximize
STC violations, which they consider as opportunities to build new
connections. Adriaens et al . [1] formulated both minimization and
maximization versions of STC problems as linear programs.
3335Dense Subgraph Discovery Meets Strong Triadic Closure KDD ’24, August 25–29, 2024, Barcelona, Spain
The dense subgraph discovery: Finding dense subgraphs is a
core problem in social network analysis. Given a graph, the densest
subgraph problem is defined as finding a subgraph with the high-
est average degree density (twice the number of edges divided by
the number of nodes). Finding the densest subgraph for a single
graph has been extensively studied [ 5,9,13]. Goldberg [9]pro-
posed an exact, polynomial time algorithm that solves a sequence
of min-cut instances. We will refer to this algorithm as Cut. Asahiro
et al. [3] provided a greedy algorithm and Charikar [5]proved that
their greedy algorithm gives a 1/2-approximation, showed how
to implement the algorithm using Fibonacci heaps, and devised a
linear-programming formulation of the problem. The idea of the
greedy algorithm is that at each iteration, a vertex with the mini-
mum degree is removed, and then the densest subgraph among all
the produced subgraphs is returned as the solution. We will refer to
this algorithm as Peel. It has also been extended for multiple graph
snapshots [ 2,11,23]. The problem has been studied in a streaming
setting [ 4]. To the best of our knowledge, this is the first attempt to
consider the notion of density together with the STC property.
In addition to degree density (a.k.a average degree), alternative
types of density measures have also been considered previously
such as triangle density and 𝑘-clique density [ 26]. Triangle density
is defined as the ratio between the number of triangles and the
number of vertices of the subgraph. The definition that will be used
in this paper is the ratio between the number of induced edges and
nodes. Adopting our problem to other density measures is left open
as future work.
4 Computational complexity
In this section, we analyze the computational complexity of the
stc-den problem by showing its NP-hardness when 𝜆<1and
its connection to the Max-Cliqe problem, when 𝜆=0. At the
other extreme, when 𝜆=1,stc-den is equivalent to the problem of
finding the densest subgraph, which can be solved in polynomial
time using the algorithm presented by Goldberg [9].
Proposition 4.1. For𝜆=0,stc-den isNP-hard.
The proof (given in Appendix A.1) also shows that the maxi-
mum clique yields precisely the optimal score while satisfying the
STC property. As a consequence, combining this with the inapprox-
imability results for Max-Cliqe [28] gives the next result (see
Appendix A.1 for the proof).
Proposition 4.2. For𝜆=0,stc-den does not have any poly-
nomial time approximation algorithm with an approximation ratio
better than𝑛1−𝜖for any constant 𝜖>0, unless P=NP.
Note that when 𝜆>0, we can obtain a1
𝜆-approximation by
finding the densest subgraph with nodes 𝑈and using a labeling 𝐿
that labels each edge as weak. Compared to an optimal solution 𝑈∗
with labeling 𝐿∗, we then obtain the score
𝑞(𝑈,𝐿;𝜆)=𝜆|𝐸(𝑈)|
|𝑈|≥𝜆|𝐸(𝑈∗)|
|𝑈∗|=𝜆𝑚𝑠(𝑈∗,𝐿∗)+𝑚𝑤(𝑈∗,𝐿∗)
|𝑈∗|
≥𝜆𝑚𝑠(𝑈∗,𝐿∗)+𝜆𝑚𝑤(𝑈∗,𝐿∗)
|𝑈∗|=𝜆𝑞(𝑈∗,𝐿∗;𝜆).In summary, stc-den is inapproximable when 𝜆=0but solvable
in polynomial time when 𝜆=1. Finally, we state that stc-den is
alsoNP-hard for 0<𝜆<1.
Proposition 4.3. stc-den isNP-hard for 0<𝜆<1.
The proof of Proposition 4.3 is in Appendix A.1.
5 Algorithms
In this section, we present five algorithms to find a good subgraph
for our stc-den problem. First, we propose an algorithm based
on integer linear programming that finds a near-optimal or exact
solution for our problem in Section 5.1. Next, we state a polynomial
time algorithm that solves a linear program in Section 5.2 followed
by three heuristics presented in Sections 5.3 and 5.4.
5.1 Exact solution using integer programming
In this section, we present an integer linear programming (ILP)
based algorithm that can be used to find an exact solution for stc-
den. To solve stc-den we need the following auxiliary problem.
The proofs for this section are given in Appendix A.2.
Problem 2 ( stc-den(𝛼)).Given a graph 𝐺=(𝑉,𝐸), a weight
parameter𝜆, and a number 𝛼, find a subset of vertices 𝑈⊆𝑉and
a labeling𝐿of the edges such that the STC property is satisfied in
(𝑈,𝐸(𝑈))and𝑚𝑠(𝑈,𝐿)+𝜆𝑚𝑤(𝑈,𝐿)−𝛼|𝑈|is maximized.
The following proposition, which is an instance of fractional
programming [ 8], shows the relationship between stc-den(𝛼)and
stc-den.
Proposition 5.1. Let𝑈(𝛼)and𝐿(𝛼)be the subgraph and the
corresponding labeling solving stc-den(𝛼). Similarly, let 𝑈∗with
labeling𝐿∗be the solution for stc-den. Write 𝛼∗=q(𝑈∗,𝐿∗). If𝛼>
𝛼∗, then𝑈(𝛼)=∅. If𝛼<𝛼∗, then𝑈(𝛼)≠∅andq(𝑈(𝛼),𝐿(𝛼))>𝛼.
We can use the proposition to solve stc-den: we find the (almost)
largest𝛼for which stc-den(𝛼)yields a nonempty solution. Then
stc-den(𝛼)for such𝛼yields an (almost) optimal solution.
We can solve stc-den(𝛼)with an integer linear program,
maximize∑︁
𝑥𝑖𝑗+𝜆∑︁
𝑧𝑖𝑗−𝛼∑︁
𝑦𝑖 (1)
subject to 𝑥𝑖𝑗+𝑧𝑖𝑗≤𝑦𝑖𝑖𝑗∈𝐸 (2)
𝑥𝑖𝑗+𝑧𝑖𝑗≤𝑦𝑗𝑖𝑗∈𝐸 (3)
𝑥𝑖𝑗+𝑥𝑗𝑘≤𝑦𝑗(𝑖,𝑗,𝑘)∈𝑍 (4)
𝑥𝑖𝑗,𝑧𝑖𝑗∈{0,1}𝑖𝑗∈𝐸 (5)
𝑦𝑖∈{0,1}𝑖∈𝑉 . (6)
Here,𝐺=(𝑉,𝐸)is the input graph and 𝑍is the set of all wedges
in𝐺.
To see why this program solves stc-den(𝛼), let𝑆⊆𝑉and𝐿
be a solution to our stc-den(𝛼). The indicator variable 𝑦𝑖denotes
whether the node 𝑖∈𝑆or not. The indicator variables 𝑥𝑖𝑗and𝑧𝑖𝑗
denote if the edge (𝑖,𝑗)is strong or not and (𝑖,𝑗)is weak or not,
respectively. Constraints 2-3 guarantee that each edge within 𝑆is
labeled either as strong or weak. Constraint 4 ensures that the STC
constraint is satisfied.
Proposition 5.1 allows us to maximize 𝛼with a binary search.
Here, we set the initial interval (𝐿,𝑈)to𝐿=0and𝑈=𝑛−1
2, and
3336KDD ’24, August 25–29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
keep halving the interval until |𝑈−𝐿|≤𝜖𝐿, where𝜖>0is an
input parameter, and return the solution to stc-den(𝐿). We refer
to this algorithm as STC-ILP. Next, we state that STC-ILP yields an
approximation guarantee of 1/(1+𝜖).
Proposition 5.2. Assume a graph 𝐺=(𝑉,𝐸),𝜆∈[0,1], and
𝜖>0. Let𝛼be the score of the solution returned by STC-ILP and let
𝛼∗be the optimal score of stc-den. Then 𝛼≥𝛼∗/(1+𝜖).
Next, we will show that if 𝜖is small enough, we are guaranteed
to find the exact solution.
Proposition 5.3. Assume a graph 𝐺with𝑛nodes. Assume that
the weight parameter 𝜆is a rational number 𝜆=𝑎
𝑏. Then, if we set
𝜖=2
𝑏𝑛3,STC-ILP returns an exact solution for the stc-den problem
inO(log𝑛+log𝑏)number of iterations.
STC-ILP requiresO(log𝑛−log𝜖)iterations, solving an integer
linear program in each round. Note that solving an ILP is NP-
hard [ 22], and the fastest known algorithm to solve an ILP exactly
runs in logℎO(ℎ)time where ℎis the number of variables [ 19].
In practice, we can solve stc-den(𝛼)for moderately sized graphs
but for larger graphs solving the ILP becomes computationally
infeasible.
This approach is related to two prior works. First, the algorithm
by Goldberg [9]for finding the densest subgraph problem uses a
similar approach, except without the variables 𝑧𝑖𝑗. In such a case,
the program can be solved exactly with a minimum cut. Secondly,
Adriaens et al . [1] use a linear program with similar wedge con-
straints to approximate MinSTC.
5.2 Algorithm based on linear programming
In this section, we present an algorithm, named STC-LP, based on
a linear program obtained by relaxing the integrality requirements
of the integer linear program given in the previous section. More
specifically, we first find a fractional solution by solving a linear
program (LP) and then derive a good subgraph via a rounding algo-
rithm. Note that solving linear programs can be done in polynomial
time [ 12,27], and solvers are efficient in practice. The proofs for
this section are given in Appendix A.3.
Consider a relaxed version of the ILP, where we replace the
constraints in Eqs. 5–6 with 𝑥𝑖𝑗,𝑧𝑖𝑗∈[0,1]and𝑦𝑖∈[0,1]. We will
refer to this optimization problem as stc-relax(𝛼).
Note that we used stc-den(𝛼)combined with the binary search
to solve stc-den. We can define a relaxed version of stc-den which
then can be analogously solved with stc-relax(𝛼).
Problem 3 (stc-relax). Given a graph 𝐺=(𝑉,𝐸), a weight
parameter𝜆, find a nonnegative set of variables 𝑥𝑒,𝑦𝑖,𝑧𝑒, where
𝑒∈𝐸and𝑖∈𝑉maximizing
𝑟(𝑥,𝑦,𝑧)=Í𝑥𝑒+𝜆Í𝑧𝑒Í𝑦𝑖such that Eqs. 2–4 hold .
stc-relax is a relaxed version of stc-den: if we were to re-
quire that the variables in stc-relax are binary numbers, then the
problems become equivalent. The next proposition is an analog to
Proposition 5.1.
Proposition 5.4. Let(𝑥∗,𝑦∗,𝑧∗)be a solution to stc-relax. Write
𝛼∗=𝑟(𝑥∗,𝑦∗,𝑧∗). Similarly, let(𝑥(𝛼),𝑦(𝛼),𝑧(𝛼))be a solutionstc-relax(𝛼). If𝛼>𝛼∗, thenÍ𝑦𝑖(𝛼)=0. On the other hand,
if𝛼<𝛼∗, thenÍ𝑦𝑖(𝛼)>0and𝑟(𝑥(𝛼),𝑦(𝛼),𝑧(𝛼))>𝛼.
Proposition 5.4 allows us to solve stc-relax with stc-relax(𝛼)
and a binary search, similar to STC-ILP. However, we can solve
stc-relax directly with a single linear program, that is,
maximize∑︁
𝑥𝑖𝑗+𝜆∑︁
𝑧𝑖𝑗
subject to 𝑥𝑖𝑗+𝑧𝑖𝑗≤𝑦𝑖𝑖𝑗∈𝐸
𝑥𝑖𝑗+𝑧𝑖𝑗≤𝑦𝑗𝑖𝑗∈𝐸
∑︁
𝑦𝑖=1
𝑥𝑖𝑗+𝑥𝑗𝑘≤𝑦𝑗(𝑖,𝑗,𝑘)∈𝑍
𝑥𝑖𝑗,𝑧𝑖𝑗≥0 𝑖𝑗∈𝐸
𝑦𝑖≥0 𝑖∈𝑉
Proposition 5.5. The LP given above solves stc-relax.
Our LP is related to the LP proposed by Charikar [5], which is
used to solve the densest subgraph problem exactly. We extend
Charikar’s LP by adding strong edges and additional STC con-
straints. Another related work is the LP proposed by Adriaens et al .
[1]which provides a 2-approximation for MinSTC using similar
wedge constraints.
Rounding phase: Next, we describe the heuristic used to obtain
the subgraph and the labeling from the variables. Let ( 𝑥∗,𝑦∗,𝑧∗)
be the solution to stc-relax. First we define a collection of sets
S={𝑆1,𝑆2,...,𝑆𝑛}where𝑆𝑗={𝑖:𝑦∗
𝑖≥𝑦∗
𝑗}. Then we enumerate
over the collection of subgraphs induced by S.
For each𝑆𝑗, we initially set all the edges as weak. Then we
enumerate over each edge 𝑒∈𝐸(𝑆𝑗)starting from the largest 𝑧∗𝑒.
Each edge𝑒is labeled as strong if the STC property is not violated.
This means that we check if there is any edge adjacent to any
of the endpoints of 𝑒which is already labeled as strong and still
creates a wedge with 𝑒. We continue the same process for all the
edges𝑒∈𝐸(𝑆𝑗)in the descending order of its 𝑧∗𝑒value. Finally, out
of all the subgraphs we pick the subgraph and the labeling that
maximizes our score.
Constructing a labeling for a single 𝑆𝑗amounts to enumerating
over the wedges in O(𝑛𝑚)time, leading to a total time of O 𝑛2𝑚
for the rounding.
5.3 Label, find the densest subgraph, and relabel
Next, we explain two algorithms that combine the existing methods
for finding the densest subgraph and finding the STC-compliant
labeling in an entire graph.
The approach is as follows. First, we label the edges of the entire
graph using Apr-MinSTC (see Section 3). Then we construct a
weighted version of the graph assigning a weight of 1for strong
edges and a weight of 𝜆for weak edges. Next, we search for the
densest subgraph using Cut orPeel (see Section 3) in the new
weighted graph. Finally, we relabel only the subgraph induced by
the returned solution. Relabeling is used to improve the score since
some of the edges might be marked as weak since they contributed
to certain wedges in the original graph, nevertheless, some edges no
longer contribute to all of those wedges. The pseudo-code for this
3337Dense Subgraph Discovery Meets Strong Triadic Closure KDD ’24, August 25–29, 2024, Barcelona, Spain
Algorithm 1: STC-Cut(𝐺,𝜆)and STC-Peel(𝐺,𝜆), both
find a subgraph 𝑈and a labeling 𝐿with good q(𝑈,𝐿;𝜆).
1𝐿←Apr-MinSTC(𝐺);
2𝐻←the weighted graph by setting 1to strong edges and 𝜆
to weak edges of 𝐺;
3𝑈←Cut(𝐻)[9] or Peel(𝐻)[5];
4𝐿′←Apr-MinSTC(𝐺(𝑈));
5return subgraph𝑈and its labeling 𝐿′;
method is given in Algorithm 1. We call the algorithm as STC-Cut
orSTC-Peel based on the subroutine used in Line 3 of Algorithm 1.
Next, we present the computational complexities of the STC-Peel
andSTC-Cut algorithms.
Proposition 5.6. Assume a graph 𝐺with𝑛nodes and𝑚edges.
Assume that the wedge graph 𝑍(𝐺)contains𝑛′nodes and𝑚′edges.
Then the running time of STC-Peel is in
O ∑︁
𝑣∈𝑉deg(𝑣)2+(𝑚+𝑛log𝑛)+(𝑚′+𝑛′)!
⊆O(𝑛𝑚).
Proof. The number of wedges in 𝐺, and hence the number
of edges in 𝑍(𝐺)is inO Í
𝑣∈𝑉deg(𝑣)2⊆O(𝑛Í
𝑣∈𝑉deg(𝑣))⊆
O(𝑛𝑚). The number of vertices, 𝑛′, in the wedge graph 𝑍(𝐺)is in
O(𝑚).Apr-MinSTC estimates the minimum vertex cover problem
with a maximum matching for 𝑍(𝐺)and the subgraph, which has a
running time ofO(𝑛′+𝑚′)when the adjacency list representation
is used for the graph [ 7]. We can execute Peel inO(𝑚+𝑛log𝑛)
time. The claim follows. □
Proposition 5.7. Assume a graph 𝐺with𝑛nodes and𝑚edges.
Assume that the wedge graph 𝑍(𝐺)contains𝑛′nodes and𝑚′edges.
Then the running time of STC-Cut is in
O 𝑚𝑛+𝑛(𝑛+𝑚)log𝑛+(𝑚′+𝑛′)⊆O(𝑚𝑛log𝑛).
Proof. The only change compared to Proposition 5.6 is that we
are using an exact algorithm instead of an approximation algorithm
for finding the densest subgraph. The exact algorithm for an edge-
weighted graph takes O(𝑀(𝑛,𝑛+𝑚)log𝑛)time, and𝑀(𝑛,𝑛+𝑚)
is the time taken to solve the min-cut problem for a graph with 𝑛
number of nodes and (𝑛+𝑚)number of edges. It takes O(𝑛(𝑛+𝑚))
to find the minimum cut [18]. The claim follows. □
5.4 Peeling with continuous relabeling
TheSTC-Peel algorithm, given in the previous section, first finds
a labeling and then uses Peel that constructs a set of subgraphs
among which the subgraph with the highest score is selected. Dur-
ing this search, the labeling remains fixed. Our final algorithm
modifies this approach by relabeling the graph as we are construct-
ing the subgraphs.
Our approach is as follows. We start from the whole graph 𝐺
and label the edges as either strong or weak using Apr-MinSTC.
Given a labeling 𝐿and a subgraph 𝑈, let the weighted degree for
a vertex deg𝜆(𝑣,𝑈,𝐿,𝜆)be defined as the sum of strong edges and
weak edges in 𝑈incident to𝑣weighted by 𝜆, i.e., deg𝜆(𝑣,𝑈,𝐿)=Algorithm 2: Grd-Naive(𝐺,𝜆), finds a subgraph 𝑈and a
labeling𝐿with good q(𝑈,𝐿;𝜆)
1𝑈←𝑉;
2while there are nodes do
3𝐿←Apr-MinSTC(𝐺(𝑈));
4𝑢←arg min
𝑣∈𝑈deg𝜆(𝑣,𝑈,𝐿,𝜆);
5𝑈←𝑈\{𝑢};
6return best tested𝑈and its labeling 𝐿;
deg𝑠(𝑣,𝑈,𝐿)+𝜆deg𝑤(𝑣,𝑈,𝐿)We drop𝐿,𝑈or𝜆when it is clear
from the context. At each iteration, we delete the node that has the
minimum weighted degree deg𝜆(𝑣). After removing each vertex we
relabel the remaining set of edges. Finally, we choose the subgraph
𝑈which corresponds to the maximum score q(𝑈,𝜆)out of all the
iterations. The naive version for this method is given in Algorithm 2.
Next, we explain several tricks to speed up the naive implemen-
tation of Algorithm 2. We focus on updating the wedge graph, mod-
ifying the minimum vertex cover, and updating individual scores
of each vertex without computing them from scratch.
Maintain wedge graph: Note that on Line 3 of Algorithm 2, we
need to repeatedly construct a wedge graph to solve MinSTC. We
can avoid this by maintaining the existing wedge graph as vertices
are deleted.
When a node is deleted we need to consider only deleting re-
spective edges in the wedge graph since new wedges cannot be
introduced. Note that an edge in the original graph 𝐺corresponds
to a node in the wedge graph 𝑍(𝐺)and edges in 𝑍(𝐺)represent
wedges in𝐺. Next, we state how to maintain 𝑍(𝐺)when a vertex
is deleted in Proposition 5.8.
Proposition 5.8. Let𝐺=(𝑉,𝐸)be a graph. Let 𝑣be a vertex
in𝐺. Define𝐺′=𝐺(𝑉\{𝑣},𝐸\𝑁(𝑣)), where𝑁(𝑣)is the set of
adjacent edges of vertex 𝑣in𝐺. Then, a new wedge graph 𝑍(𝐺′)is
formed by deleting the vertices in 𝑍(𝐺)corresponding to 𝑁(𝑣).
We omit the straightforward proof.
Dynamic vertex cover using maximal matching: Next, we
consider updating the vertex cover after a vertex deletion.
Recall that we use maximum matching to approximate the vertex
cover in Apr-MinSTC. Given a maximal matching of the current
graph, Ivković and Lloyd [10]presented a simple algorithm to main-
tain the cover when an edge is deleted or inserted. Here we modify
their algorithm slightly to adapt to a node deletion from 𝐺. Let us
consider the case where the vertex 𝑣is deleted from the original
graph𝐺. Note that𝑁(𝑣)is a set of edges in 𝐺which corresponds
to a subset of nodes in 𝑍(𝐺). According to Proposition 5.8, the set
of nodes corresponding to 𝑁(𝑣)should be deleted from the wedge
graph𝑍(𝐺)to compensate for the deleted vertex. We assume that
a maximal matching 𝑀of𝑍(𝐺)is given.
The algorithm is as follows. We iterate over the elements in 𝑁(𝑣)
and pick a node 𝑎∈𝑁(𝑣)in𝑍(𝐺). We then test whether there is
an edge(𝑎,𝑏)in𝑀for some𝑏. There can be only one, and if there
is, we delete it. Upon such deletion, 𝑀may no longer be maximal
since𝑏may have a single adjacent edge that can be added. We
search for such an edge and add it if one is found.
3338KDD ’24, August 25–29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
Algorithm 3: Dynamic-Vertex-cover (𝑀,𝑣), maintains
a vertex cover (a maximal matching 𝑀) when a node 𝑣is
deleted
1foreach𝑎∈𝑁(𝑣)do
2 ifthere is𝑏such that(𝑎,𝑏)∈𝑀then
3 delete(𝑎,𝑏)from𝑀;
4 if𝑏∉𝑁(𝑣)and there is𝑡∉𝑁(𝑣)such that𝑡is not
an endpoint of any edge in 𝑀and(𝑏,𝑡)∈𝐸(𝑍(𝐺))
then
5 add(𝑏,𝑡)to𝑀;
6return𝑀;
The pseudocode is given in Algorithm 3. Algorithm 3 still pro-
duces a maximal matching; thus a 2-approximation for Min-Vertex-
cover is guaranteed.
Speeding the vertex selection: We can speed up finding the
next vertex by maintaining deg𝜆(𝑣,𝜆)in a priority queue. Once a
vertex is deleted, we need to update the degree of its neighboring
nodes. Also, we may need to update the weighted degree of the
affected vertices if the vertex cover of 𝑍(𝐺)changes. However, the
number of changed edges in the vertex cover is constant. The final
version of the algorithm is presented in Algorithm 4.
Algorithm 4: Greedy(𝐺,𝜆), finds a subgraph 𝑈and a la-
beling𝐿with good q(𝑈,𝐿;𝜆)
1𝐿←Apr-MinSTC(𝐺);
2𝑃←priority queue where each node is ranked by
deg𝜆(𝑣,𝐿);
3𝑈←𝑉;
4while there are nodes do
5𝑢←arg min
𝑣∈𝑈deg𝜆(𝑣,𝑈,𝐿);
6𝑈←𝑈\{𝑢};
7 Update the wedge graph 𝑍((𝑈,𝐸(𝑈)));
8 Update labeling 𝐿using Algorithm 3;
9 Update𝑃;
10return best tested𝑈and its labeling 𝐿;
Next, we state the computational complexity of Greedy.
Proposition 5.9. Assume a graph 𝐺with𝑛nodes and𝑚edges.
Assume that the wedge graph 𝑍(𝐺)contains𝑛′nodes and𝑚′edges.
Then the running time of Greedy is in
O 𝑚𝑛+(𝑛′+𝑚′)+𝑚log𝑛+𝑛𝑚⊆O(𝑛𝑚).
Proof. Let𝐺𝑖be the graph at 𝑖th iteration. Consider deleting
vertex𝑢from𝐺𝑖. Upon deletion, we need to update the priorities
of the affected nodes in the queue.
When𝑢is deleted from 𝐺𝑖, we need to delete the set of nodes
in𝑍(𝐺)which corresponds to the adjacent edges of 𝑢. For each
deleted vertex in 𝑍(𝐺), there can be at most one adjacent edge that
belongs to the existing matching set. Therefore, to compensate forthe edge that is removed from the maximal matching set, we need
to add at most one edge to the matching. The two endpoints of the
newly added edge correspond to two edges in 𝐺𝑖+1. Therefore, the
total number of vertices that require updating priorities is at most
4. Moreover, deleting one edge from the existing matching set will
affect the priorities of at most 2vertices.
In summary,O(deg𝑢)nodes need to be updated when we delete
𝑢. Consequently, the total update time of 𝑃is inO(𝑚log𝑛). More-
over, the total update time for 𝑍(𝐺)is inO(𝑛′+𝑚′). Updating
𝑀requires finding a new edge which may cost O(𝑛)time, conse-
quently, updating 𝑀requiresO(𝑛𝑚)total time. Finally, the update
time for(𝑈,𝐸(𝑈))is inO(𝑚).
Initially, constructing 𝑍(𝐺)requiresO Í
𝑣∈𝑉deg(𝑣)2⊆O(𝑛𝑚)
time and VC-Mat requiresO(𝑛′+𝑚′)⊆O(𝑛𝑚)time.
Combining these times proves the claim. □
6 Experimental evaluation
Next, we evaluate our algorithms experimentally. We first generate
a synthetic dataset with a dense subgraph component and test
how well our algorithms perform. Next, we study the performance
of the algorithms on real-world networks. We implemented the
algorithms in Python1and performed the experiments using a
2.4GHz Intel Core i5 processor and 16GB RAM. In our experimental
evaluation, we used Gurobi solver in Python to solve the ILPs and
LPs associated with STC-ILP andSTC-LP respectively.
Synthetic dataset: We will now explain how the synthetic
dataset was generated. Given a vertex set 𝑉of size 230, we split 𝑉
into dense and sparse components 𝐷and𝑆. Here, we randomly se-
lected𝐷to have 38 nodes and 𝑆to have 192 nodes. We sampled the
edges using a stochastic block model, with the edge probabilities
being𝑝𝑑=1,𝑝𝑠=0.3, and𝑝𝑐=0.05for dense component, sparse
component, and cross edges, respectively. The resulting graph had
5 197 edges, and the wedge graph had 5 197 nodes and 179 100 edges.
The density of 𝐷was|𝐸(𝐷)|/|𝐷|=18.5.
Results using synthetic dataset: We report our results in
Table 1. First, we see that all our algorithms find the ground truth
by achieving a score of 18.5which is the density of our planted
clique of size 38for example when 𝜆=0.4and𝜆=0.2. Note that
STC-ILP produced the results within an hour only for the 𝜆=0.2
case. Since STC-ILP solves an ILP in each round, it was inefficient
to run for the other 𝜆values and we stopped the execution after
one hour.
As𝜆increases, our algorithms tend to find a score greater than
18.5by deviating away from the planted clique. We also see that
STC-LP which solves a linear program runs significantly slower
than Greedy, STC-Peel, and STC-Cut algorithms.
Next, we study how the scores and the percentage of weak edges
vary as a function of 𝜆as shown in Figure 2. We can observe that
both STC-Cut andSTC-Peel produce equal scores whereas STC-
Peel andSTC-LP slightly underperform at 𝜆=0.6and𝜆=0.5
respectively as shown in Fig. 2a. Moreover, the STC-LP slightly out-
performs other algorithms when 𝜆≥0.7. In terms of percentages
of weak edges, all three algorithms produced the same decreasing
trends according to Fig. 2b. There are no weak edges in the sub-
graphs produced by any of the algorithms when 𝜆≤0.4since scores
1The source code is available at https://version.helsinki.fi/dacs/.
3339Dense Subgraph Discovery Meets Strong Triadic Closure KDD ’24, August 25–29, 2024, Barcelona, Spain
Table 1: Results of the experiments for synthetic and real datasets. Here, 𝜆is the weight parameter, columns CT,PL,GR,LP,
andIPrepresent STC-Cut, STC-Peel, Greedy, STC-LP, and STC-ILP, respectively, columns in qare the discovered scores,
columns in|𝐸𝑠|%give the percentages of strong edges in discovered subgraph, and columns in time give the computational time.
q |𝐸𝑠|% time
Dataset 𝜆 CT PL GR LP IP CT PL GR LP IP CT PL GR LP IP
Synthetic 0.8 21.28 21.28 21.27 21.68 9 .45 15.96 9.43 17.2 11 .72s 6.69s 6.94s 29.58s
0.6 16.57 16.57 18.5 17.37 9 .45 15.86 100 17 .07 11 .29s 6.4s 7.11s 36.9s
0.4 18.5 18.5 18.5 18.5 100 100 100 100 9s 4.73s 7.85s 16.97s
0.2 18.5 18.5 18.5 18.5 18.5 100 100 100 100 100 7 .02s 7.02s 7.98s 12.92s 9m5s
Cora 0.8 2.58 2.33 2.3 2.65 2.69 32.51 10.03 5.16 22.16 28.57 18.14s 1.1s 1m1s 2.41s 43.26s
0.6 1.99 1.84 2.01 2.14 2.29 74.15 7.35 81.82 21.57 37.5 17.51s 0.92s 1m1s 2.8s 11m1s
0.4 2 1 .78 2 1 .62 2.09 100 100 100 39 .13 69.57 14.68s 0.94s 46.73s 2.98s 4m23s
0.2 2 1 .78 2 1 .32 2.02 100 100 100 66 .67 95.24 15.48s 0.88s 42.34s 2.79s 4m17s
Citeseer 0.8 4 3 .99 3.87 4.12 4.2 6.54 17.95 8.89 19.44 27.78 13.17s 0.51s 1m25s 1.27s 18.32s
0.6 3.11 3.08 2.99 3.35 3.5 6.93 18.64 5.45 20.37 28.16 15.44s 0.52s 1m18s 1.28s 17.54s
0.4 2.22 2.16 2.5 2.65 2.82 16.07 24.49 100 23 .3 32.94 14.55s 0.56s 56.86s 1.3s 38.62s
0.2 1.5 1.5 2.5 1.89 2.5 100 100 100 35 .29 100 15 .05s 0.68s 50.06s 1.29s 1m6s
PGP 0.8 15.96 15.59 15.4 16.48 16.86 18.41 15.24 15.68 32.05 42.19 1m33s 5.95s 31m49s 22.39s 6m55s
0.6 12.51 12.07 12 13 .97 14.66 17.75 24.68 100 33 .22 42.19 1m38s 6.67s 31m52s 20.52s 8m40s
0.4 10.5 10.5 11 11 .44 12.56 100 100 100 34 .94 48.19 1m38s 6.42s 31m4s 20.33s 9m24s
0.2 10.5 10.5 11 10 .46 12 100 100 100 67 .29 100 1m40s 6.28s 24m20s 27.82s 9m3s
Email-EU 0.8 22.17 22.17 22.12 22.44 2 .14 2.17 1.22 7.09 52 .5s 22.21s 2m29s 3m37s
0.6 16.78 16.76 16.68 17.3 2 .14 2.09 1.26 6.88 54 .26s 21.13s 2m33s 4m26s
0.4 11.4 11.38 11.24 12.2 2 .35 2.28 1.44 7.12 55s 21.76s 2m25s 5m16s
0.2 6.02 5.97 8 7 .16 3 .06 2.88 100 7 .52 57 .63s 23.54s 2m21s 4m57s
Facebook 0.8 62.26 63.33 62.02 61.48 5 .71 6.19 4.16 12.68 1m22s 37.31s 5m29s 7m27s
0.6 47.79 47.94 47.31 49.84 5 .71 6.19 4.16 12.49 1m23s 36.05s 5m39s 6m34s
0.4 33.54 33.38 33.5 36.3 6 .26 5.92 100 12 .75 1m21s 35.21s 5m32s 9m30s
0.2 19.27 19.36 33 23 .18 6 .76 6.92 100 13 .46 1m22s 34.21s 5m22s 9m27s
LastFM 0.8 11.97 12 11 .94 12.28 4 .72 5.58 3.77 15.19 1m33s 11.99s 24m54s 1m1s
0.6 9.16 9.19 8.98 9.67 4 .72 5.34 5.29 13.53 1m33s 12.09s 24m45s 58.42s
0.4 6.47 6.43 6.5 7.09 6 .21 5.76 100 14 .3 1m32s 11.38s 23m10s 1m3s
0.2 3.46 3.52 6.5 4.71 4 .38 4.83 100 15 .98 1m32s 11.8s 17m28s 1m1s
Table 2: Characteristics of real-world datasets. Here, |𝑉|and
|𝐸|give the number of vertices and edges, |𝑉(𝑍)|and|𝐸(𝑍)|
are the number of vertices and edges in the wedge graph,
𝑑=|𝐸(𝑈)|/|𝑈|gives the density of the densest subgraph, and
𝑑𝑐is the density induced by Max-Cliqe.
Dataset|𝑉| |𝐸| |𝑉(𝑍)| |𝐸(𝑍))|𝑑 𝑑𝑐
Cora 2 708 5 278 5 151 47 411 3 .14 2
Citeseer 3 264 4 536 4 192 23 380 4 .91 2.5
PGP 10 680 24 316 23 568 270 433 19 .07 12
Email-EU 986 16 064 16 063 866 833 27 .57 8.5
Facebook 747 30 025 30 022 1 177 951 76 .73 33.5
LastFM 7 624 27 806 27 775 557 781 14 .79 7
are only contributed by the planted clique. Recall the connection
to the maximum clique problem for 𝜆=0from Proposition 4.1.
Finally, we study the running time as a function of the number
of edges|𝐸|and the number of wedges |𝑉(𝑍)|in Figure 3. We00.20.40.60.81203040
𝜆q(·;𝜆)Greedy
STC-Cut
STC-Peel
STC-LP
(
a)00.20.40.60.81020406080100
𝜆|𝐸𝑠|%
(
b)
Figure 2: Scores and percentages of strong edges as a function
of𝜆forSynthetic dataset.
randomly generated 6datasets each with 5 000 nodes. The number
of edges of the datasets uniformly ranges from 1×104to1.1×105.
We see that STC-Cut andSTC-Peel are the fastest while STC-LP
is the slowest.
3340KDD ’24, August 25–29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
0.20.40.60.81
·10501
0002 0003
0004 000
|𝐸|timeGreedy
STC-Cut
STC-Peel
STC-LP
(
a)2 4
·10601 0002 0003
0004 000
|𝑉(𝑍)|time
(
b)
Figure 3: Time in seconds as a function of the number of
edges|𝐸|and the number of wedges |𝑉(𝑍)|.
Real-world datasets: We test our algorithms in publicly avail-
able, real-world datasets: Cora [20]2and Cite-seer [20]2datasets
are citation networks. Email-EU is a collaboration network be-
tween researchers.3Facebook is extracted from a friendship circle of
Facebook.4LastFM is a social network of LastFM users.4PGP is an
interaction network of the users of the Pretty Good Privacy (PGP)
algorithm.5The details of the datasets are shown in Table 2.
Results using real-world datasets: We present the results ob-
tained using our algorithms in Table 1. We compare our algorithms
in terms of scores, running time, and the percentage of the strong
edges within subgraphs they returned for a set of 𝜆values. Since
STC-ILP invokes a sequence of integer programs, the algorithm
does not scale for large datasets. We stopped the experiments that
took over one hour. We always set 𝜖=0.01when testing each
dataset with STC-ILP.
First, let us compare the scores across the algorithms. Our first
observation is that STC-ILP always yields the highest score with
the tested datasets while all other algorithms perform similarly in
terms of scores: in most cases, they produce approximately equal
scores. When STC-ILP is not usable, STC-LP has produced the max-
imum score except for 3outlier cases where Greedy andSTC-Peel
algorithms obtained the maximum score 2times and 1time respec-
tively. Nevertheless, for high 𝜆s all of them produce less deviated
scores when compared to lower 𝜆s. As expected, qincreases as 𝜆
increases for all 4algorithms.
Next, let us look at column |𝐸𝑠|%which gives the percentages of
strong edges in the returned subgraph. Generally speaking, |𝐸𝑠|%
monotonically decreases as 𝜆increases except for a few outlier
cases. This is because when we assign a higher weight 𝜆, it becomes
more beneficial to include more weak edges.
Computation times are given in the 𝑡𝑖𝑚𝑒 columns of Table 1.
Greedy, STC-LP, and STC-Cut run significantly slower than STC-
Peel. If we compare Greedy andSTC-Cut, for all the tested cases
STC-Cut runs faster despite having to solve a sequence of minimum
cuts. This is due to the implementation differences as STC-Cut uses
a fast native library to compute the minimum cuts.
Despite STC-ILP not being scalable for larger datasets, it runs
faster than Greedy except for four cases with the tested datasets.
ForCora, Citeseer, PGP, and LastFM datasets, STC-LP runs faster
2https://networkrepository.com
3https://toreopsahl.com/datasets/
4http://snap.stanford.edu
5http://konect.cc/networks/arenas-pgp/than all other algorithms except STC-Peel. However, for the two
other remaining datasets, STC-LP is the slowest in comparison to
the other three algorithms. We see that the running times are still
reasonable in practice for the tested datasets; for example, we were
able to compute the subgraph for the Facebook dataset, with over
30 000 edges and 1 000 000 wedges, in under ten minutes.
Table 3: Co-authorship case-study for DBLP dataset with
weighted variant of STC-ILP. We set 𝜆=0.8and𝜖=0.01. For
each subgraph, we state the scores within brackets.
S1 P. S.Yu, C. C.Aggarwal, J.Han, W.Fan, J.Gao, X.Kong (6.00)
S2 C. H. Q.Ding, F.Nie, H.Huang, D.Luo (4.78)
S3 S.Yan, J.Yan, N.Liu, Z.Chen, H.Xiong, Q.Yang, Y.Fu, Y.Ge,
H.Zhu, E.Chen, C.Liu, Q.Liu, B.Zhang (4.70)
S4 S.Lin, H.Hsieh, C.Li (4.23)
S5 C.Faloutsos, J.Sun, S.Papadimitriou, H.Tong, L.Akoglu,
T.Eliassi-Rad, B.Gallagher (4.09)
S6 Y.Liu, M.Zhang, S.Ma, L.Ru (3.84)
S7 H.Liu, J.Tang, X.Hu, H.Gao (3.80)
S8 D.Phung, S.Venkatesh, S. KumarGupta, S.Rana, S.Tsumoto,
S.Hirano (3.76)
S9 C.Böhm, I. S.Dhillon, C.Plant, C.Hsieh, P.Ravikumar (3.54)
S10 S.Günnemann, H.Kremer, T.Seidl, I.Assent, E.Müller,
R.Krieger (3.46)
Case study: Next, we conducted a case study for DBLP [25]6
which contains co-authorship connections from top venues in data
mining and machine learning (SDM, NIPS, ICDM, KDD, ECMLP-
KDD, and WWW). Each node represents an author and each edge
corresponds to a collaboration between two authors. We removed
the author pairs who have less than 3collaborations. The size
of the dataset after prepossessing is 𝑛=4 592,𝑚=5 566, and
|𝑍(𝐺)|=26 073. To compute a marginal weight that corresponds to
an author pair, we assign a weight for each paper as one divided by
the number of authors. We then weigh each edge (author-pair) by
summing up the weights of all respective collaborations. Then we
ran a weighted version of STC-ILP whose objective is to maximize
the edge-weighted score,Í
strong𝑒∈𝐸(𝑈)𝑤(𝑒)+𝜆Í
weak𝑒∈𝐸(𝑈)𝑤(𝑒)
|𝑈|.
We found top-10 non-overlapping subgraphs iteratively by deleting
the returned subgraph in each iteration and then considering the
remaining graph to find the next subgraph. We set 𝜆=0.8and
𝜖=0.01. The list of author subgraphs is shown in Table 3. We
see that the variant of STC-ILP discovered subgraphs of prolific
authors.
7 Concluding remarks
We introduced a novel dense subgraph discovery problem that
takes into account the strength of ties within the subgraph. Here
we label each edge either as strong or weak based on the strong
triadic closure principle (STC). The STC property requires that
if one node strongly connects with two other nodes, then those
6https://www.aminer.org/citation
3341Dense Subgraph Discovery Meets Strong Triadic Closure KDD ’24, August 25–29, 2024, Barcelona, Spain
two nodes should at least have a weak connection between them.
Our goal was to maximize a density-like measure defined as the
sum of the number of strong edges and the number of weak edges
weighted by a weight parameter, divided by the number of nodes
within the subgraph. We showed that our optimization problem is
NP-hard, and connects the two well-known problems of finding
dense subgraphs and maximum cliques. To solve the problem, we
presented an exact algorithm based on integer linear programming.
In addition, we presented a polynomial-time algorithm based on
linear programming, a greedy heuristic algorithm, and two other
straightforward algorithms based on the algorithms for the densest
subgraph discovery.
The experiments with synthetic data showed that our approach
recovers the latent dense components. The experiments on real-
world networks confirmed that our proposed algorithms discovered
the subgraphs reasonably fast in practice. Finally, we presented a
case study where our algorithm produced interpretable results
suggesting the practical usefulness of our problem setting and
algorithms.
The idea of combining the dense subgraph problem with the
STC property opens up several lines of work. For example, instead
of using the ratio between the number of edges and the number
of nodes as the density measure, we can incorporate other density
measures.
Acknowledgments
This research is supported by the Academy of Finland project MAL-
SOME (343045).
References
[1]Florian Adriaens, Tijl De Bie, Aristides Gionis, Jefrey Lijffijt, Antonis Matakos,
and Polina Rozenshtein. 2020. Relaxing the strong triadic closure problem for edge
strength inference. Data Mining and Knowledge Discovery 34 (2020), 611–651.
[2]Chamalee Wickrama Arachchi and Nikolaj Tatti. 2023. Jaccard-constrained dense
subgraph discovery. arXiv preprint arXiv:2308.15936 (2023).
[3]Yuichi Asahiro, Kazuo Iwama, Hisao Tamaki, and Takeshi Tokuyama. 2000. Greed-
ily finding a dense subgraph. Journal of Algorithms 34, 2 (2000), 203–221.
[4]Sayan Bhattacharya, Monika Henzinger, Danupon Nanongkai, and Charalampos
Tsourakakis. 2015. Space-and time-efficient algorithm for maintaining dense
subgraphs on one-pass dynamic streams. In Proceedings of the forty-seventh
annual ACM symposium on Theory of computing. 173–182.
[5]Moses Charikar. 2000. Greedy approximation algorithms for finding dense
components in a graph. In APPROX. 84–95.
[6]Kenneth L Clarkson. 1983. A modification of the greedy algorithm for vertex
cover. Inform. Process. Lett. 16, 1 (1983), 23–25.
[7]Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. 2022.
Introduction to algorithms. MIT press.
[8]Werner Dinkelbach. 1967. On nonlinear fractional programming. Management
science 13, 7 (1967), 492–498.
[9] Andrew V Goldberg. 1984. Finding a maximum density subgraph. (1984).
[10] Zoran Ivković and Errol L Lloyd. 1993. Fully dynamic maintenance of vertex
cover. In International Workshop on Graph-Theoretic Concepts in Computer Science.
Springer, 99–111.
[11] Vinay Jethava and Niko Beerenwinkel. 2015. Finding dense subgraphs in rela-
tional graphs. In Joint European Conference on Machine Learning and Knowledge
Discovery in Databases. 641–654.
[12] Narendra Karmarkar. 1984. A new polynomial-time algorithm for linear pro-
gramming. In Proceedings of the sixteenth annual ACM symposium on Theory of
computing. 302–311.
[13] Samir Khuller and Barna Saha. 2009. On finding dense subgraphs. In International
colloquium on automata, languages, and programming. Springer, 597–608.
[14] Athanasios L Konstantinidis, Stavros D Nikolopoulos, and Charis Papadopoulos.
2018. Strong triadic closure in cographs and graphs of low maximum degree.
Theoretical Computer Science 740 (2018), 76–84.[15] Athanasios L Konstantinidis and Charis Papadopoulos. 2020. Maximizing the
strong triadic closure in split graphs and proper interval graphs. Discrete Applied
Mathematics 285 (2020), 79–95.
[16] Antonis Matakos and Aristides Gionis. 2022. Strengthening ties towards a highly-
connected world. Data mining and knowledge discovery 36, 1 (2022), 448–476.
[17] Lutz Oettershagen, Athanasios L Konstantinidis, and Giuseppe F Italiano. 2022.
Inferring Tie Strength in Temporal Networks. In Joint European Conference on
Machine Learning and Knowledge Discovery in Databases. 69–85.
[18] James B Orlin. 2013. Max flows in O (nm) time, or better. In Proceedings of the
forty-fifth annual ACM symposium on Theory of computing. 765–774.
[19] Victor Reis and Thomas Rothvoss. 2023. The subspace flatness conjecture and
faster integer programming. arXiv preprint arXiv:2303.14605 (2023).
[20] Ryan A. Rossi and Nesreen K. Ahmed. 2015. The Network Data Reposi-
tory with Interactive Graph Analytics and Visualization. In AAAI. https:
//networkrepository.com
[21] Polina Rozenshtein, Nikolaj Tatti, and Aristides Gionis. 2017. Inferring the
strength of social ties: a community-driven approach. In Proceedings of the 23rd
ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.
1017–1025.
[22] Alexander Schrijver. 1998. Theory of Linear Integer Programming. John Wiley &
Sons.
[23] Konstantinos Semertzidis, Evaggelia Pitoura, Evimaria Terzi, and Panayiotis
Tsaparas. 2019. Finding lasting dense subgraphs. Data mining and knowledge
discovery 33, 5 (2019), 1417–1445.
[24] Stavros Sintos and Panayiotis Tsaparas. 2014. Using strong triadic closure to
characterize ties in social networks. In Proceedings of the 20th ACM SIGKDD
international conference on Knowledge discovery and data mining. 1466–1475.
[25] Jie Tang, Jing Zhang, Limin Yao, Juanzi Li, Li Zhang, and Zhong Su. 2008. Arnet-
miner: extraction and mining of academic social networks. In KDD. 990–998.
[26] Charalampos Tsourakakis. 2015. The k-clique densest subgraph problem. In
WWW. 1122–1132.
[27] Jan van den Brand. 2020. A deterministic linear program solver in current
matrix multiplication time. In Proceedings of the Fourteenth Annual ACM-SIAM
Symposium on Discrete Algorithms. SIAM, 259–278.
[28] David Zuckerman. 2006. Linear degree extractors and the inapproximability of
max clique and chromatic number. In Proceedings of the thirty-eighth annual ACM
symposium on Theory of computing. 681–690.
A Appendix
A.1 Computational complexity proofs
Proof of Proposition 4.1. We will show the NP-hardness of
stc-den by a reduction from the NP-hard Max-Cliqe problem. As
𝜆=0, we simply write the score as 𝑞(𝑈,𝐿)instead of𝑞(𝑈,𝐿;𝜆)=
𝑞(𝑈,𝐿; 0)for brevity. Assume that the set 𝑈with the labeling 𝐿is
an optimal solution to the stc-den problem with 𝜆=0, maximizing
the score𝑞(𝑈,𝐿)while satisfying the STC property. The density of
the strong edges in 𝑈is then
𝑞(𝑈,𝐿)=Í
𝑣∈𝑈deg𝑠(𝑣,𝑈,𝐿)
2|𝑈|. (7)
Consider a vertex 𝑤in𝑈with the highest number deg𝑠(𝑤,𝑈,𝐿)
of strong edges connected to it. As the maximum number of strong
edges, deg𝑠(𝑤,𝑈,𝐿)has to be at least the average,
deg𝑠(𝑤,𝑈,𝐿)≥Í
𝑣∈𝑈deg𝑠(𝑢,𝑈,𝐿)
|𝑈|. (8)
Then for any two vertices 𝑣and𝑢that have strong edges (𝑣,𝑤)
and(𝑢,𝑤)connecting them to 𝑤, there must be an edge between 𝑣
and𝑢to satisfy the STC property.
Thus, the vertex 𝑤and its strong neighbors form a clique 𝐶with
deg𝑠(𝑤,𝑈,𝐿)+1vertices. Consider only having these vertices in
𝐶and having a labeling 𝐿′that labels each edge in the clique as
strong. This would satisfy the STC property and would give a score
of
𝑞(𝐶,𝐿′)=|𝐶|(|𝐶|−1)
2|𝐶|=|𝐶|−1
2=deg𝑠(𝑤,𝑈,𝐿)
2.
3342KDD ’24, August 25–29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
From Equations 7 and 8, we get
𝑞(𝐶,𝐿′)=deg𝑠(𝑤,𝑈,𝐿)
2≥Í
𝑣∈𝑈deg𝑠(𝑣,𝑈,𝐿)
2|𝑈|=𝑞(𝑈,𝐿).(9)
Thus, the clique 𝐶has at least the same score as 𝑈, which has
the maximum score of all subgraphs, so 𝑞(𝐶,𝐿′)=𝑞(𝑈,𝐿). This
means that𝐶must be a maximum size clique in the input graph 𝐺,
as larger cliques would give a higher score than 𝑈.
Therefore, by finding an optimal set of vertices 𝑈and labeling 𝐿
we can find a maximum clique 𝐶. Thus, stc-den isNP-hard. □
Proof of Proposition 4.2. Assume that we can find a set 𝑈
with labeling 𝐿that is an𝛼-approximation to stc-den, while the
optimal solution has value 𝑞(𝐶∗,𝐿∗)with a maximum clique 𝐶∗and
labeling𝐿∗. Consider then the vertex 𝑤with the highest number
of strong edges and construct the clique 𝐶consisting of 𝑤and its
strong neighbors. Define the labeling 𝐿′such that each edge in the
clique𝐶is labeled as strong. Using Equation 9 and that 𝑞(𝑈,𝐿)is
an𝛼-approximation, we get
𝑞(𝐶,𝐿′)≥𝑞(𝑈,𝐿)≥𝛼𝑞(𝐶∗,𝐿∗).
But as the score of a clique 𝐶with only strong edges is 𝑞(𝐶,𝐿′)=
|𝐶|−1
2, we have
|𝐶|−1
2≥𝛼|𝐶∗|−1
2.
By solving for|𝐶|and using𝛼≤1, we get
|𝐶|≥𝛼 𝐶∗−1+1≥𝛼𝐶∗.
This means that we have an 𝛼-approximation for Max-Cliqe.
Therefore, any inapproximability results for Max-Cliqe also apply
for the𝜆=0case of stc-den. Using the result by Zuckerman [28]
then finishes the proof. □
To prove Proposition 4.3 we need the following lemma.
Lemma A.1. Assume graph 𝐺. Let𝑋⊊𝑌be two subgraphs, and
let𝐿be a labeling defined on 𝑌. Define
Δ(𝑋,𝑌)=𝑚𝑠(𝑌)+𝜆𝑚𝑤(𝑌)−𝑚𝑠(𝑋)−𝜆𝑚𝑤(𝑋)
|𝑌|−|𝑋|.
IfΔ(𝑋,𝑌)<q(𝑌,𝐿), then q(𝑌,𝐿)<q(𝑋,𝐿), ifΔ(𝑋,𝑌)>q(𝑌,𝐿),
then q(𝑌,𝐿)>q(𝑋,𝐿), and if Δ(𝑋,𝑌)=q(𝑌,𝐿), then q(𝑌,𝐿)=
q(𝑋,𝐿).
Proof. Assume Δ(𝑋,𝑌)<q(𝑌,𝐿). Multiply by(|𝑌|−|𝑋|)|𝑌|
and subtract|𝑌|(𝑚𝑠(𝑌)+𝜆𝑚𝑤(𝑌))from both sides. Dividing by
−|𝑋||𝑌|then gives q(𝑋,𝐿)>q(𝑌,𝐿), proving the first claim. The
proofs for other claims are identical. □
Proof of Proposition 4.3. We will prove the hardness by re-
ducing an NP-hard problem MinSTC to our problem. In MinSTC,
we are asked to label the full graph and minimize the number of
weak edges [ 24]. Assume a graph 𝐺with nodes𝑉=𝑣1,...𝑣𝑛. We
assume that 𝑛≥5. We define a new graph 𝐻that consists of 𝐺and
𝑘=⌈1/𝜆⌉(𝑛+1)/2cliques𝐶𝑖of size𝑛. Let
𝑐𝑖𝑗	be the nodes in
𝐶𝑖. For each𝑗and𝑖, we connect 𝑣𝑗with𝑐𝑖𝑗.
Let𝑈be the optimal subgraph of 𝐻forstc-den and𝐿be its
labeling. Let 𝐿′be the labeling where every 𝐸(𝐶𝑖)is strong and theremaining edges are weak. Note that q(𝑈)≥q(𝐶𝑖,𝐿′)=(𝑛−1)/2≥
2for any𝐶𝑖. We claim that 𝑈contains every node in 𝐻.
To prove the claim, let us define 𝑊𝑖=𝑈∩𝐶𝑖. If|𝑊𝑖|=1,2, then
Δ(𝑈\𝑊𝑖,𝑈)≤ 3/2<q(𝑈)and Lemma A.1 states that we can
delete𝑊𝑖from𝑈and obtain a better score. Assume 3≤|𝑊𝑖|<𝑛.
Let𝑐∈𝐶𝑖\𝑊𝑖. We can safely assume that the edges between
𝑊𝑖and𝐺are weak; otherwise, we can relabel them as weak and
compensate by labeling any weak edge in 𝑊𝑖as strong. Now we
can extend the labeling 𝐿to𝑐by setting the edges from 𝑐to𝑊𝑖as
strong, and the possibly remaining edge as weak. We can show that
Δ(𝑈\𝑊𝑖,𝑈)<Δ(𝑈,𝑈∪{𝑐}). Lemma A.1, applied twice, states
that either deleting 𝑊𝑖or adding𝑐improves the solution. Therefore,
either𝑊𝑖=∅or𝑊𝑖=𝐶𝑖.
Assume𝑊𝑖=𝐶𝑖and𝑊𝑗=∅. The optimal labeling must be such
that all edges between 𝑊𝑖and𝐺are weak and the edges in 𝑊𝑖are
all strong. We can extend the same labeling scheme to 𝐶𝑗. Then
Δ(𝑈\𝐶𝑖,𝑈)=Δ(𝑈,𝑈∪𝐶𝑗). IfΔ(𝑈,𝑈∪𝐶𝑗)>q(𝑈), Lemma A.1
implies that we improve the solution by adding 𝐶𝑗, which is a
contradiction. Hence, Δ(𝑈\𝐶𝑖,𝑈)≤q(𝑈). Lemma A.1 implies that
we can safely delete 𝐶𝑖. Applying this iteratively we arrive to an
optimal solution with nodes only in 𝑉. This cannot happen since
then q(𝑈)≤(𝑛−1)/2, but then q(𝐶𝑖∪𝑉,𝐿′)=(𝑛−1)/2+𝜆/2>
𝑞(𝑈). Therefore, 𝑊𝑖=𝐶𝑖for every𝑖.
Finally, assume 𝑣𝑗∉𝑈. Then Δ(𝑈,𝑈∪
𝑣𝑗	
)≥𝜆𝑘≥(𝑛+1)/2>
(𝑛−1)/2+𝜆≥Δ(𝑈\𝐶𝑖,𝑈). Lemma A.1 states that either deleting
any𝐶𝑖or adding𝑣𝑗improves the solution. This contradicts the
optimality of 𝑈, so every𝑣𝑗∈𝑈.
Consequently, 𝑉⊆𝑈. The optimal labeling must have every
edge in𝐶𝑖as strong, the cross-edges between 𝐶𝑖and𝐺as weak,
and the labels for edges in 𝐺solve MinSTC. □
A.2 Proofs for Section 5.1
Proof of Proposition 5.1. Let us write 𝑓(𝑈,𝐿)=𝑚𝑠(𝑈,𝐿)+
𝜆𝑚𝑤(𝑈,𝐿). Note that
𝑓(𝑈(𝛼),𝐿(𝛼))−𝛼|𝑈(𝛼)|≥0. (10)
Assume𝛼>𝛼∗. If𝑈(𝛼)≠∅, then Eq. 10 implies that
q(𝑈(𝛼),𝐿(𝛼))≥𝛼>𝛼∗,
which contradicts the optimality of 𝛼∗. Thus,𝑈(𝛼)=∅.
Assume𝛼<𝛼∗. Then
𝑓(𝑈(𝛼),𝐿(𝛼))−𝛼|𝑈(𝛼)|≥𝑓(𝑈∗,𝐿∗)−𝛼𝑈∗
>𝑓(𝑈∗,𝐿∗)−𝛼∗𝑈∗=0.
That is,𝑓(𝑈(𝛼),𝐿(𝛼))>𝛼|𝑈(𝛼)|, implying in turn that 𝑈(𝛼)≠∅
andq(𝑈(𝛼),𝐿(𝛼))>𝛼. □
Proof of Proposition 5.2. Let𝐿and𝑈be the values of the
interval when binary search is terminated. Note that 𝛼≥𝐿due to
Proposition 5.1. We know that 𝑈−𝐿≤𝜖𝐿and𝐿≤𝛼∗≤𝑈. Thus,
𝛼∗−𝐿≤𝑈−𝐿≤𝜖𝐿, or𝛼∗≤(1+𝜖)𝐿≤(1+𝜖)𝛼. □
Proof of Proposition 5.3. Let𝛼be the score of the solution
𝑋,𝐿returned by STC-ILP , and let𝛼∗be the score of the optimal
solution𝑋∗,𝐿∗forstc-den. We will show that if 𝛼<𝛼∗, then
𝛼∗−𝛼≥1/(𝑏𝑛2), which contradicts with the fact that 𝛼∗−𝛼≤
𝜖𝛼<𝜖𝑛/2=1/(𝑏𝑛2).
3343Dense Subgraph Discovery Meets Strong Triadic Closure KDD ’24, August 25–29, 2024, Barcelona, Spain
To prove the claim, let Δ=𝛼∗−𝛼. Then
Δ=𝑚𝑠(𝑋∗)+𝑎
𝑏𝑚𝑤(𝑋∗)
|𝑋∗|−𝑚𝑠(𝑋)+𝑎
𝑏𝑚𝑤(𝑋)
|𝑋|
=|𝑋|(𝑏𝑚𝑠(𝑋∗)+𝑎𝑚𝑤(𝑋∗))−|𝑋∗|(𝑏𝑚𝑠(𝑋)+𝑎𝑚𝑤(𝑋))
𝑏|𝑋||𝑋∗|.
Note that the numerator and the denominator are both integers.
Consequently, if Δ>0, then Δ≥1/(𝑏𝑛2). It follows that if we set
𝜖=2
𝑏𝑛3, then STC-ILP finds the optimal solution in O(log𝑛+log𝑏)
number of rounds. □A.3 Proofs for Section 5.2
Proof of Proposition 5.4. Scaling(𝑥∗,𝑦∗,𝑧∗)by any constant
𝑐>0does not change the value of 𝑟(·,·,·)nor does it change the
validity of the constraints in Eqs. 2–4. Therefore, we can safely
assume that 𝑥∗𝑒,𝑧∗𝑒≤1and𝑦∗
𝑖≤1and𝑖∈𝑉, for any𝑒∈𝐸and
𝑖∈𝑉. The claim now follows by repeating the steps of the proof of
Proposition 5.1. □
Proof of Proposition 5.5. Scaling(𝑥∗,𝑦∗,𝑧∗)by any constant
𝑐>0does not change the value of 𝑟(·,·,·)nor does it change the
validity of the constraints in Eqs. 2–4. Therefore, we can safely
require thatÍ𝑦𝑖=1, which immediately proves the claim. □
3344