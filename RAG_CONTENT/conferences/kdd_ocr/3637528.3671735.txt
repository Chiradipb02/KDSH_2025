Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV
Md Mouinul Islam
mi257@njit.edu
CS, NJIT
Newark, NJ, USASoroush Vahidi
sv96@njit.edu
CS, NJIT
Newark, NJ, USA
Baruch Schieber
sbar@njit.edu
CS, NJIT
Newark, NJ, USASenjuti Basu Roy
senjutib@njit.edu
CS, NJIT
Newark, NJ, USA
ABSTRACT
We investigate the problem of finding winner(s) given a large num-
ber of users’ (voters’) preferences casted as ballots, one from each
of the𝑚users, where each ballot is a ranked order of preference
of up toℓout of𝑛items (candidates). Given a group protected
attribute with 𝑘different values and a priority that imposes a selec-
tion order among these groups, the goal is to satisfy the priority
order and select a winner per group that is most representative.
It is imperative that at times the original users’ preferences may
require further manipulation to meet these fairness and priority
requirement. We consider manipulation by modifications and for-
malize the margin finding problem under modification problem. We
study the suitability of Instant Run-off Voting (IRV) as a preference
aggregation method and demonstrate its advantages over positional
methods. We present a suite of technical results on the hardness
of the problem, design algorithms with theoretical guarantees and
further investigate efficiency opportunities. We present exhaustive
experimental evaluations using multiple applications and large-
scale datasets to demonstrate the effectiveness of IRV, and efficacy
of our designed solutions qualitatively and scalability-wise.
CCS CONCEPTS
•Information systems →Top-𝑘retrieval in databases.
KEYWORDS
Fairness;𝑘-Winners Selection; Instant Runoff Voting
ACM Reference Format:
Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy.
2024. Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV. In
Proceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery
and Data Mining (KDD ’24), August 25–29, 2024, Barcelona, Spain. ACM, New
York, NY, USA, 12 pages. https://doi.org/10.1145/3637528.3671735
1 INTRODUCTION
The task of finding the winner, i.e., the most favorable item or
candidate from a given set of 𝑚users’ (voters’) preferences over 𝑛
items (candidates), has found a wide variety of applications such as
This work is licensed under a Creative Commons Attribution
International 4.0 License.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08.
https://doi.org/10.1145/3637528.3671735in hiring candidate(s) for a job, selecting member(s) of a committee,
finding winning candidate(s) in a competition, in electoral voting,
or even in recommender systems. IRV (Instant Run-off Voting) is a
ranked choice voting mechanism that has been gaining popularity
lately as an electoral system in Australia, Ireland, and the U.S. [ 13,
15,20,25,29,31,35]. In this paper, we study the applicability and
computational implications of adapting IRV to preference data to
enable group fairness while satisfying a priority order.
Preference data considering faculty hiring. Table 1 represents
ranked order of up to top-5 preferences over 7candidates who
have applied to a faculty position. Preferences are provided by
10committee members (voters). Each of these ranked orders of
preferences constitutes a ballot.
Committe
e member 1st
choice 2nd
choice 3r
d choice 4th
choice 5th
choice
Jack Zo
ey Mira
Emma Laura Gina Molly Kim Zo
ey
Monica Zo
ey Molly Kim Gina Sara
Daniel Zo
ey Molly Sara Gina
Max Mira Molly Sara Kim Zo
ey
John Sara Gina Kim Zo
ey
Amy Gina Sara Kim Mira Zo
ey
Alice Sara Gina Kim Molly Zo
ey
Bob Kim Gina Sara Molly Zo
ey
Ste
ve Kim Gina Sara
Table 1: Preferences over 7( 𝑛) candidates by 10 committee
members(𝑚) upto 5-th position ( ℓ)
Fairness and priority order. Group fairness is studied considering
the protected attribute of the candidates to ensure equal representa-
tion of each group [ 22,33]. The example assumes that research area
is one such protected attribute with 𝑘=3different values (it is not
hard to extend this to race, gender, ethnicity, or any other protected
attribute). The value of this attribute for each of the candidates and
the priority among these values is given in Table 2.
Priority Order Protected attribute (area) Candidates
First DM Molly, Laura
Second ML Gina, Kim, Sara
Third AI Zoey, Mira
Table 2: Fairness and Priority Orders
Goal. The goal is to return one candidate per protected attribute
group that is most representative of the committee members’ prefer-
ences while obeying the priority order of the groups. In our example,
we need to first select a Data Mining (DM) candidate, then a Ma-
chine Learning (ML) candidate, and finally an Artificial Intelligence
(AI) candidate. Selections are made in the priority order, and if at
 
1199
KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
any point there are no more available positions, no more selections
are made. For instance, if there are 2 positions available and if both
the selected DM and ML candidates accepted their offers, then an
AI candidate will not be selected.
The IRV process. The IRV process [ 24,30] is a multi-stage pro-
cess [ 7] that simulates 𝑛−1run-off rounds, where in each such
round one item is eliminated. The single item that survived the
eliminations after all rounds is the winner. More specifically, given
the original preferences of the users (voters), an initial tally of the
first choice votes of every candidate is performed in round 1. The
item that has the lowest number of first choice votes is eliminated.
Ties are broken arbitrarily. After the elimination, all the ranked
orders that include the eliminated item are updated, and the items
following this eliminated item in the ranked order are advanced
one place up. This concludes round 1. This is iterated 𝑛−1times,
namely, the tally is recomputed, and the item that has the lowest
number of first choice votes is eliminated, where ties are broken
arbitrarily.
Using the running example, as shown in the left of Table 4, the
IRV process eliminates Molly in round 1, Mira in round 2 (and the
respective vote gets transferred to Sara), and Gina in round 3. This
process continues further making Sara the winner after 6rounds.
Motivation. The resurgence of IRV is motivated by a range of ex-
pected benefits, including, ensuring majority support for the winner,
reducing conflict within the electorate, reducing strategic voting,
and increasing diversity of the winners [ 30]. IRV is amenable to
incomplete ranked order, making the process further suitable for
applications where users are not obligated to provide full order.
Multiple recent works [ 16], [10] have demonstrated the superior-
ity of IRV over plurality voting [ 26], as well as positional voting
mechanisms (such as Borda [ 19]) to promote proportional represen-
tation of solid coalition and anti-plurality. IRV is used in elections
in Australia, Ireland, and several U.S. states [ 20,31], demonstrating
its practical utility and effectiveness. Additionally, IRV can enhance
the diversity and fairness of recommendations in AI systems. Ta-
ble 3 summarizes some of the advantages of IRV compared to other
selection methods. Refer to Appendices A.1, A.2 for further details.
Metho
dAnti-
pluralityPr
oportional
representationSuitable
to
incomplete order
Scoring
based×× ×
P
lurality ×× ×
Positional ×× ✓
IRV ✓✓ ✓
Table 3: Comparison of aggregation methods
IRV Margin computation. Recall that in our example the IRV
process chooses Sara as the winner of the ballots. Clearly, Sara
does not satisfy the priority order of selecting a DM candidate first.
Hence, some ballot modifications are needed. If Jack’s ballot in
Table 1 is changed by replacing Zoey with Molly, a series of 6run-
off rounds are simulated after that, as listed in the right of Table 4,
which makes Molly the winner. If instead Laura is to be made the
winner, this will require at least 3ballot modifications, for example,
by replacing the top choice of Alice, Monica, and John with Laura.
Intuitively too, Molly is a better choice because it is liked as thesecond choice by 3out of 7original committee members. A similar
process must also be carried out for ML and AI independently. Our
goal is to find the minimum ballot modification that results in an
outcome that satisfies the 𝑘priority orders. We refer to this problem
as IRV margin computation [26] to satisfy𝑘priority orders (denoted
byMqKIRV for𝑘≥1andMqIRV for𝑘=1). To the best of our
knowledge, we are the first to initiate a principled study on this.
Candidate T
ally R1 R2 R3 R4 R5 R6Ne
w
TallyR1 R2 R3 R4 R5 R6
Zo
ey 3 3 3 3 3 4 2 2 2 2
Sara 2 2 3 4 4 6 8 2 2 3 3 3 5
Kim 2 2 2 2 3 2 2 2 2 2
Laura 1 1 1 1 1 1 1
Gina 1 1 1 1 1
Mira 1 1 1
Molly 0 1 2 2 3 5 5 7
Table 4: IRV rounds after ballot modification (left): Sara winner
IRV rounds after ballot modification (right): Molly winner
Why ballot modification? An alternative to ballot modification
could be the following – filter out candidates that do not satisfy
the priority order (e.g., delete all ML and AI candidates for finding
the top DM candidate) and run preference aggregation over the
remaining ones. We note that such a filtering process could lead to
undesired results. Imagine that there are 99 voters and 𝑛candidates,
denoted𝐴,𝐵,𝐶 1,...,𝐶𝑛−2, where candidates 𝐴and𝐵belong to the
group with the top priority and candidates 𝐶1,...,𝐶𝑛−2belong to
another group. The preferences of 50 voters is 𝐶1>···>𝐶𝑛−2>𝐴
and the preferences of the other 49 voters is 𝐵>𝐶1>···>𝐶𝑛−2.
An aggregation mechanism based on filtering will choose 𝐴as the
winner for the top priority group and 𝐶1for the other group. On
the other hand, modifying a single vote from 𝐶1>···>𝐶𝑛−2>𝐴
to𝐵>𝐶1>···>𝐶𝑛−2will result in choosing 𝐵and𝐶1, which
seems to be a much better reflection of the voters’ preferences.
We recognize the ethical concerns related to modifying votes
to promote fairness. In our work, we argue that modifying inputs
(votes) is more morally responsible than altering outputs (results).
This is because changing outputs inherently modifies the original
preferences. Our approach minimizes changes to the original prefer-
ences, making it a more responsible method. This approach aligns
with the concept of preprocessing versus postprocessing in fair
classification, which is widely accepted in the field. Prior work in
this line has also been conducted in ranking and recommendation
systems. References such as [ 10,16,26] support the ethical and
practical advantages of our method. By adopting this approach, we
ensure that the modifications are transparent, justified, and aimed
at promoting equitable representation.
Technical Contributions (Sections 3 and 4). We make multiple
technical contributions in terms of analyzing the studied problems
as well as designing solutions for them. We prove that MqIRV is
NP-hard, even when the ballot size is at most ℓ=2by reducing an
instance of the known NP-complete problem Exact Cover by 3-Sets
(X3C) to an instance of MqIRV. Inspired by [ 13,29] we then design
an algorithmic framework AlgExact that gives an exact solution
and considers all possible permutations of the candidates that end in
a candidate that satisfies the priority order. Solving AlgExact thus
requires repeatedly solving a subproblem DistTo, which, given
a permutation, finds the smallest number of ballot modifications
needed to ensure that the order of the candidates eliminated in 𝑛−1
 
1200Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV KDD ’24, August 25–29, 2024, Barcelona, Spain
run-off rounds of IRV follow this order. Unfortunately, we prove
that the decision version of DistTo is NP-hard, even when ℓ=3,
by reducing an instance of X3C to DistTo.
We further study efficiency opportunities of AlgExact by en-
abling early terminations via branch and bound. The idea is to
avoid making expensive DistTo calls by computing a lower bound
on the margin for every possible suffix of every permutation, and
eliminating a permutation in its entirety if the lower bound on its
margin is not smaller than the current upper bound on the margin
of the MqIRV instance. To that end, we design a lower bound com-
putation algorithm DistToLB and an upper bound computation
algorithm MqIRVUB that are highly effective and computationally
lightweight. We also study the DistTo problem under different
preference manipulation models – for example, we study how to
only add the smallest number of ballots to the existing set of ballots,
such that the priority orders are satisfied. We refer to this as the
DistToAdd problem. We present an efficient exact solution for
theDistToAdd problem. We also present an integer programming
formulation for MqIRV which is non-trivial. We finally design a
highly scalable heuristics that is shown to work well in practice.
Experimental Evaluations (Section 5). Our final contribution is
experimental – we use four real world large scale datasets motivated
by different electoral voting and recommender systems applications,
as well as one synthetically generated very large datasets. Our exper-
imental evaluations have the following findings: (a)We empirically
show that MqIRVresults in a significantly smaller anti-plurality
index [ 16] (i.e., it does not select candidates that are disliked by
the majority of voters) compared to alternative approaches such
as plurality voting [ 26] or Borda [ 19].(b)We present an in-depth
case study demonstrating that ballot modification results in a lower
anti-plurality index compared to alternative approaches such as
filtering. (c)We demonstrate that AlgExact is optimal, yet more
scalable than existing solutions that could be adapted to our prob-
lem [ 29], [13].(d)We empirically demonstrate the optimality of
DistToAddAlg and its scalability, as well as the quality and scal-
ability of our designed approximate solution by varying several
pertinent parameters and comparing with appropriate additional
baseline algorithms.
We present the discussion of related work in Section 6 and conclude
in Section 7.
2 DATA MODEL & PROBLEM
In this section, we describe the data model, following which we
formally define the problem and prove its hardness.
2.1 Data model
Ballot/preference. Preference of a user is elicited using a ballot 𝑏
containing a ranking up to position at most ℓ, where𝑐𝑖is the𝑖-th
preferred candidate. Using the running example, 𝑐1and𝑐5areGina,
andZoey, respectively of user Amy’s ballot.
Ballot profiles. The data contains the preferences/ballots Bof𝑚
users/voters over a set 𝐶of𝑛items/candidates. Using the running
example,𝑚=10,𝑛=7. The columns in Table 1 show B.
Preference aggregation. A preference aggregation method F
takesBas input and selects a winner from the candidates/items.
Given fairness criteria and priority order, the goal is to make use ofBandFmultiple (𝑘) times to select 𝑘different winners in the pri-
ority order. Table 2 shows 𝑘=3such constraints for recommending
top DM, ML, and AI candidates. We use IRV as F, as discussed in
more detail in Section A.2.
Preference manipulation models. We consider two different
preference manipulation models, where only the first one satisfies
the number of ballot invariance property (i.e., the total number of
votes remains unchanged) and is our primary focus in this work.
(1)Manipulation by modification. Given a ballot 𝑏with ranking
up to position 𝑗(𝑗≤ℓ) positions, update any number of entries
in𝑏considering candidates from 𝐶. As an example, Jack’s ballot
(see Table 1) is changed from Zoey, Mira toMolly, Mira. Note
that changing Daniel’s ballot from Zoey, Molly, Sara, Gina to
Mira, Kim also constitutes to a single ballot modification.
(2)Manipulation by addition. Add a new ballot 𝑏with ranking
of up toℓcandidates from 𝐶.
Handling ties in IRV Recall that according to our definition ties
during the IRV process are broken arbitrarily. It is not difficult to
see that the way these ties are broken may impact the value of the
margin. Indeed, in our example of ballot modification candidate
Molly is the winner after just a single modification only in case
the ties are broken in a very specific way. We postulate that any
consistent choice would be effective in our case, since we use the
margin to distinguish among choices and are not interested in the
actual value of the margin.
2.2 Problem Definitions & Hardness
Problem Definition 1. MqIRV (IRV Margin satisfying a single
query constraint). Given a set of ballots Beliciting𝑚voters ranked
preferences of up to ℓpositions over a given set 𝐶of𝑛candidates,
and a query constraint that specifies a subset of the candidates, find
the minimum number of ballots that need to be modified in order
to ensure that the winner of the IRV election belongs to the subset
specified in the query constraint.
Running Example. Referring to Table 2, if the query constraint
specifies selecting a DB candidate, then the minimum number of
ballot modifications required to ensure that is 1, where Zoey in
Jack’s ballot is swapped by Molly. If instead Laura is to be made the
winner, this will require 3ballot modifications. Hence, the margin
to satisfy the query constraint is 1.
Theorem 2.1. MqIRV is NP-Complete, even when ℓ=2.
Proof is given in Appendix A.3.
Problem Definition 2. MqKIRV (IRV Margin satisfying 𝑘query
constraints.) Given a set of ballots Beliciting𝑚voters ranked pref-
erences of up to ℓpositions over a given set 𝐶of𝑛candidates, and
a query with 𝑘constraints, each specifies a subset of the candidates,
find the minimum number of ballots that need to be modified in or-
der to ensure that the winners of 𝑘independent invocations of the
IRV election (each starting from the original ballots) belong to the
respective subsets specified 𝑘query constraints.
Theorem 2.2. MqKIRV is NP-Complete, even when ℓ=2.
Proof. Follows trivially from Theorem 2.1. □
 
1201KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
Running Example. Considering the running example again (Ta-
ble 2),𝑘=3and the ballots are shown in Table 1. The winner for
DB is Molly (margin = 1), for ML it is Sara (margin = 0), for AI it is
Zoey (margin = 1). The minimum number of ballot modifications
(margin) required to ensure all three constraints is 1+0+1 =2.
3 ALGORITHMS FOR MqIRV AND MqKIRV
In this section, we focus on designing exact solutions for MqIRV
andMqKIRV. In Section 3.2 we discuss AlgExact, a branch-and-
bound algorithm for MqIRV that is capable of effective pruning
of the search space. In Section 3.3 we present a non-trivial integer
programming formulation of MqIRV. These exact algorithms apply
also exact algorithms for for MqKIRV as follows from the following
simple theorem.
Theorem 3.1. An optimal solution for MqKIRV corresponds to
solving MqIRV optimally𝑘times.
3.1 Required Definitions
We first give some definitions that will be useful when discussing
our algorithms.
Signature. LetSbe the set of all possible partial or total rankings
over𝐶(including those that do not appear in B). A signature 𝑠∈S
is one such partial or total ranking. The total number of possible
signatures is|S|=Íℓ
𝑥=1 𝑛
𝑥·𝑥!. For example, both {Molly, Sara}
and {Zoey, Molly, Sara, Gina} are valid signatures even though the
former is not present in Table 1.
Tally𝑡𝑟(𝑐)or first choice votes. The tally or first choice votes of
a candidate𝑐at round𝑟, denoted as 𝑡𝑟(𝑐), is defined as the number
of ballots in round 𝑟in which𝑐is the first choice candidate. Using
the running example, tally of Sara, Zoey, and Kim at the beginning
of round 5are:𝑡5(Sara) =4,𝑡5(Zoey) =3, and𝑡5(Kim) =3.
3.2 AlgExact for MqIRV
We propose an algorithmic framework AlgExact that is an exact
solution to the MqIRV problem. The algorithmic solution is de-
veloped by creating a branch and bound tree, akin to two prior
works [13, 29].
For a given winner 𝑤, the solution considers all possible per-
mutations of candidates that need to be eliminated (i.e., (𝑛−1)!),
where each permutation represents an elimination order simulating
𝑛−1run-off rounds of IRV. The height of the tree is at most 𝑛. Each
node of the tree contains two values: (a) an elimination order 𝜋,
(b) a score that represents the number of ballot modifications to
realize𝜋(we formalize that as DistTo below). Each edge of the
tree represents the next candidate to be eliminated. An artificial
root node connects the branches of the subtree, where each subtree
represents a 𝑤∈𝑊as the winner, where 𝑊is the constrained
winner set specified by the query. Except for the fake root node, the
relationship between any parent and child nodes in the tree is as
follows: (i) At any parent node with elimination order 𝜋, the child
node has elimination order 𝜋′=𝑐+𝜋, for some𝑐∈𝐶−𝜋, and
(ii)DistTo(𝜋)≤DistTo(𝜋′) [29]. The leaf nodes end with a full
permutation, where the last candidate is from 𝑊. The maximum
number of possible leaf nodes is = |𝑊|×(𝑛−1)!.AlgExact solves
the sub-problem DistTo formalized below, repeatedly, at each node
of the branch and bound tree.Algorithm 1 AlgExact
Input: Ballot profile B, set of Candidates 𝐶, set of preferred
candidates𝑊.
Output: MqIRV
1:𝑢𝑏=∞
2:𝑙𝑏=0
3:initialize priority 𝑞𝑢𝑒𝑢𝑒 with tuples(𝑤,0)where𝑤∈𝑊
4:while𝑞𝑢𝑒𝑢𝑒 .notEmpty() do
5:𝜋,𝑙𝑏 =𝑞𝑢𝑒𝑢𝑒 .pop()
6: for𝑐∈𝐶\𝜋do
7:𝜋′=𝑐+𝜋
8:𝑙𝑏=DistToLB(B,𝐶,𝜋′)
9: if𝑙𝑏>𝑢𝑏then
10: prune𝜋′
11: else
12: 𝑞𝑢𝑒𝑢𝑒 .add(𝜋′,𝑙𝑏)
13: end if
14: if|𝜋′|==𝑛then
15: 𝑢𝑏=min(𝑢𝑏,DistTo(B,𝐶,𝜋′))
16: end if
17: end for
18:end while
19:MqIRV =𝑢𝑏
20:Return MqIRV
Problem Definition 3. DistTo. Given an elimination order over
the candidates 𝜋(complete or partial order, |𝜋|≤|𝐶|) and a database
of ballot profilesB, find the minimum number of ballots that must
be modified to achieve 𝜋.
Theorem 3.2. DistTo is NP-hard, even when ℓ=3.
Proof omitted due to space constraints.
AlgExact explores the tree level by level (refer to Figure 9 in
Appendix A.4) and makes an attempt to prune part of the tree
based on the lower bound of a branch (which corresponds to an
elimination order) and an upper bound of the value the MqIRV
instance.
Definition 3.3. Upper bound of an instance MqIRVUB. Given
anMqIRV instance, MqIRVUB is defined as an upper bound of
the number of ballots that must be modified to satisfy the query
constraint.
Definition 3.4. Lower bound (DistToLB) of DistTo(𝜋).Given
anMqIRV instance and an elimination order 𝜋,DistToLB is a
lower bound on the number of ballots that must be modified to
achieve𝜋, namely, DistToLB(𝜋)≤DistTo(𝜋).
Running Example. Figure 9 shows one such partially constructed
tree for our running example.The candidates are represented by
their unique ids, and any red node and the sub-tree under them
are fully pruned. Each such red node has DistToLB(𝜋) that is
not smaller than the MqIRVUB of the MqIRV instance (e.g.,
DistToLB([1,3,5])=4is larger than MqIRVUB =2). Compared
to prior works [ 13,29], we propose both effective as well as com-
putationally efficient MqIRVUB andDistToLB solutions, as we
discuss in Section 4.
 
1202Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV KDD ’24, August 25–29, 2024, Barcelona, Spain
3.3 IP for MqIRV
MqIRV can be formulated as an integer linear program (IP). The
objective of the IP is to minimize the number of ballot modifications
required to ensure that the winner is the preferred candidate. Next,
we describe how to formulate this IP.
min∑︁
𝑠∈S𝑎𝑠subject to
𝑚𝑠+𝑎𝑠−𝑑𝑠=𝑦𝑠 ∀𝑠∈S (1)
𝑚≥𝑦𝑠≥0 ∀𝑠∈S (2)
𝑚𝑠≥𝑑𝑠≥0 ∀𝑠∈S (3)
𝑚−𝑚𝑠≥𝑎𝑠≥0 ∀𝑠∈S (4)
∑︁
𝑠∈S𝑎𝑠=∑︁
𝑠∈S𝑑𝑠 (5)
𝑢𝑐𝑖,𝑐𝑗+𝑢𝑐𝑗,𝑐𝑖=1 ∀{𝑐𝑖,𝑐𝑗}⊆𝐶 (6)
𝑢𝑐𝑖,𝑐𝑗+𝑢𝑐𝑗,𝑐𝑟+𝑢𝑐𝑟,𝑐𝑖≥1∀{𝑐𝑖,𝑐𝑗,𝑐𝑟}⊆𝐶 (7)
𝑣𝑠,𝑐𝑖,˜𝑐=𝑢𝑐𝑖,˜𝑐·Π𝑖−1
𝑥=1𝑢˜𝑐,𝑐𝑥∀𝑠∈S∀ ˜𝑐∈𝐶
∀𝑖∈{1,...,|𝑠|} (8)
∑︁
𝑠(𝑦𝑠·𝑣𝑠,ˆ𝑐,˜𝑐)≥𝑢ˆ𝑐,˜𝑐·∑︁
𝑠 𝑦𝑠·𝑣𝑠,˜𝑐,˜𝑐∀{ˆ𝑐,˜𝑐}⊆𝐶 (9)
The IP for MqIRV
For each ballot signature 𝑠∈S, let𝑚𝑠denote the number of
ballots with signature 𝑠in the original ballot profile. Define 𝑚=Í
𝑠∈S𝑚𝑠, so that𝑚counts the total number of ballots in the original
election profile. Note that the values of 𝑚𝑠and𝑚are determined
by the original election profile. Let 𝑎𝑠denote the number of ballots
that are modified to 𝑠from a different ballot signature, 𝑑𝑠denote
the number of ballots that are modified from 𝑠to another ballot
signature, and 𝑦𝑠denote the total number of ballots with signature
𝑠after the modifications.
Constraint 1 requires that the number of ballots with a new
signature𝑠be equal to the number of ballots that originally had
the signature 𝑠, plus the number that changed from something
else to𝑠, minus the number that changed from 𝑠to something
else. Constraint 2 states that the number of ballots that end with
signature𝑠cannot be more than the total number of ballots that
were cast in the election. Constraints 3 and 4 require that one cannot
change more ballots of signature 𝑠than the number of ballots that
originally had the signature 𝑠, and that the number of ballots that
are modified to signature 𝑠must be nonnegative and no more than
the number of ballots that had a signature different than 𝑠originally.
Constraint 5 implies that the total number of ballots changed
from any signature is equal to the total number of ballots changed
toany signature.
Constraints 6 and 7 correspond to the elimination order. Assume
𝐶is the set of all candidates. For every pair {𝑐𝑖,𝑐𝑗}⊆𝐶, define𝑢𝑐𝑖,𝑐𝑗
as a binary variable that is 1iff candidate 𝑐𝑗is eliminated before
candidate𝑐𝑖. For completeness also define 𝑢𝑐𝑖,𝑐𝑖=1, for every 𝑐𝑖∈
𝐶. To guarantee that the variables 𝑢𝑐𝑖,𝑐𝑗define an order, Constraint 6
requires it to be antisymmetric and Constraint 7 requires it to satisfy
the triangle inequality.For a signature 𝑠of an original ballot and candidates ˆ𝑐and ˜𝑐
(which may be equal), define the binary variable 𝑣𝑠,ˆ𝑐,˜𝑐to be 1iff
when candidate ˜𝑐is eliminated ˆ𝑐is the top candidate in the signature
that had originally been signature 𝑠. Bit𝑣𝑠,ˆ𝑐,˜𝑐is trivially 0ifˆ𝑐does
not appear in 𝑠. Let signature 𝑠=𝑐1,𝑐2,...,𝑐ℓ, where𝑐𝑥is the𝑥-th
candidate on the ballot, 𝑐1is the top choice while 𝑐ℓis the bottom.
Assume from now on that ˆ𝑐=𝑐𝑖. For candidate 𝑐𝑗in𝑠, where
𝑗<𝑖, bit𝑣𝑠,𝑐𝑖,𝑐𝑗is0since𝑐𝑗is ranked higher than 𝑐𝑖is𝑠. Assume
from now on that ˜𝑐≠𝑐𝑗, for𝑗∈{1,...,𝑖−1}. Constraint 8 on
𝑣𝑠,𝑐𝑖,˜𝑐ensures that all the candidates 𝑐1,𝑐2,...,𝑐𝑖−1are eliminated
before ˜𝑐is eliminated, and in case 𝑐𝑖≠˜𝑐, candidate𝑐𝑖is eliminated
after ˜𝑐is eliminated. Thus signature 𝑠contributes to 𝑐𝑖’s tally when
˜𝑐is eliminated. Note that since by definition 𝑢𝑐1,𝑐1=1, we get
that𝑣𝑠,𝑐1,𝑐1=1, which holds trivially. The constraint in its current
format is not linear since it is a product of bits. Later, we show how
to convert it to linear constraints.
Constraint 9 is for every ordered pair of candidates ˆ𝑐≠˜𝑐. It
guarantees that if 𝑢ˆ𝑐,˜𝑐=1, namely ˆ𝑐is eliminated after ˜𝑐, then in
the round in which ˜𝑐is eliminated the number of ballots in which
ˆ𝑐is the top candidate is at least the number of ballots in which ˜𝑐is
the top candidate. The constraint is written as a product of bits and
an integer (later, we show how to convert it to linear constraints).
If we want to force candidate ˆ𝑐to be the winner we need to add
the constraints 𝑢ˆ𝑐,˜𝑐=1, for every ˆ𝑐≠˜𝑐. Alternatively, if we want to
force candidate ˆ𝑐notto be the winner we need to add the constraintÍ
˜𝑐≠ˆ𝑐𝑢˜𝑐,ˆ𝑐≥1. In addition, we can change the objective function to
count only additions or only deletions or any linear combination
of additions, deletions, and modifications. For our case we set the
objective function to be: minimizeÍ𝑎𝑠, which is the number of
ballots modifications.
In the last two constraints, we used (i) product of bits, and more
generally (ii) product of a nonnegative number and bits. We show
how to linearize a product of a nonnegative number and bits as long
as we have an upper bound on the number. Let 𝑢1,...,𝑢𝑥be𝑥bits,
and𝐴be a non-negative number. Assume that 𝑚is an upper bound
on𝐴. (As in our case, since 𝑚is the total number of signatures.)
The constraints that replace 𝑧=𝐴·Π𝑥
𝑖=1𝑢𝑖are as follows.
𝑧≤𝑢𝑖·𝑚 for𝑖∈{1,...,𝑥}
𝑧≤𝐴
𝑧≥𝐴+ 𝑥∑︁
𝑖=1𝑢𝑖−𝑥!
·𝑚
𝑧≥0
4 EFFICIENT ALGORITHMS
This section is dedicated to further investigation of computational
efficiency. In Section 4.1, we describe an improved algorithm for
computing DistToLB. Due to space constraints we had to omit the
description of two additional algorithms: (1) an improved MqIRVUB
algorithm that is computationally efficient and can be applied as
an efficient heuristic for the MqIRV problem, and (2) an efficient
(polynomial time) algorithm for DistTo in case only ballot addi-
tions are allowed. Thus, demonstrating that DistTo becomes a
computationally tractable in this special case.
 
1203KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
4.1 An Improved DistToLB Algorithm
In this section, we discuss an improved lower bound calculation
algorithm for DistTo(𝜋). The intuition is the following: given 𝜋
and two candidates 𝑐and𝑐′, if𝑐needs to be eliminated before 𝑐′
in round𝑖, where𝑡𝑖(𝑐)and𝑡𝑖(𝑐′)are the number of first choice
votes of𝑐and𝑐′in round𝑖, respectively, then at leastl𝑡𝑖(𝑐)−𝑡𝑖(𝑐′)
2m
number of first choice votes from 𝑐needs to go to 𝑐′. That is,𝑙𝑏, the
lower bound of round 𝑖is calculated as the half of the difference
of tally between 𝑐and𝑐′. Finally, the maximum over all of these
is returned as the output of the algorithm. Algorithm 2 has the
pseudocode.
Algorithm Efficient AlgExact Blom
Number of IP callsAI: 1
ML: 1
DM: 2AI: 143
ML: 108
DM: 107
Runtime (s) 0.057 0.626
Table 5: Efficiency improvement using MqIRVUB and
DistToLB for the running example
Running example. Assume,𝜋= [Gina, Molly, Zoey] =[4,6,0]
where 4is eliminated first. Initially, 𝑡1(Gina) = 6, 𝑡1(Zoey) = 3,
𝑡1(Molly) = 1. To ensure Gina is eliminated, at least max{6−1
2
,6−3
2
}
=3ballot modifications are required. After Gina is eliminated,
𝑡2(Zoey) = 5,𝑡2(Molly) = 4. Required modifications of the ballot to
ensure that Zoey wins =5−6
2
=0. Therefore, 𝑙𝑏=max(3,0)=3.
Using the running example, Algorithm 2 reduces a significant
number of DistTo (which is solved using IP) calls. For example,
𝑙𝑏=DistToLB([4,6,0])=3≤DistTo([4,6,0]). Hence AlgExact
prunes the branch [4,6,0]without having to make an expensive
DistTo call (this is because 𝑙𝑏for this branch >𝑢𝑏). Table 5 shows
efficiency improvement using DistToLB andMqIRVUB inside
AlgExact over prior work [13].
Algorithm 2 Algorithm for DistToLB
Input: Set of ballots B, an elimination order 𝜋
Output: DistToLB(DistTo( 𝜋))
1:𝑙𝑏=0
2:while|𝜋|>1do
3:𝑐=𝜋.pop_front()
4: for𝑐′∈𝜋\𝑒do
5:𝑙𝑏=max(𝑙𝑏,l𝑡𝑖(𝑐)−𝑡𝑖(𝑐′)
2m
)
6: end for
7:end while
8:Return𝑙𝑏
Theorem 4.1. Algorithm 2 returns a valid lower bound on DistTo(𝜋).
Lemma 1. The running time of Algorithm 2 is 𝑂(𝑛2+𝑚ℓ).
5 EXPERIMENTAL EVALUATIONS
We conducted experiments to analyze our algorithms, implemented
in Python 3.8 on a Windows 11, i7, 16GB RAM setup. Results are
averages from 10 runs. The code and data could be found in the
github [3].5.1 Experiment Design
We have three goals. (a) Assess the effectiveness of MqKIRV (Sec-
tion 5.2). (b) Evaluate the quality of our designed algorithms for
MqIRV andMqKIRV problems (Section 5.3). (c) Evaluate their scal-
ability (Section 5.4). We analyzed four real-world and one synthetic
dataset, with comprehensive details provided in Table 6.
Dataset
Name𝑚𝑛 Description
NSW
Senate
Election data533 1,520k Candidates
from five parties.
San
Francisco
Election data18 193kBoar
d of supervisors, district
attorney, and mayoral results.
Mo
vieLens 100k 100k User
movie ratings.
A
dressa News 100k 100k Ne
ws articles with user ratings.
Synthetic 1,000k 1,000k Random
preference rankings.
Table 6: Real world and synthetic datasets
(𝑚denotes number of candidates and 𝑛number of voters)
5.1.1 Baseline Algorithms. The following algorithms are imple-
mented.
1.Filtering-Borda [32]. We implement a baseline where candi-
dates who do not satisfy the query constraints are first filtered out.
Then, considering the remaining candidates, the preferences of the
voters are aggregated using the ”positional” scoring mechanism
Borda [ 32] that assigns a score to each candidate corresponding
to the positions in which a candidate appears within each voter’s
ballot. This baseline is implemented to evaluate two aspects: 1. Why
a ballot modification is necessary, and 2. effectiveness of a different
positional aggregation mechanism and its effectiveness over IRV.
2.Plurality voting [21,23]. The winner is the candidate who rep-
resents a plurality of voters’ first choice or, in other words, receives
more first choice votes than any other candidate. That makes plural-
ity voting among the simplest of all electoral systems. This baseline
is implemented to evaluate effectiveness of a non positional aggre-
gation mechanism and its effectiveness over IRV.
3.Blom et al. [13]. Magrino et al. [ 29] propose a simple lower
bound based on the DistTo of any𝜋of length𝑛. Given two elimi-
nation orders, if one is the suffix of another, then, the DistTo of the
suffix could be used as the DistToLB ofDistTo for the longer elim-
ination order. Blom et al. [ 13] propose an improved lower bound
over [ 29] based on the last round margin 𝑙(𝑐′,𝑐)between any pair
of candidates 𝑐and𝑐′(to ensure𝑐′is eliminated before 𝑐), where
𝑙(𝑐′,𝑐)is half of the difference in the tallies of 𝑐′and𝑐(first choice
votes). This idea is generalized to generate lower bound of margin
to ensure an elimination order ending in 𝜋, which is max{𝑙(𝑐′,𝑐)},
where𝑐′∈𝐶−𝜋,𝑐∈𝜋.
4.Random. We implement an algorithm that runs iteratively. In
the first iteration, it randomly selects a ballot and modifies it. In
the next iteration, it doubles the number of selected ballots to be
modified (and selects those ballots randomly) and repeats the pro-
cess until the query constraints are satisfied.
5.IP for DistToAdd. We implement an integer programming based
solution for the DistToAdd problem.
These algorithms are compared against our proposed DistToLB
andMqIRVUB solutions inside AlgExact. We also compare Al-
gApprx against these solutions and the implemented IP for MqIRV.
Finally, we compare our designed solution DistToAddAlg with its
corresponding IP implementation.
 
1204Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV KDD ’24, August 25–29, 2024, Barcelona, Spain
7 8 9 10
# candidates0.00.20.40.60.81.0Anti-Plurality IndexIRV
Plurality
Filtering-Borda
Figure 1: Anti-plurality index using NSW election dataset
5.1.2 Measures. To evaluate anti-plurality, we measure the anti-
plurality index that is proposed in a related work [ 16]. Anti-plurality
index of a preference aggregation method is computed by looking
at each winner candidate 𝑖that the method produces and then
calculating the percentage of voters who prefer 𝑖the least (i.e.,
it is the last choice on their ballots). The average anti-plurality
index is then calculated by taking the average over multiple queries.
To evaluate the quality of our designed algorithms, we compare
approximation factors of margins produced by different algorithms
(margin produced by the proposed algorithm/ exact margin), as
well as compare the exact margin values. Finally, we compare the
effectiveness of the proposed algorithms based on the number of
expensive DistTo calls they make (smaller is better). To evaluate
scalability, we evaluate the pruning effectiveness of the algorithms
and the overall running time.
5.1.3 Query and Parameters. Query constraints are generated ran-
domly but by using party affiliation for NSW datasets, race of the
candidates from the San Francisco Election dataset, and movie genre,
and news type of the last two datasets, respectively. For evaluating
MqIRV, we vary the size of the ballot ( ℓ), number of users ( 𝑚), and
the number of candidates ( 𝑛). We consider various combinations
over these parameters to cover a wide range of recommendation
settings. The default values are 𝑛=10,ℓ=4and𝑚=1000.
5.2 Goal 1: Analyzing Anti-plurality
For these experiments, NSW dataset is used. For each query, the set
𝑊is selected arbitrarily based on the 5different party affiliations
of the candidates – Labor Party or LAB, Christian Democratic
Party or CDP, National Party or NLT, Liberal Party or LIB, The
Greens or GRN. We compare average anti-plurality index of MqIRV
margin computation based on plurality voting [ 21,23] and margin
computation based on Filtering-Borda in Figure 1 after running
133queries. These results clearly indicate that MqKIRV results in
significantly anti-plurality compared to the other baselines.
5.2.1 A case study. We present a case study to demonstrate efficacy
ofMqIRV to overcome anti-plurality. A smaller subset of NSW
election data is used that contains 12candidates and 33,553voters.
A query is generated to select candidates that are either LIB or
LAB. This makes 𝑊={2,5,8,10}(these numbers are the unique
ids of the candidates). MqIRV selects candidate 8as the winner,
while, Plurality voting and Filtering-Borda both select candidate
5. Upon further analysis, it appears that a total of 9884 voters like
candidate 5as their first choice, while a total of 5411 voters dislike
candidate 5(these voters place candidate 5as their last choice on
their ballots). For candidate 8, these two numbers are 9483 and1863,
respectively. In fact, about 25%of the voters put candidate 5as oneof their 3least preferred candidates compared to only 2%voters that
do so for candidate 8. This case study anecdotally demonstrates the
efficacy of MqIRV to overcome anti-plurality. This case study also
demonstrates why filtering based approach could skew the results,
which MqIRV avoids by looking at the entire ballot and the order
of all candidates.
5.3 Goal 2: Analyzing Quality
Approximation factor. In Table 7, we present the approximation
factors of the MqIRV problems solved using different algorithms.
The results are shown for 4real datasets. Two of the exact solutions
are compared against the IP formulation of MqIRV and exhibit
approximation ratio of 1, as expected. AlgApprx has an approxi-
mation ratio between 1.91and3.15. On the other hand, Random
has an approximation ratio between 3.61and 4.21. As analyzed
analytically, DistToAddAlg is an exact solution of DistToAdd
and has an approximation ratio of 1.
Dataset AlgExa
ct DistT
oAdd AlgApprx Random
NSW
dataset 1 1 1.97 3.41
San
Francisco Election 1 1 1.98 3.96
Mo
vieLens 1 1 1.99 3.42
A
dressa News 1 1 3.15 4.21
Table 7: Approximation factor of the algorithms
Margin. Figure 2 shows the box plot of difference in margin for
AlgApprx andAlgExact varying𝑛for all 4real datasets over 10
different queries. These results corroborate that AlgApprx is an
effective solution across all 4datasets.
We also analyze the margin difference between AlgApprx and
Random using one synthetic dataset and 3real datasets varying
𝑛up to 1million. For each run, we keep the number of ballots
𝑚=𝑛. Figure 5 shows AlgApprx always returns smaller margin
than Random. Using MovieLens data, Random margin is about 20
times larger than AlgApprx.
Number of DistTo IP calls. Finally, we show that AlgExact re-
quires significantly less number of IP calls compared to Blom (Fig-
ure 6). On Adressa News dataset on 𝑛=10,AlgExact invokes
about 17times less number of IP calls than what Blom does. These
results demonstrate the effectiveness of our proposed DistToLB
andMqIRVUB solutions, compared to the adapted version of [ 13].
5.4 Goal 3: Analyzing Scalability
Running time. In these experiments (Figure 3), we compare run-
ning time in seconds for AlgExact, AlgApprx, and Blom on4real
world datasets by varying 𝑛, while keeping ℓand𝑚fixed. The ex-
act algorithms show that the running time increases exponentially
with increasing 𝑛.AlgApprx is almost 24333 times faster than Blom
for𝑛=12using MovieLens dataset. While AlgExact is7.6times
faster than Blom for 𝑛=12using MovieLens dataset.
Figure 7 presents effect of varying ℓand𝑚on running time
ofAlgExact, AlgApprx, and Blom on 2real world datasets. As
expected, running time AlgExact does not significantly vary with
increasing𝑚andℓ, as it is mostly driven by exponential 2𝑛cost of
branch & bound tree exploration.
Running time in very large scale data. For these experiments,
we compare running time of our efficient solution AlgApprx and
compare that with Random. Figure 8 shows that the running time of
 
1205KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
AlgApprx is significantly smaller than Random. Using the Adressa
News dataset with 𝑛=100𝑘,𝑚=100𝑘and𝑙=4, the runtime for
Random is about 100times higher than AlgApprx.
Running time of DistToAddAlg. Figure 4 compares the running
time between our exact solution DistToAddAlg forDistToAdd
with IP based implementation (DistToIPADD). DistToIPAdd run-
time increases exponentially with 𝑛as expected, whereas, Dist-
ToAddAlg runs in𝑂(𝑛2)time. For MovieLens dataset with 𝑛=10
DistToAddAlg is53times faster than DistToIPAdd.
5.5 Summary of Results
Our first observation is that, MqKIRV significantly promotes lower
anti-plurality, whereas, the other baselines do not. The case study
demonstrates that ballot modification selects winner with lower
anti-plurality index than plurality voting and a filtering based ap-
proach ( Filtering-Borda ) that could be myopic at times. Our
second major observation is that our designed AlgExact enabled
by effective lower bound DistToLB and upper bound MqIRVUB
algorithm is highly effective as well as computationally efficient
compared to their counterparts Blom. Third, AlgApprx exhibits
empirical approximation factor around 2(for3of the datasets) and
runs significantly faster than the exact solutions (order of magni-
tude faster) and the Random baseline. Finally, consistent with our
theoretical analysis, DistToAddAlg returns an exact solution for
DistToAdd, runs in polynomial time, and is significantly faster
(about 53times for some datasets) than the IP based solution.
6 PRIOR WORK
We present related work covering three areas: (a) preference ag-
gregation methods, (b) how to minimally update preferences so
that the produced outputs satisfy additional criteria, and (c) multi-
stage preference aggregation methods and their margin of victory
computation.
We remark that it is evident from this prior work that we are
the first to study an IRV based multi-stage preference aggregation
procedures [ 7]. Also, our margin finding problem MqKIRV is dif-
ferent from previously known Margin of victory (MoV) problems,
and our hardness results and algorithmic solutions to this problem
extend the state of the art in this area.
Preference aggregation. Preference aggregation is closely studied
in the context of group recommendation [ 1,2,5,8,9,14,28,34],
with the goal of selecting one or top- 𝑘items that are most suitable
to the preference of all users in the group. These are also studied
while promoting fairness in ranking and recommendation [ 33,38].
In [16], the authors empirically demonstrate that multi-stage vot-
ing methods, such as STV and IRV offer benefits over positional
preference aggregation methods (e.g., plurality voting, approval
voting) in the recommendation contexts by handling hyperactive
users in a more equitable and fair way.
Changing original preferences. The second line of related work
exists in how to minimally update the original preferences of the
users so that the produced outputs satisfy additional criteria.Some leading criteria include maximizing the satisfaction of some
specific users considering rating based preference aggregation meth-
ods in top-𝑘recommendation [ 9], changing the original winner,
that is, computing margin, or producing Margin of victory (MoV), or
satisfying fairness criteria [ 26,36], to name a few. Among these, the
most relevant to this work is the previous work on computing MoV.
There are two types of MoV: constructive and destructive. In the
constructive (destructive) version, the goal is to find the minimum
number of changes to the ballots that is needed so that a special
candidate is (not) elected. [ 37] has investigated the computational
complexity and (in)approximability of computing MoV for various
voting rules, including approval voting, all positional scoring rules,
etc. [ 11] has introduced a sampling based probabilistic algorithm for
finding the margin of victory, which can be used for many voting
rules.
Multi-stage preference aggregation methods and their mar-
gin of victory computation. Multi-stage methods, such as STV
and IRV, were introduced in the 19th century in electoral voting
systems. [ 6] demonstrated that determining whether the MoV in an
IRV election is at most 1 is NP-hard for both constructive and de-
structive versions. Moreover, there is no 2-approximation algorithm
for it unless 𝑃=𝑁𝑃. In [ 17] the coalitional weighted manipulation
is investigated. In [ 27] the authors present a branch and bound
algorithm that calculates possible winners when only part (rather
than all) of the ballots are accessible. The usage of [ 27] is to gener-
ate information on the result of an election and to announce it on
election night, even when there are still some ballots that have not
been counted. MoV of IRV [ 30] and STV [ 24] is studied in many
related works [4, 12, 13, 29].
7 CONCLUSION
We study the suitability of Instant Run-off Voting (IRV) as a prefer-
ence aggregation method to select 𝑘different winners to promote
group fairness and priority. We formalize an optimization problem
that aims at finding the margin, i.e., the smallest number of modifi-
cations of original users’ preferences (ballots) so that the selected 𝑘
winners satisfy all these query constraints. We present principled
models and several non-trivial algorithmic and theoretical results.
Our experimental analyses demonstrate suitability of IRV as a pref-
erence aggregation method over plurality voting and a filtering
based approach, as well as corroborate our theoretical analysis.
This work opens up many interesting directions – as an ongoing
work, we are investigating how to design approximation algorithms
with theoretical guarantees for MqIRV. We are also studying how
our proposed solution AlgExact could be adapted to compute the
margin for single transferable voting (STV) schemes.
ACKNOWLEDGMENTS
The work of Md Mouinul Islam, Soroush Vahidi, Baruch Schieber
and Senjuti Basu Roy is supported by the following funding agen-
cies: (1) National Science Foundation award number(s): 1942913,
2007935, 1814595 (2) Office of Naval Research award number(s):
N000141812838, N000142112966
 
1206Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV KDD ’24, August 25–29, 2024, Barcelona, Spain
45678910
# candidates (n)1k2k3k4kMargin difference
(a) NSW Election
45678910
# candidates (n)01020Margin difference (b) San Francisco Election
456789101112
# candidates (n)02040Margin difference (c) MovieLens
45678910
# candidates (n)0.2k0.6k1.0kMargin difference
 (d) Adressa News
Figure 2: Margin difference between AlgApprx andAlgExact varying𝑛
4 6 8 10
# candidates (n)050100Time (s)AlgApprx
AlgExact
Blom
(a) NSW Election
4 6 8 10
# candidates (n)02040Time (s)AlgApprx
AlgExact
Blom
 (b) San Francisco Election
4 6 8 10 12
# candidates (n)050100150Time (s)AlgApprx
AlgExact
Blom (c) MovieLens
4 6 8 10
# candidates (n)02040Time (s)AlgApprx
AlgExact
Blom (d) Adressa News
Figure 3: Runtime for AlgApprx, AlgExact, and Blom varying𝑛
4 6 8 10 12
# candidates (n)0200400600Time (s)DistToAddAlg
DistToIPAdd
(a) NSW Election
4 6 8
# candidates (n)02040Time (s)DistToAddAlg
DistToIPAdd (b) San Francisco Election
4 6 8 10 12
# candidates (n)0200400Time (s)DistToAddAlg
DistToIPAdd (c) MovieLens
4 6 8 10
# candidates (n)0100200300Time (s)DistToAddAlg
DistToIPAdd (d) Adressa News
Figure 4: Runtime for DistToAddAlg andDistToIPAdd
50k 100k 500k 1000k
# candidates0204060MarginAlgApprx
Random
(a) Synthetic
200 500 800 1000
# candidates0204060MarginAlgApprx
Random (b) MovieLens
5k 10k 50k 100k
# candidates5k15k30kMarginAlgApprx
Random (c) Adressa News
Figure 5: Margin for AlgApprx and Random
45678910
# candidates (n)1k2k3k4k# IP callsAlgExact
Blom
(a) NSW Election
456789101112
# candidates (n)1k2k3k# IP callsAlgExact
Blom (b) MovieLens
45678910
# candidates (n)0.2k0.6k1.0k1.4k# IP callsAlgExact
Blom (c) Adressa News
Figure 6: #IP calls for AlgApprx andAlgExact varying𝑛
4 5 6 7
Maximum ballot size (l)1234Time (s)AlgApprx
AlgExact
Blom(a) Adressa News varying 𝑙
0 10k 20k 30k
# ballots (m)0510Time (s)AlgApprx
AlgExact
Blom (b) Adressa News varying 𝑚
Figure 7: Runtime for AlgApprx, AlgExact, and Blom varying𝑙,𝑚
100k 500k 1000k
# candidates0200400600Time(s)AlgApprx
Random
(a) Synthetic
250 500 750 1000
# candidates012Time(s)AlgApprx
Random (b) MovieLens
20k 60k 100k
# candidates0100200Time(s)AlgApprx
Random (c) Adressa News
Figure 8: Runtime for AlgApprx & Random
 
1207KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
REFERENCES
[1]Sihem Amer-Yahia, Behrooz Omidvar-Tehrani, Senjuti Basu, and Nafiseh Shabib.
2015. Group recommendation with temporal affinities. In International Conference
on Extending Database Technology (EDBT).
[2]Sihem Amer-Yahia, Senjuti Basu Roy, Ashish Chawlat, Gautam Das, and Cong
Yu. 2009. Group recommendation: Semantics and efficiency. Proceedings of the
VLDB Endowment 2, 1 (2009), 754–765.
[3]Anonymous. 2023. Git link. https://anonymous.4open.science/r/selection_
queries_using_irv-5AD0/README.md.
[4]Manel Ayadi, Nahla Ben Amor, Jérôme Lang, and Dominik Peters. 2019. Single
Transferable Vote: Incomplete Knowledge and Communication Issues. In 18th
International Conference on Autonomous Agents and MultiAgent Systems (AAMAS
19). International Foundation for Autonomous Agents and Multiagent Systems,
Montreal QC, Canada, 1288–1296. https://hal.science/hal-02307486
[5]Linas Baltrunas, Tadas Makcinskas, and Francesco Ricci. 2010. Group recommen-
dations with rank aggregation and collaborative filtering. In Proceedings of the
4th ACM Conference on Recommender Systems. 119–126.
[6]John J. Bartholdi and James B. Orlin. 1991. Single transferable vote resists strategic
voting. Social Choice and Welfare 8, 4 (1991), 341–354. http://www.jstor.org/
stable/41105995
[7]Senjuti Basu Roy. 2022. Returning Top-K: Preference Aggregation or Sortition,
or is there a Better Middle Ground? SIGMOD Blog (2022).
[8]Senjuti Basu Roy, Laks VS Lakshmanan, and Rui Liu. 2015. From group rec-
ommendations to group formation. In Proceedings of the 2015 ACM SIGMOD
International Conference on Management of Data. 1603–1616.
[9]Senjuti Basu Roy, Saravanan Thirumuruganathan, Sihem Amer-Yahia, Gautam
Das, and Cong Yu. 2014. Exploiting group recommendation functions for flexible
preferences. In 2014 IEEE 30th International Conference on Data Engineering. IEEE,
412–423.
[10] Rachel Behar and Sara Cohen. 2022. Representative Query Results by Voting. In
Proceedings of the 2022 International Conference on Management of Data. 1741–
1754.
[11] Arnab Bhattacharyya and Palash Dey. 2021. Predicting winner and estimating
margin of victory in elections using sampling. Artificial Intelligence 296 (2021),
103476. https://doi.org/10.1016/j.artint.2021.103476
[12] Michelle Blom, Peter J. Stuckey, and Vanessa J. Teague. 2017. Towards Computing
Victory Margins in STV Elections. arXiv:1703.03511 [cs.GT]
[13] Michelle Blom, Peter J. Stuckey, Vanessa J. Teague, and Ron Tidhar. 2015. Efficient
Computation of Exact IRV Margins. arXiv:1508.04885 [cs.AI]
[14] Da Cao, Xiangnan He, Lianhai Miao, Yahui An, Chao Yang, and Richang Hong.
2018. Attentive group recommendation. In The 41st International ACM SIGIR
Conference on Research & Development in Information Retrieval. 645–654.
[15] David Cary. 2011. Estimating the Margin of Victory for Instant-Runoff Voting.
InConference on Electronic voting technology/workshop on trustworthy elections.
USENIX Association, San Francisco, CA.
[16] Abhijnan Chakraborty, Gourab K Patro, Niloy Ganguly, Krishna P. Gummadi,
and Patrick Loiseau. 2018. Equality of Voice: Towards Fair Representation in
Crowdsourced Top-K Recommendations. arXiv:1811.08690 [cs.SI]
[17] Vincent Conitzer, Tuomas Sandholm, and Jérôme Lang. 2007. When Are Elections
with Few Candidates Hard to Manipulate? J. ACM 54, 3 (Jun 2007), 14:1–14:33.
https://doi.org/10.1145/1236457.1236461
[18] Palash Dey and Y. Narahari. 2015. Estimating the Margin of Victory of an Election
using Sampling. arXiv:1505.00566 [cs.AI]
[19] Peter Emerson. 2013. The original Borda count and partial voting. Social Choice
and Welfare 40 (2013), 353–358.[20] FairVote. 2000–2024. Proportional RCV Information. https://fairvote.org/our-
reforms/proportional-ranked-choice-voting-information/.
[21] Piotr Faliszewski, Piotr Skowron, Arkadii Slinko, and Nimrod Talmon. 2017. Multi-
winner voting: A new challenge for social choice theory. Trends in Computational
Social Choice 74, 2017 (2017), 27–47.
[22] David García-Soriano and Francesco Bonchi. 2021. Maxmin-fair ranking: indi-
vidual fairness under group-fairness constraints. In Proceedings of the 27th ACM
SIGKDD Conference on Knowledge Discovery & Data Mining. 436–446.
[23] Bernard Grofman, Guillermo Owen, and Scott L Feld. 1983. Thirteen theorems
in search of the truth. Theory and Decision 15, 3 (1983), 261–278.
[24] Wm. H. Hare. 1871. Application of Mr. Hare’s System of Voting to the Nomi-
nation of Overseers of Harvard College. Journal of Social Science: Containing
the Transactions of the American Social Science Association 3-4 (1871), 192–198.
https://books.google.com/books?id=W7QRAAAAYAAJ
[25] Steven Hill and Robert Richie. 2005. Success for instant runoff voting in San
Francisco. National Civic Review 94, 1 (2005), 65–69.
[26] Md Mouinul Islam, Dong Wei, Baruch Schieber, and Senjuti Basu Roy. 2022. Satis-
fying complex top-k fairness constraints by preference substitutions. Proceedings
of the VLDB Endowment 16, 2 (2022), 317–329.
[27] Alborz Jelvani and Amelie Marian. 2022. Identifying Possible Winners in Ranked
Choice Voting Elections with Outstanding Ballots. Proceedings of the AAAI
Conference on Human Computation and Crowdsourcing 10, 1 (Oct. 2022), 114–123.
https://doi.org/10.1609/hcomp.v10i1.21992
[28] Jae Kyeong Kim, Hyea Kyeong Kim, Hee Young Oh, and Young U Ryu. 2010. A
group recommendation system for online communities. International Journal of
Information Management 30, 3 (2010), 212–219.
[29] Thomas Magrino, Ronald Rivest, Emily Shen, and David Wagner. 2011. Comput-
ing the margin of victory in IRV elections. In 2011 Electronic Voting Technology
Workshop/Workshop on Trustworthy Elections (EVT/WOTE 11). USENIX Associ-
ation, San Francisco, CA, 4–4. https://www.usenix.org/conference/evtwote-
11/computing-margin-victory-irv-elections
[30] Eamon McGinn. 2020. Rating Rankings: Effect of Instant Run-off Voting on
participation and civility. http://eamonmcginn.com.s3.amazonaws.com/papers/
IRV_in_Minneapolis.pdf
[31] Robert A. Newland. 1972. Only half a democracy. Representation, Journal of
Representative Democracy 12, 49 (1972), 38.
[32] Shmuel Nitzan and Ariel Rubinstein. 1981. A further characterization of Borda
ranking method. Public Choice (1981), 153–158.
[33] Evaggelia Pitoura, Kostas Stefanidis, and Georgia Koutrika. 2022. Fairness in
rankings and recommendations: an overview. The VLDB Journal (2022), 1–28.
[34] Abinash Pujahari and Dilip Singh Sisodia. 2020. Aggregation of preference
relations to enhance the ranking quality of collaborative filtering based group
recommender system. Expert Systems with Applications 156 (2020), 113476. https:
//doi.org/10.1016/j.eswa.2020.113476
[35] Anand D. Sarwate, Stephen Checkoway, and Hovav Shacham. 2012. Risk-Limiting
Audits and the Margin of Victory in Nonplurality Elections. Statistics, Politics
and Policy 3, 3 (December 2012), 29–64. https://doi.org/10.1515/spp-2012-0003
[36] Dong Wei, Md Mouinul Islam, Baruch Schieber, and Senjuti Basu Roy. 2022. Rank
aggregation with proportionate fairness. In Proceedings of the 2022 ACM SIGMOD
International Conference on Management of Data. 262–275.
[37] Lirong Xia. 2012. Computing the Margin of Victory for Various Voting Rules. In
Proceedings of the 13th ACM Conference on Electronic Commerce (EC ’12) (Valencia,
Spain). Association for Computing Machinery, New York, NY, USA, 982–999.
https://doi.org/10.1145/2229012.2229086
[38] Meike Zehlike, Ke Yang, and Julia Stoyanovich. 2021. Fairness in ranking: A
survey. arXiv preprint arXiv:2103.14000 (2021).
 
1208Promoting Fairness and Priority in 𝑘-Winners Selection Using IRV KDD ’24, August 25–29, 2024, Barcelona, Spain
A APPENDIX
A.1 Different Aggregation Mechanisms
Plurality voting. In a plurality voting system, each voter is allowed
to vote for one candidate, and the candidate who receives the most
votes wins, regardless of whether they secure a majority of the votes.
This system is straightforward and easy to understand but can result
in a "winner-takes-all" outcome where the elected representative
may not reflect the preference of the majority of voters. For instance,
in our current example, Zoey wins the plurality vote with just 3
ballots in her favor. However, Zoey is also the least favored choice
of 5 voters, underscoring the system’s limitation in capturing the
majority’s true preference.
Scoring based. In scoring-based voting systems, voters score each
candidate independently on a scale (e.g., 0 to 5 or 1 to 10). The scores
for each candidate are then aggregated to determine the winner.
This system allows voters to express not just a preference order
but also the intensity of their preferences. Examples of scoring-
based voting systems include Range Voting and Approval Voting.
However, when the users provide preferences in a ranked order,
there is no standard way to convert those preferences to scores.
Positional voting. Positional voting systems allow voters to rank
candidates in order of preference. The most common form of po-
sitional voting is the Borda Count, where points are assigned to
positions on the voters’ preference lists. Using the running example,
Gina emerged as the clear winner of Borda Count with a total of
17 points (3 points from Emma, 1 point from Monica, 0 point from
Daniel, 2 points from John, 4 points from Amy, 3 points from Alice,
3 points from Bob, 1 points from Steve.). Gina’s consistent ranking
as a second top choices of many voters secured her victory.
A.2 IRV Properties
IRV is known to satisfy properties [ 16] that other preference aggre-
gation measures are unable to accommodate.
IRV promotes proportional representation for solid coali-
tions. In social choice theory, a solid coalition for a set of candidates
is defined as a set of voters who all rank every candidate in that set
higher than any candidates outside that set. This criterion requires
that if the number of such voters is at least half of the total number
of voters, then one of those candidates from that set must win.
Consider a scenario in which two candidates with similar ide-
ologies compete over the same pool of voters, resulting in divided
votes and potentially allowing a third candidate with a different
ideology that has fewer overall votes to win. IRV fulfills this crite-
rion, whereas plurality voting [ 23] fails to do so. To demonstrate
this property, notice that in our running example, there exists a
solid coalition of voters who like ML (refer to Table 1 which shows
5of the 10users, John, Amy, Alice, Bob, and Steve rank the three
ML candidates Gina, Kim, Sara higher than any other candidate).
Clearly, if user preferences are aggregated using plurality voting,
none of the ML candidates will be returned as the winner since Zoey
has the highest number of first place votes, and will be selected as
the winner. On the contrary, IRV will select Sara as the winner, and
hence it is resistant to the ballot splitting problem.
IRV promotes anti-plurality. In social choice theory, the majority
loser criterion was proposed to evaluate single-winner elections. Itstates that if a majority of voters prefer every other candidate over
a given candidate, then that candidate must not win. IRV fulfills
this criterion [ 16] (as there is a solid coalition for the rest of the
candidates). Indeed, the candidate Zoey is the last choice of 6out
of the 10users (Table 1), and thus IRV will not select it. Contrarily,
plurality voting will select Zoey as the winner. In [ 16] this criterion
is extended to define anti-plurality which requires that no candidate
among the bottom 𝑥%of the ranked choices for the majority of the
voters should be selected. Although not guaranteed, it is empirically
shown in [ 16] that IRV fulfills this extended criterion anti-plurality
frequently.
IRV vs. Plurality Voting. A popular voting mechanism is plurality
voting, that selects that the winner that receives the highest number
of top ranked votes. Using Table 1, note that plurality voting will
choose Laura as the winner among the candidates in DM area,
even though it is clear that between Laura andMolly, the latter is
more preferred by the users. As we will demonstrate later our IRV
based process will indeed choose Molly. Finally, it is known that
finding the margin (the number of ballots that must be substituted
in order to change the original winner [ 18,26,35,37]) for IRV is
NP-hard [13], making IRV less susceptible to manipulation.
IRV vs. Scoring based Voting. Scoring-based voting systems face
challenges in terms of the proportionality of solid coalitions, anti-
plurality, and having the complete preferences of voters in a way
that accurately reflects voter intent. In scoring-based voting sys-
tems, the proportionality of solid coalitions as a strong preference
for a particular candidate can be undermined if voters give nearly
as high scores to other candidates, thus not providing a clear ad-
vantage to the coalition’s preferred candidate. This aspect can also
impact anti-plurality; since voters might give high scores to a can-
didate who is the last choice by the majority of the voters, this can
lead to a winner who is disliked by most. In contrast, IRV upholds
all three of these properties.
IRV vs. Positional Voting. Positional Voting, like the Borda Count,
focuses on selecting the most preferred candidate rather than re-
flecting the depth of support among multiple choices. This may
lead to a winner-takes-all outcome, often favoring the candidate
with the highest first-choice or second-choice support, potentially
disregarding the proportional strength of coalitions. For the same
reason, Positional Voting can select a winner who is the last choice
by the majority of voters. Let’s consider an example where voters
rank five candidates A, B, C, D, and E in order of preference. In
this election, there are 20 votes of preference order {A, D, E, C},
indicating that A is ranked first, followed by D, E, and C; 10 votes of
preference order {B, C, E, A}; and 11 votes of preference order {C, B,
D, A} are cast. Applying the Borda Count, Candidate A accumulates
60 points (20 votes * 3 points), Candidate B, C, D, E accumulates
52, 53, 51 and 30 points respectively. Therefore, under the Borda
Count, Candidate A emerges as the winner with the highest total
points of 60. However, notice there is a solid coalition of B and C
formed by 21 voters (they are preferred by 21 voters, more than
half of voters, than any other candidates). IRV will select one of the
candidates of group B or C. Again, A is the last preference by the
majority of voters (21 voters), yet still wins the election, showing
an anti-plurality scenario.
 
1209KDD ’24, August 25–29, 2024, Barcelona, Spain Md Mouinul Islam, Soroush Vahidi, Baruch Schieber, and Senjuti Basu Roy
A.3 Hardness Results: MqIRV is NP-Complete
Theorem A.1. MqIRVis NP-Complete, even when ℓ=2.
Proof. The hardness proof is by reducing an instance of the
known NP-hard problem 3-Exact Cover problem (3XC) to an in-
stance of MqIRV. Our proof is inspired by the NP-Hardness proof
of [6].
Consider an election in which 𝑚voters need to elect 𝑘=1
candidate out of 𝑛candidates. In the election, each voter casts
his/her ballot for two candidate in ranked order. The final candidate
is determined using the IRV process. For a given instance of the
election, we define the margin as the number of ballot changes
required to ensure that a specific candidate wins.
We prove that computing the margin is NP-Complete. It is straight-
forward that the problem is in NP since the outcome of an IRV
election can be computed in polynomial time. The NP-hardness
is proved by reduction from the 3-Exact Cover problem (3XC). In
this problem, we are given a universal set {𝑒1,...,𝑒 3𝑛}, and𝑚≥𝑛
subsets𝑆1,...,𝑆𝑚of size 3 each. We need to determine whether
there are𝑛sets whose union is the universal set.
Suppose that we are given an instance of the 3XC problem. We
show how to define a related IRV margin problem and then prove
that the IRV has a margin 𝑛if and only if the answer to the respective
3XC problem is Yes.
The IRV problem has 2𝑚+3𝑛+2candidates𝑏1,...,𝑏𝑚,𝑐1,...,𝑐𝑚,
𝑒1,...,𝑒 3𝑛and𝑢,𝑣. We must ensure that 𝑢wins the election. There
are6𝑚+𝑚2+𝑚(𝑚+5)+3𝑛(2𝑚+10)+2𝑚+11+2𝑚+13=
2𝑚2+6𝑚𝑛+15𝑚+30𝑛+24ballots as follows:
•For every𝑖∈[1..𝑚], let𝑆𝑖={𝑒𝑥,𝑒𝑦,𝑒𝑧}. There are 6 ballots
that we call “cover ballots”. These ballots are two of each
[𝑏𝑖,𝑒𝑥],[𝑏𝑖,𝑒𝑦], and[𝑏𝑖,𝑒𝑧]
•For every𝑖∈[1..𝑚]there are𝑚ballots[𝑏𝑖,𝑐𝑖]
•For every𝑖∈[1..𝑚]there are𝑚+5ballots[𝑐𝑖,𝑏𝑖]
•For every𝑖∈[1..3𝑛]there are 2𝑚+10ballots[𝑒𝑖,𝑣]
•There are 2𝑚+11ballots[𝑣,𝑢]
•There are 2𝑚+13ballots[𝑢,𝑣]
Suppose that the 3XC instance has an exact cover. Let the indices
of the sets in the cover be 𝑗1...,𝑗𝑛. We change 𝑛ballots as follows.
For every𝑖∈[1..𝑛]change a ballot[𝑏𝑗𝑖,𝑐𝑗𝑖]to[𝑐𝑗𝑖,𝑏𝑗𝑖].
We successively eliminated all candidates who got the least num-
ber of votes, which is initially 𝑚+5. There are𝑚candidates with this
number of votes: 𝑚−𝑛candidates𝑐𝑥, for𝑥∈[1..𝑚]\{𝑗1...,𝑗𝑛},
and𝑛candidates𝑏𝑥, for𝑥∈{𝑗1...,𝑗𝑛}. As a result of eliminating
the𝑚−𝑛candidates𝑐𝑥, the number of votes of the candidates 𝑏𝑥,
for𝑥∈[1..𝑚]\{𝑗1...,𝑗𝑛}jumps to 2𝑚+11. As a result of elimi-
nating the𝑛candidates𝑏𝑥, the number of votes of the candidates
𝑐𝑥, for𝑥∈{𝑗1...,𝑗𝑛}, jumps to 2𝑚+5. Also, since the union of
the𝑛sets𝑆𝑥,𝑥∈{𝑗1...,𝑗𝑛}, is the universal set, the elimination
of𝑏𝑥in the 6𝑛“cover ballots” causes the number of votes of every
𝑒𝑖to jump to 2𝑚+12.
Next, the𝑛remaining candidates 𝑐𝑥, for𝑥∈{𝑗1...,𝑗𝑛}, with
2𝑚+5votes are eliminated. This does not change the vote ofany other candidate. Lastly, the 𝑚−𝑛candidates𝑏𝑥, for𝑥∈
[1..𝑚]\{𝑗1...,𝑗𝑛}, and𝑣each with 2𝑚+11votes are eliminated.
None of the 𝑒𝑖is eliminated at this point because all of them have
2𝑚+12votes. Then, all 𝑒𝑖s will be deleted, each with 2𝑚+12votes,
and, finally, 𝑢wins with 2𝑚+11+2𝑚+13=4𝑚+24votes.
We need to prove the other direction. Namely, if the margin
is𝑛then there is an exact cover. Suppose that the outcome of
the elections can be changed to be 𝑢by at most𝑛ballot changes.
Since candidate 𝑣has one more vote than each of the 3𝑛candi-
dates𝑒1,...,𝑒 3𝑛, we need to increase the votes of all the candidates
𝑒1,...,𝑒 3𝑛by at least 2 so that none of the 𝑒𝑖is eliminated before 𝑣is
eliminated. Because if any of 𝑒𝑖s is eliminated before 𝑣is eliminated,
then the second choice of 𝑒𝑖’s ballot goes to 𝑣and the votes of 𝑣
increase to 4𝑚+21. Then all 𝑒𝑖and𝑢will be eliminated, and 𝑣wins
the election, and 𝑢loses. The only way to ensure that none of 𝑒𝑖s
is eliminated before 𝑣is by eliminating some of the candidates 𝑏𝑗.
This can be done by ballot changes that reduce the number of votes
of some of the candidates 𝑏𝑗by 1 and increase the number of votes
of the respective candidates 𝑐𝑗. This will cause some candidates
𝑏𝑗to be eliminated and thus increase the votes of the resulting
elements𝑒𝑖in the “cover ballots” corresponding to these candidates
𝑏𝑗. Since we can make only 𝑛ballot changes and since the cover
ballots of any candidate 𝑏𝑗change the votes of only the 3 candidates
from{𝑒1,...,𝑒 3𝑛}that correspond to the set 𝑆𝑗, the𝑛candidates
𝑏𝑗eliminated first must correspond to an exact set. □
A.4 Figures
[0] 
, 
lb=0.0
[1,0] 
, 
lb=1.0
[5, 
1, 
0] 
, 
lb=1.0
[4, 
2, 
3, 
5, 
1, 
0] 
, 
lb=1.0
[4, 
2, 
3, 
5, 
1, 
0] 
, 
lb=1.0
[6, 
4, 
2, 
3, 
5, 
1, 
0] 
, 
lb=1.0
[6,0] 
, 
lb=0
[4,6,0] 
, 
lb=3.0
[5] 
, 
lb=1.0
[0,5] 
, 
lb=3.0
[3,5] 
, 
lb=1.0
[0,3,5] 
, 
lb=3.0
[1,3,5] 
, 
lb=4.0
ub=2
ub=2
ub=2
ub=2
ub=2
ub=2
ub=2
ub=2
ub=2
...
...
ub=2
ub=2
[ 
], 
lb=0
...  
...  
...
Figure 9: Partially explored tree for AlgExact , the
candidates are represented with their ids, where red nodes
and their subtrees are pruned
 
1210