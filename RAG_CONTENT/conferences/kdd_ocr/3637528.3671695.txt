QSketch: An Efficient Sketch for Weighted Cardinality Estimation
in Streams
Yiyan Qi∗
International Digital Economy
Academy (IDEA)
Shenzhen, China
qiyiyan@idea.edu.cnRundong Li∗
MOE KLINNS Lab
Xi’an Jiaotong University
Xi’an, China
xjtulirundong@stu.xjtu.edu.cnPinghui Wang‡
MOE KLINNS Lab
Xi’an Jiaotong University
Xi’an, China
phwang@xjtu.edu.cn
Yufang Sun
MOE KLINNS Lab
Xi’an Jiaotong University
Xi’an, China
sunyufang00@stu.xjtu.edu.cnRui Xing
MOE KLINNS Lab
Xi’an Jiaotong University
Xi’an, China
xingrui128719@163.com
ABSTRACT
Estimating cardinality, i.e., the number of distinct elements, of a
data stream is a fundamental problem in areas like databases, com-
puter networks, and information retrieval. This study delves into
a broader scenario where each element carries a positive weight.
Unlike traditional cardinality estimation, limited research exists
on weighted cardinality, with current methods requiring substan-
tial memory and computational resources, challenging for devices
with limited capabilities and real-time applications like anomaly
detection. To address these issues, we propose QSketch, a memory-
efficient sketch method for estimating weighted cardinality in
streams. QSketch uses a quantization technique to condense con-
tinuous variables into a compact set of integer variables, with each
variable requiring only 8 bits, making it 8 times smaller than previ-
ous methods. Furthermore, we leverage dynamic properties during
QSketch generation to significantly enhance estimation accuracy
and achieve a lower time complexity of 𝑂(1)for updating estima-
tions upon encountering a new element. Experimental results on
synthetic and real-world datasets show that QSketch is approxi-
mately 30% more accurate and two orders of magnitude faster than
the state-of-the-art, using only 1/8of the memory.
CCS CONCEPTS
•Theory of computation →Sketching and sampling; •Infor-
mation systems→Data stream mining.
KEYWORDS
Streaming algorithms, Sketch, Weighted Cardinality Estimation
∗Equal Contribution.
‡Corresponding Author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671695ACM Reference Format:
Yiyan Qi∗, Rundong Li∗, Pinghui Wang‡, Yufang Sun, and Rui Xing. 2024. QS-
ketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams.
InProceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery
and Data Mining (KDD ’24), August 25–29, 2024, Barcelona, Spain. ACM, New
York, NY, USA, 12 pages. https://doi.org/10.1145/3637528.3671695
1 INTRODUCTION
Real-world systems generate data in a streaming fashion. Exam-
ples range from financial transactions to Internet of Things (IoT)
data, network traffic, call logs, trajectory logs, etc. Computing the
cardinality, i.e., the number of distinct elements, of such a stream
is fundamental in research areas like databases, machine learning,
and information retrieval. For example, online games and mobile
apps usually use daily active users (DAU), i.e., the number of dis-
tinct active users within a day, as a metric to measure the level of
engagement. Other examples include network security monitoring
[14] and connectivity analysis in the Internet graph [32].
Due to the unknown or even unlimited size and the high-speed
nature of these data streams, it is infeasible to collect the entire data
when the computation and memory resources of data collection
devices (e.g., network routers) are limited. To solve this challenge,
considerable attention has been paid to designing fast and memory-
efficient cardinality estimating algorithms via sketching techniques
[13,17,20,40]. They build a compact data summary (i.e., sketch) on
the fly and then estimate the cardinality from the generated sketch.
The above cardinality computing problem can be generalized to
a weighted scenario, where each element ein the data stream is
associated with a positive weight 𝑤∈R+. In this new scenario, the
goal is to compute the total sum of weights for all distinct elements,
i.e., weighted cardinality. The weighted cardinality has various
applications, including 1) In database systems, an example is a SQL
query like “SELECT DISTINCT * FROM TABLE”. In addition to the
query’s cardinality, understanding the total size of the resultant set
aids in optimizing performance and managing resources [ 30,31].
Here, the weighted cardinality represents the total size (in bytes)
of the query result, calculated as the cumulative size of all distinct
records, weighted by their row size. 2) In a voting system, each
voter may have a weight based on their expertise and we need it to
figure out the final voting result. 3) In an app or website, users with
 
2432
KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
more activity might be assigned higher weights. This metric allows
for a more nuanced understanding of the app other than Daily
Active User (DAU). Weighted cardinality computation is important
in scenarios where individual contributions vary in importance.
Despite the plenty of works for estimating the regular cardi-
nality, little attention has been paid to the problem of Weighted
Cardinality Estimation (WCE). Lemiesz [ 26] conducts a formal
study on the WCE problem. The proposed method maps each ele-
ment in the data stream into 𝑚exponential variables concerning
the element’s weight. To guarantee estimation accuracy, 𝑚is set to
hundreds or thousands, making it infeasible to deal with real-time
streams. Zhang et al. [ 45] proposed a method FastGM to decrease
the update time complexity of Lemiesz’s method. Instead of generat-
ing𝑚variables independently, FastGM generates those exponential
variables in ascending order and early stops the generation when
the value is greater than the maximal value stored in the current
registers. A recent method FastExp Sketch [ 27] shares the same idea
with FastGM. The above three methods use 64-bit floating-point reg-
isters to store these exponential variables. When a large value of 𝑚is
employed for improved accuracy, it becomes memory-intensive for
devices with limited computational and storage resources. Addition-
ally, they require 𝑂(𝑚)operations to estimate weighted cardinality,
making them computationally expensive when aiming to provide
anytime-available estimation for real-time applications.
We develop a memory-efficient sketch, QSketch, to estimate the
weighted cardinality of distinct elements in a data stream. QSketch
generates𝑚independent exponential variables for each incoming
element in descending order. This process is employed to update the
𝑚integer registers, and an early termination occurs when a gen-
erated variable is smaller than the values in all registers. QSketch
employs a novel mapping strategy that transforms continuous expo-
nential variables into discrete variables, using a small set of integer
registers to represent data streams with varying weighted cardinal-
ities. Consequently, each register in our QSketch requires no more
than 5bits, making it up to 13×smaller than both Lemiesz’s method
and FastGM. To reduce time cost and estimation error, we propose
an extension of QSketch, QSketch-Dyn, to monitor the weighted car-
dinality on the fly. QSketch-Dyn shares the same data structure as
QSketch but only needs to compute one variable for each element. It
utilizes the dynamic property of our QSketch to reduce estimation
error significantly. We summarize our main contributions as:
•We propose a memory-efficient sketch method QSketch to es-
timate the weighted cardinality of distinct elements in a data
stream. QSketch employs a novel mapping strategy that trans-
forms continuous exponential variables into discrete variables,
using a small set of integer registers to represent data streams
with varying weighted cardinalities.
•We also present QSketch-Dyn, an advanced variant of QSketch,
which leverages the inherent dynamic nature of QSketch, en-
abling real-time tracking of weighted cardinality.
•We conduct experiments on both synthetic and real-world datasets.
The experimental results demonstrate that our new sketching
method achieves approximately 30% more accurate and is two or-
ders of magnitude faster than the state-of-the-art while requiring
only 1/8 of the memory usage.Algorithm 1: Pseudo-code of Lemiesz’s method.
input : stream Π,𝑚.
output: sketch𝑅.
1𝑅←[+∞,...,+∞];
2foreach(𝑥,𝑤)∈Πdo
3 sfor𝑗=1,...,𝑚 do
4𝑟𝑗←−lnℎ𝑗(𝑥)
𝑤;
5𝑅[𝑗]← min(𝑅[𝑗],𝑟𝑗);
The rest of this paper is organized as follows. Section 2 introduces
the problem. Section 3 briefly discusses preliminaries. Section 4
presents our method QSketch and QSketch-Dyn. The performance
evaluation and testing results are presented in Section 5. Section 6
summarizes related work. Concluding remarks then follow.
2 PROBLEM FORMULATION
We first introduce some notations. Let Π=e(1)···e(𝑡)···denote
a data stream, where an element e(𝑡)arriving at time 𝑡corresponds
to one of the elements 𝑥1,...,𝑥𝑛and each𝑥𝑖,1≤𝑖≤𝑛has a
positive weight 𝑤𝑖>0. Note that an element emay appear multiple
times in the stream. Denote 𝑁(𝑡)
Πas the set of distinct elements
that occurred in stream Πbefore and including time 𝑡. Then, the
weighted cardinality of stream Πat𝑡is defined as
𝐶(𝑡)=∑︁
𝑥𝑖∈𝑁(𝑡)
Π𝑤𝑖. (1)
This paper aims to develop a sketch method to estimate the weighted
cardinality𝐶(𝑡)accurately and efficiently. We omit the superscript
(𝑡)when no confusion arises.
3 PRELIMINARIES
In this section, we introduce two existing methods to estimate
weighted cardinality and discuss their shortcomings.
3.1 Existing Methods For WCE
•Lemiesz’s Method [26] builds a sketch consisting of 𝑚registers
𝑅[1],...,𝑅[𝑚]. Typically,𝑚is set to be thousands to guarantee the
desired accuracy. All 𝑚registers are initialized to +∞. For each
𝑗∈{1,...,𝑚}, let𝑅(𝑡)[𝑗]denote the value of 𝑅[𝑗]at time𝑡. For
each e(𝑡)arriving at time 𝑡, Lemiesz’s method maps it into all 𝑚
registers independently and each register is updated as
𝑅(𝑡)[𝑗]← min(𝑅(𝑡−1)[𝑗],𝑟𝑗(e(𝑡))).
Without loss of generality, we let e(𝑡)=𝑥𝑖with weight 𝑤𝑖,1≤𝑖≤
𝑛. In the above equation, 𝑟𝑗(e(𝑡))is defined as
𝑟𝑗(e(𝑡))=−lnℎ𝑗(𝑥𝑖)
𝑤𝑖,
whereℎ𝑗(𝑥)is a hash function that maps 𝑥to(0,1)uniformly, i.e.,
ℎ𝑗(𝑥)∼Uniform(0,1),1≤𝑗≤𝑚. The pseudo-code of Lemiesz’s
method is shown in Algorithm 1. We note that 𝑟𝑗(e(𝑡))follows an
exponential distribution EXP(𝑤(𝑡))and𝑅(𝑡)[𝑗]=min
𝑥𝑖∈𝑁(𝑡)
Π𝑟𝑗(𝑥𝑖)
 
2433QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD ’24, August 25–29, 2024, Barcelona, Spain
follows an exponential distribution EXP(𝐶(𝑡)), in which𝐶(𝑡)is
the weighted cardinality at time 𝑡. Thus, the summation variable
𝐺𝑚=Í𝑚
𝑗=1𝑅(𝑡)[𝑗]follows a gamma distribution 𝐺𝑚∼Γ(𝑚,𝐶(𝑡)).
According to [ 41], the inverse of the summation variable 𝐺𝑚, i.e.,
1/𝐺𝑚, has the inverse gamma distribution 1/𝐺𝑚∼Γ−1(𝑚,𝐶(𝑡)),
and we have
E[1/𝐺𝑚]=𝐶(𝑡)
𝑚−1,Var[1/𝐺𝑚]=(𝐶(𝑡))2
(𝑚−2)(𝑚−1)2,
where the first equation holds for 𝑚≥2and second for 𝑚≥3.
Then at time 𝑡, Lemiesz gives an unbiased estimator of 𝐶(𝑡)as
ˆ𝐶(𝑡)=𝑚−1Í𝑚
𝑗=1𝑅(𝑡)[𝑗]. (2)
The above estimator’s variance is computed as
Var[ˆ𝐶(𝑡)/𝐶(𝑡)]=1
𝑚−2.
•FastGM. Lemiesz’s method needs 𝑂(𝑚)time to update an element
In practice, 𝑚is usually thousands to achieve the expected accu-
racy and is infeasible for high-speed streams. To solve this problem,
Zhang et al. [ 45] proposed FastGM, reducing the time complexity
from𝑂(𝑚)to𝑂(1). FastGM shares the same sketch structure as
Lemiesz’s method. The difference is that 𝑚random variables in
FastGM−lnℎ1(𝑥𝑖)
𝑤𝑖,...,−lnℎ𝑚(𝑥𝑖)
𝑤𝑖are generated in ascending or-
der as
−lnℎ𝜋1(𝑥𝑖)
𝑤𝑖,𝜋1
,...,
−lnℎ𝜋𝑚(𝑥𝑖)
𝑤𝑖,𝜋𝑚
, where−lnℎ𝜋1(𝑥𝑖)
𝑤𝑖<
···<−lnℎ𝜋𝑚(𝑥𝑖)
𝑤𝑖and𝜋1,...,𝜋𝑚is a random permutation of inte-
gers 1,...,𝑚 . Once the current obtained random variable −lnℎ𝑗1(𝑥𝑖)
𝑤𝑖
is larger than all values in registers 𝑅(𝑡)[1],...,𝑅(𝑡)[𝑚], there is
no need to generate the following random variables because they
have no chance to change the sketch. In detail, for each e(𝑡)=𝑥𝑖,
1≤𝑖≤𝑛, FastGM generates the first exponential variable as
𝑟𝜋1(e(𝑡))=−1
𝑚·lnℎ𝜋1(𝑥𝑖)
𝑤𝑖, (3)
and the following exponential variables 𝑟𝜋𝑗(e(𝑡)),2≤𝑗≤𝑚are
generated in ascending order as
𝑟𝜋𝑗(e(𝑡))=𝑟𝜋𝑗−1(e(𝑡))−1
𝑚−𝑗+1·lnℎ𝜋𝑗(𝑥𝑖)
𝑤𝑖. (4)
After generating a hash value 𝑟𝜋𝑗(e(𝑡)),𝑗∈{1,...,𝑚}, FastGM
uses the Fisher-Yates shuffle [ 15] to find its position 𝜋𝑗∈{1,...,𝑚}.
Specially, let(𝜋1,...,𝜋𝑚)be initialized to(1,...,𝑚). To obtain the
position of the 𝑗-th smallest hash value, FastGM randomly chooses a
position𝑘∈{𝑗,𝑗+1,...,𝑚}, swaps𝜋𝑘and𝜋𝑗, and updates 𝑅(𝑡)[𝜋𝑗]
with𝑟𝜋𝑗(e(𝑡)). FastGM uses an extra register 𝑟∗to perform an early
stop to record the maximal values among 𝑚registers. Register
values in FastGM follow the same distribution as LM. They share
the same weighted cardinality estimator and the same estimation
errors. Besides, we find that a recent method FastExpSketch [ 27]
shares the same idea with FastGM.
3.2 Limitations of Existing Methods
•Memory-consuming. Lemiesz’s method and FastGM use 32-
bit or 64-bit floating-point registers to store hash variables. They
require 32𝑚or64𝑚bits of memory to store 𝑚hash variables for
0 1 2 4
0 -1 1 2… -2…FastGM
QSketch
  2
  1
  -1
  -2Figure 1: Basic idea of QSketch
a stream Π. When we need a large 𝑚for better accuracy or there
are many different streams, it is memory-intensive for devices (e.g.
IoT devices or routers) with limited computational and storage
resources. Therefore, reducing the number of bits for each register
is practical, saving storage space and improving the computational
efficiency for sketch operations [26, 29].
•Time-consuming. Lemiesz’s method requires updating each
register for element insertion, incurring an 𝑂(𝑚)time cost. While
FastGM improves upon this by ordering register updates, it still de-
mands𝑂(𝑚)time in the worst-case scenario when element weights
grow over time. Furthermore, the time complexity for the estimation
process in both methods is quantified as 𝑂(𝑚). Such a computa-
tional demand poses challenges for providing consistent, real-time
estimations in applications that require immediate data availability.
4 OUR METHOD
In this section, we first introduce a compact sketch QSketch (Quan-
tization Sketch) which utilizes the quantization technique (i.e.,
mapping continuous infinite values to a small set of discrete values).
We design a novel estimator to estimate weighted cardinality. Then,
we exploit the dynamic properties of the register arrays over time
to significantly improve the estimation accuracy and reduce the
time cost to monitor the weighted cardinality on the fly.
4.1 Basic Idea
QSketch reduces the size of 32-bit or 64-bit floating-point registers
to a smaller bit size (5 or 6 bits) through quantization. This process
transforms an infinite range of continuous values into a limited set
of discrete values. Figure 1 illustrates how QSketch’s hash value
mappings compare to those in FastGM and Lemiesz’s method.
4.2 QSketch
Data structure and update procedure. Denote𝑅as the sketch
with𝑚registers𝑅[1],...,𝑅[𝑚], andℎ1,...,ℎ𝑚as𝑚independent
hash functions, each of them mapping 𝑥to a random value in range
(0,1)uniformly, i.e., ℎ𝑗(𝑥) ∼ Uniform(0,1),1≤𝑗≤𝑘. When
inserting ewhich is associated with i 𝑥and weight𝑤, we generate
𝑚variables𝑦1(e),...,𝑦𝑚(e)as
𝑦𝑗(e)=⌊−log2(𝑟𝑗(e))⌋, (5)
where𝑟𝑗(e)=−lnℎ𝑗(𝑥)
𝑤is an exponential random variable and ⌊·⌋
is the round-down operation. Then QSketch updates as
𝑅[𝑗]← max(𝑅[𝑗],𝑦𝑗(e)). (6)
Following [ 45], we generate 𝑚variables𝑟𝜋1(e),...,𝑟𝜋𝑚(e)in an
ascending order, in which (𝜋1,...,𝜋𝑚)is a random permutation
of(1,...,𝑚). As a result, 𝑦𝜋1(e), ...,𝑦𝜋𝑚(e)are generated in a
descending order. The update procedure is shown in Algorithm 2.
We use the Fisher-Yates shuffle [ 15] (Line 11-12 in Algorithm 2)
to quickly find the position to be updated and use 𝑗∗to record
 
2434KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
Algorithm 2: Update procedure of QSketch.
input : stream Π, sketch size 𝑚, register size 𝑏.
output: sketch𝑅.
1𝑟min←−2𝑏−1+1;𝑟max←2𝑏−1−1;
2𝑈←[𝑟min,...,𝑟 min];𝑗∗←1;
3foreach e∈Πdo
/* element 𝑥with weight 𝑤. */
4[𝜋1,...,𝜋𝑚]←[ 1,...,𝑚];
5𝑟←0;
6 for𝑗=1,...,𝑚 do
7𝑟←𝑟−lnℎ𝑗(𝑥)
𝑤(𝑚−𝑗+1);
8𝑦←⌊− log2(𝑟)⌋;
9 if𝑦≤𝑅[𝑗∗]then
/* early stop */
10 break ;
11𝑘←RandInt(𝑗,𝑚);
12 Swap(𝜋𝑘,𝜋𝑗);
13 if𝑦>𝑅[𝜋𝑙]then
14 𝑅[𝜋𝑙]=min(max(𝑦,𝑟min),𝑟max);
15 if𝜋𝑙=𝑗∗then
16 𝑗∗←arg min𝑗=1,...,𝑚𝑅[𝑗];
the register’s index that records the sketch’s minimum values. A
brief introduction to the Fisher-Yates shuffle is in Appendix A.1.
When the generated variable is smaller than 𝑅[𝑗∗], we early stop
the generation procedure.
Weighted Cardinality Estimation. Direct use of the estimator in
Equation (2) yields a large estimation error since the quantization
leads to a loss of precision. Instead, we design a new estimator
with the help of Maximum Likelihood Estimation (MLE). Before
that, we first derive the probability distribution of a single register
𝑅[𝑗],1≤𝑗≤𝑚. It has been proved that a register value 𝑅(without
quantization) follows an exponential distribution EXP(𝐶Π)[26,45],
in which𝐶Πis the weighted cardinality of stream Π. In QSketch,
according to Equation (5), we quantize the continuous register value
to discrete values. Particularly, continuous register values in the
range(2−(𝑟+1),2−𝑟]will be compressed into a discrete value 𝑟.
Then the probability distribution of a single register value 𝑅[𝑖]is
𝑃𝑟(𝑅[𝑗]=𝑟|𝐶Π)=∫2−𝑟
2−(𝑟+1)𝐶Π𝑒−𝐶Π𝑥𝑑𝑥
=𝑒−𝐶Π·2−(𝑟+1)−𝑒−𝐶Π·2−𝑟.(7)
Given the specific register values 𝑅[1],...,𝑅[𝑚], we compute the
likelihood function for 𝐶Πis
𝐿(𝐶Π)=𝑚Ö
𝑗=1𝑃𝑟(𝑅[𝑗]|𝐶Π)=𝑚Ö
𝑗=1
𝑒−𝐶Π·2−(𝑅[𝑗]+1)−𝑒−𝐶Π·2−𝑅[𝑗]
,
(8)and the derivative of the likelihood function’s logarithm is:
𝑑(ln𝐿(𝐶Π))
𝑑𝐶Π=𝑚∑︁
𝑗=12−(𝑅[𝑗]+1)·2−𝑒𝐶Π·2−(𝑅[𝑗]+1)
𝑒𝐶Π·2−(𝑅[𝑗]+1)−1. (9)
To compute the MLE of 𝐶Π, let the above formula equal 0. Unfortu-
nately, this equation is too complicated to be solved directly. So we
use the Newton-Raphson method to obtain ˆ𝐶Π. Specially, let
𝑓(𝐶Π)=𝑚∑︁
𝑗=12−(𝑅[𝑗]+1)·2−𝑒𝐶Π·2−(𝑅[𝑗]+1)
𝑒𝐶Π·2−(𝑅[𝑗]+1)−1, (10)
The Newton-Raphson method [ 5] starts from an initial estimation
ˆ𝐶(0)
Πand then repeats the following steps:
ˆ𝐶(𝑙+1)
Π←ˆ𝐶(𝑙)
Π−𝑓(ˆ𝐶(𝑙)
Π)
𝑓′(ˆ𝐶(𝑙)
Π), (11)
until ˆ𝐶Πconverges, where 𝑓′(ˆ𝐶(𝑙)
Π)is the derivative of 𝑓(𝐶Π)at
point𝐶Π=ˆ𝐶(𝑙)
Π. To start the iteration, we initialize ˆ𝐶(0)
Πas
ˆ𝐶(0)
Π=𝑚−1Í
1≤𝑗≤𝑚2−𝑅[𝑗].
Since the register values in QSketch are the quantization of register
values in FastGM, ˆ𝐶(0)
Πcan be viewed as an approximation of ˆ𝐶Π,
which is reasonable as an initial value to guarantee convergence.
The above MLE-based estimator provides an asymptotically un-
biased estimation. The approximate variance of the above estima-
tor is based on the Cramér-Rao bound [ 12]. Specifically, we have
Var[ˆ𝐶]≈1
𝐼Π(ˆ𝐶), where𝐼Π(ˆ𝐶)is the observed fisher information
given stream data Π, i.e., the negative of the second derivative of
the log-likelihood function at ˆ𝐶. Formally, we have
Var[ˆ𝐶]≈−1
𝑓′(ˆ𝐶(𝑙)
Π).
Through the quantization, all possible values of 𝑦(e)are integers,
i.e.,𝑦(e)∈Z. In practice, we notice that most values of 𝑦(e)are
concentrated in a small range and we can truncate these gener-
ated variables by 𝑦′(e)=min(max(𝑦(e),𝑟min),𝑟max). As a result,
adjusting the probability distribution of the truncated value in each
register is necessary, as shown in Equation (7).
𝑃𝑟(𝑅[𝑗]|𝐶Π)= 
𝑒−𝐶Π·2−(𝑟min+1), 𝑅[𝑗]≤𝑟min;
1−𝑒−𝐶Π·2−𝑟max, 𝑅[𝑗]≥𝑟max;
𝑒−𝐶Π·2−(𝑅[𝑗]+1)−𝑒−𝐶Π·2−𝑅[𝑗],otherwise.
By substituting the above probability to Equation (8), we get the
weighted cardinality estimator under truncated values. Note that
the estimator only fails to give an unbiased estimation when all
register values equal 𝑟minor𝑟maxas the likelihood function 𝐿(𝐶Π)
becomes monotonous without an extremum. Fortunately, in the
following theorem, we show that by properly setting 𝑟minand𝑟max,
the failure probability is extremely low.
Theorem 1.Let0<𝜀≪1be a small positive value. Given a
sketch of𝑚registers with minimal value 𝑟minand maximal value
𝑟max, when−2(𝑟min+1)·ln𝜖<𝐶Π<−2𝑟maxln(1−𝜖), the register
 
2435QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD ’24, August 25–29, 2024, Barcelona, Spain
values are not in the discrete set {𝑟min,...,𝑟 max}within a maximum
probability of 2𝜖.
The proof is in Appendix A.2. When 𝑟min=−127,𝑟max=127,
and𝜀=0.001, each register value at time 𝑡is not tuncatated with a
probability of more than 0.998when 8.1×10−38≤𝐶Π≤3.4×1035.
In this case, we need just 8bits to store the register values.
4.3 QSketch-Dyn
QSketch has the same expected time complexity of 𝑂(𝑚·ln𝑚+𝑛)
as FastGM [ 33,45]. However, it still suffers from the worst time
complexity𝑂(𝑚·𝑛)under scenarios in which the weights of the ele-
ments increase as time progresses. In addition, we have to solve the
MLE problem whenever figuring out the latest weighted cardinality,
which costs for real-time estimation. To improve the estimation ef-
ficiency, we utilize the dynamic property of the sketch and propose
QSketch-Dyn to keep track of the weighted cardinality on the fly.
Data structure and update procedure. QSketch-Dyn shares the
same data structure, i.e., a bit array of size 𝑚, and the same set
of hash functions ℎ1,...,ℎ𝑚as Lemiesz’s method [ 26]. The main
differences are: 1) QSketch-Dyn introduces another hash function
𝑔(𝑥), which uniformly maps 𝑥to some integer in set {1,...,𝑚}
at random. 2) QSketch-Dyn maintains a tabular 𝑇to record the
frequency of values in the sketch. Specifically, the tabular 𝑇consists
of2𝑏counters, in which 𝑏is the number of bits used by a register.
Next, we introduce how to update an element e(𝑡)correspond-
ing to𝑥and𝑤. Instead of updating multiple register values as in
other methods, QSketch-Dyn first randomly chooses one register
𝑅[𝑗]with𝑗=𝑔(𝑥),1≤𝑗≤𝑚from the sketch, computes its
quantized hash value 𝑦𝑗(e)=⌊−log2(𝑟𝑗(e))⌋(Equation 5), and
update the register value 𝑅[𝑗]← max(𝑅[𝑗],𝑦𝑗(e))(Equation 6).
Once the register value 𝑅[𝑗]changes, we then update the tabular
𝑇as𝑇[𝑅[𝑗]]←𝑇[𝑅[𝑗]]− 1and𝑇[𝑦𝑗(e)]←𝑇[𝑦𝑗(e)]+ 1.
Weighted Cardinality Estimation. Denote𝑞(𝑡)
𝑅as the probability
ofe(𝑡)changing a register among 𝑅[1],...,𝑅[𝑚]at time𝑡,
𝑞(𝑡)
𝑅≜∑︁
1≤𝑗≤𝑚𝑃𝑟(𝑦>𝑅[𝑗]∧𝑔(𝑥)=𝑗|𝑅[𝑗])
=∑︁
1≤𝑗≤𝑚𝑃𝑟(𝑦≥𝑅[𝑗]+1|𝑅[𝑗])·𝑃𝑟(𝑔(𝑥)=𝑗)
=1
𝑚·∑︁
1≤𝑗≤𝑚∫2−(𝑅[𝑗]+1)
0𝑤·𝑒−𝑤𝑥𝑑𝑥
=1−1
𝑚∑︁
1≤𝑗≤𝑚𝑒−𝑤·(2−(𝑅[𝑗]+1)).
Letˆ𝐶(𝑡)
Πdenote the weighted cardinality estimate of stream Πat
time𝑡. When element earrives at time 𝑡, we update the weighted
cardinality estimate as
ˆ𝐶(𝑡)
Π←ˆ𝐶(𝑡−1)
Π+1(𝑅[𝑗](𝑡)≠𝑅[𝑗](𝑡−1))
𝑞(𝑡)
𝑅·𝑤, (12)
in which 1(𝑅[𝑗](𝑡)≠𝑅[𝑗](𝑡−1))is an indicator variable which
equals to 1 if element echanges the register value 𝑅[𝑗](remind
that𝑗=𝑔(𝑥)) and equals to 0 otherwise. In later analysis, we will
prove that ˆ𝐶(𝑡)
Πis an unbiased estimation of 𝐶(𝑡)
Π.Algorithm 3: Update procedure of QSketch-Dyn.
input : stream Π, sketch size 𝑚, register size 𝑏.
output: Estimated weighted cardinality ˆ𝐶.
1𝑟←0;𝑞𝑅←0;ˆ𝐶←0;
2𝑅←[𝑟min,...,𝑟 min];𝑇←[0,0,..., 0];
3foreach e∈Πdo
/* corresponding to element 𝑥with weight 𝑤.
*/
4𝑗←RandInt(1,𝑚);
5𝑟←−lnℎ𝑗(𝑥)
𝑤;
6𝑦←⌊− log2(𝑟)⌋;
7 if𝑦>𝑅[𝑗]then
8 if𝑇[𝑅[𝑗]−𝑟min]>0then
9 𝑇[𝑅[𝑗]−𝑟min]←𝑇[𝑅[𝑗]−𝑟min]−1;
10 𝑇[𝑦−𝑟min]←𝑇[𝑦−𝑟min]+1;
11 else
12 𝑇[𝑦−𝑟min]←𝑇[𝑦−𝑟min]+1;
13𝑅[𝑗]← min(𝑦,𝑟max);
14𝑞←0;
15 for𝑘=0,..., 2𝑏−1do
16 𝑞←𝑞+𝑇[𝑘]·𝑒−𝑤·2−(𝑘+𝑟min+1);
17𝑞𝑅=1−𝑞
𝑚;
18 ˆ𝐶←ˆ𝐶+𝑤
𝑞𝑅;
The computation of probability 𝑞(𝑡)
𝑅needs summation over all 𝑚
registers, which is time-consuming when 𝑚is set to a large value.
To save time, we additionally maintain a tabular 𝑇recording the
histogram of register values as mentioned above, where 𝑇[𝑅[𝑗]]
tracks the count of value 𝑅[𝑗]in the current sketch. As discussed
previously, each register occupies 𝑏bits and the number of different
values is at most 2𝑏. Then,𝑞(𝑡)
𝑅is expressed as
𝑞(𝑡)
𝑅=1−1
𝑚∑︁
1≤𝑗≤2𝑏𝑇[𝑅[𝑗]]·𝑒−𝑤·(2−(𝑅[𝑗]+1)).
We summarize the pseudo-code of the update and estimation pro-
cedure of QSketch-Dyn in Algorithm 3.
Complexity Analysis. The time complexity of updating an ele-
ment for QSketch-Dyn is 𝑂(1)since it only chooses one register
to update its value. Then it costs 𝑂(2𝑏)time for QSketch-Dyn to
compute𝑞(𝑡)
𝑅. Considering that 𝑏is small, this part costs little time.
Finally, QSketch-Dyn tracks the estimated cardinality over time,
and it costs no time for estimation compared with QSketch. For
space complexity, QSketch uses 𝑚registers, in which each register
occupies𝑏bits. Besides, QSketch-Dyn maintains a tabular 𝑇with 2𝑏
counters. Since there are 𝑚registers in the sketch, each counter of
tabular𝑇occupies at most log2(𝑚)bits. Therefore, the total space
complexity is 𝑚·𝑏+2𝑏·log2(𝑚).
Error Analysis. For the estimated weighted cardinality ˆ𝐶(𝑡)
Πfrom
QSketch-Dyn, we first prove that our estimator is unbiased and
then derive the variance of ˆ𝐶(𝑡)
Π.
 
2436KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
Table 1: Statistics of real-world datasets.
Dataset #Documents Vector Size
Real-sim [39] 72,309 20,958
Rcv1 [28] 20,242 47,236
Webspam [36] 350,000 16,609,143
News20 [24] 19,996 1,355,191
Libimseti [25] 220,970 220,970
Theorem 2.The expectation and variance of ˆ𝐶(𝑡)
Πare
E[ˆ𝐶(𝑡)
Π]=𝐶(𝑡)
Π,
Var[ˆ𝐶(𝑡)
Π]=∑︁
𝑖∈𝑇(𝑡)
𝑠(𝑤(𝑖))2E[1−𝑞(𝑖)
𝑅
𝑞(𝑖)
𝑅],
where𝑇(𝑡)
𝑠is the set of timestamps that each element appears in the
stream for the first time.
Proof. See Appendix A.3 □
5 EVALUATION
All algorithms are implemented in C++ and run on a processor
with a Quad-Core Intel(R) Xeon(R) CPU E3-1226 v3 CPU 3.30GHz
processor. Our source code is available [4].
5.1 Datasets
We conduct experiments on both synthetic and real-world datasets.
•Synthetic Datasets. We generate synthetic datasets with the
following distributions: Uniform distribution 𝑈(0,1), Gauss distri-
bution𝑁(1,0.1), and Gamma distribution 𝛾(1,2)For each type of
distribution, we generate datasets with different sizes of elements,
respectively. The name of the dataset is represented as “distribution-
#elements”. For example, Uniform-1k represents the dataset with
1,000elements, and the weight of each element follows the Uniform
distribution 𝑁(0,1). Each dataset is considered a single stream.
•Real-world Datasets. We use the following real-world datasets:
Twitter [1],Real-sim [39],Rcv1 [28],Webspam [36],News20 [24]
Libimseti [25]. Twitter [ 1] is a dataset of “following” relation-
ships between Twitter users. The above two datasets are treated
as single-stream datasets. Real-sim [ 39], Rcv1 [ 28], Webspam [ 36]
and News20 [ 24] are datasets of web documents from different
resources, where each vector represents a document and each entry
in the vector refers to the TF-IDF score of a specific word for the
document. Libimseti [ 25] is a dataset of ratings of different users,
where each vector refers to a user and each entry records the user’s
rating. These six datasets are considered multi-stream datasets, and
each vector within the dataset is a single stream of elements with a
weight. The details of these datasets are described in Table 1.
5.2 Baselines
We compare QSketch and QSketch-Dyn, with state-of-the-art meth-
ods, Lemiesz’s method [ 26] (represented as LM), FastGM [ 45] and
FastExp Sketch [ 27]. All baseline methods maintain a sketch with
𝑚64-bit registers. QSketch and QSketch-Dyn are truncated with
𝑟min=−127and𝑟max=127, i.e., they all use 8-bit integer registers
by default. We assign each algorithm the same number of registers,which means QSketch and QSketch-Dyn use about 1/8 of the mem-
ory space of baseline methods. Following [ 3], we use a 32-bit word
to hold multiple short-bit registers. For example, with each register
set to 8 bits, a 32-bit word can hold ⌊32
8⌋=4registers.
5.3 Metrics
•Accuracy. We use Relative Root Mean Square Error (RRMSE) and
Average Absolute Relative Error (AARE) to evaluate the estimation
accuracy on single-stream datasets and multi-stream datasets, re-
spectively. In detail, the RRMSE of estimation ˆ𝐶is defined as
𝑅𝑅𝑀𝑆𝐸(ˆ𝐶)=√︃
E[(ˆ𝐶−𝐶)2]
𝐶,
and the AARE is defined as
𝐴𝐴𝑅𝐸 =1
𝑛𝑛∑︁
𝑖=1|ˆ𝐶𝑖−𝐶𝑖|
|𝐶𝑖|.
•Efficiency. We use Throughput (Million updates per second,
Mops) to evaluate the update speed for incoming elements, and
Esimation time to assess the time taken to calculate the weighted
cardinality from the sketch. All experimental results are empirically
computed from 100 independent runs by default.
5.4 Accuracy Analysis
5.4.1 Results on Real-World Datasets. Figure 2 shows the results
on accuracy concerning the number of registers in a sketch on
real-world datasets. Specially, we vary the number of registers in
each sketch𝑚∈{26,27,28,29,210,211,212}. For dataset Twitter and
the other 3 document datasets, we evaluate RRMSE and AARE w.r.t.
the number of registers, respectively. Notably, QSketch demon-
strates comparable performance to other baseline methods across
all datasets. Conversely, QSketch-Dyn outperforms its competitors,
leveraging the dynamic nature of the sketch. For example, on the
dataset Twitter, our method QSketch-Dyn is 30% more accurate
than alternative methods with the number of registers 𝑚=28. It
is imperative to emphasize that QSketch and QSketch-Dyn utilize
only 1/8of the memory compared to LM and FastGM.
5.4.2 Results on Synthetic Datasets. To comprehensively assess the
efficacy of QSketch across diverse scenarios, we conduct a thorough
evaluation comparing its performance with that of other baseline
methods. This evaluation encompasses a range of factors including
data distribution, dataset scale, register count, and register size.
Performance under different data distribution. We compare
our methods QSketch and QSketch-Dyn with other methods on
synthetic datasets from different distributions. Figure 3 illustrates
the comparative performance. Remarkably, QSketch-Dyn consis-
tently outperforms other methods across all distributions, the same
as real-world dataset results.
Performance under different dataset sizes. Next, we explore
the performance of our methodologies across varying dataset sizes.
We generate datasets from three distributions at different scales
ranging from 102to106. The results of the remaining two distri-
butions are summarized in the Appendix. The number of registers
for all methods is fixed at 28. As shown in Figure 4, QSketch, LM,
FastGM, and FastExp Sketch estimation errors remain consistent
across all dataset scales. However, the performance of QSketch-Dyn
 
2437QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD ’24, August 25–29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Twitter
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Libimseti
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) News20
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(d) Rcv1
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (e) Real-sim
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (f) Webspam
Figure 2: Accuracy of all methods under different numbers of registers on real-world datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform-10k
Figure 3: Accuracy of all methods under different numbers of registers on synthetic datasets.
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma distribution
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss distribution
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform distribution
Figure 4: Accuracy of all methods under different data sizes on synthetic datasets.
shows a slight improvement with increasing dataset scale, with the
estimation error stabilizing around 0.05for dataset sizes exceeding
104. This phenomenon primarily stems from the fact that, with
smaller dataset sizes, most registers in QSketch-Dyn are populated
by only one element, resulting in nearly exact counting.
Performance under different register size. As mentioned in
Theorem 1, the bit size of the sketch’s registers also influences its
performance. Figure 5 illustrates the estimation error of QSketch
and QSketch-Dyn on the Uniform-10k distribution, considering the
maximum value of the distribution ranging from 10−10to1010(i.e.,
weighted cardinality ranging from 5×10−7to5×1013). The numberof registers of both methods is set to 28. It is evident that when
employing 4- or 5-bit registers, both QSketch and QSketch-Dyn
offer accurate estimations within a limited range. However, with a
bit size increase to 7 or 8, both methods consistently perform well
across all values, aligning with the findings of Theorem 1.
5.5 Efficiency Analysis
For efficiency, we measure the Throughput (Millions of updates
per second) as the update speed of a sketch for incoming ele-
ments, and the Estimation time as the time taken to calculate the
weighted cardinality from the sketch.
 
2438KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
1010
108
106
104
102
1001021041061081010
Maximum Value102
101
100101RRMSE
bit=4
bit=5bit=6
bit=7bit=8
(a) QSketch
1010
108
106
104
102
1001021041061081010
Maximum Value102
101
100101102RRMSE
bit=4
bit=5bit=6
bit=7bit=8 (b) QSketch-dyn
Figure 5: Accuracy of our methods QSketch and QSketch-Dyn under different register sizes on synthetic datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Twitter
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Libimseti
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) News20
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(d) Rcv1
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (e) Real-sim
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (f) Webspam
Figure 6: Update throughput of all methods under different numbers of registers on real-world datasets.
5.5.1 Results on Real-World Datasets. Figure 6 shows the results of
the update throughput on real-world datasets. The throughput for
LM, FastGM, FastExp Sketch, and QSketch demonstrates a decrease
with more registers in the sketch. Moreover, the update throughput
for FastGM and FastExp Sketch exhibits similarity and is faster than
LM. For QSketch, since it uses packed integers for implementation,
it needs fewer memory accesses than FastGM and FastExp, which
leads to a large update throughput on most datasets. The update
throughput for QSketch-Dyn remains nearly consistent across vary-
ing numbers of registers. Specifically, on dataset Rcv1, the update
time for QSketch-Dyn is approximately 2 to 3 orders of magnitude
shorter compared to FastGM and LM, respectively.
5.5.2 Results on Synthetic Datasets. Figure 7 shows the experimen-
tal results of update throughput on synthetic datasets with three
different distributions. Remarkably, the update throughput exhibits
similar trends across all three distributions. Overall, QSketch-Dyn
emerges as the superior performer among all competitors, a trend
consistent with the results observed on real-world datasets. Specifi-
cally, the update throughput for QSketch-Dyn is approximately 10
and 100 times shorter compared to FastGM and LM, respectively.
Figure 8 shows the estimation time of all methods on three synthetic
datasets. We omit similar results on other datasets. The estimationtime of LM, FastGM, and FastExp Sketch is only related to the num-
ber of registers in the sketch. QSketch needs several iterations for
convergence, which costs more time. Fortunately, in practical appli-
cation scenarios, the estimation procedure may happen much less
frequently than the update procedure, and the absolute estimation
time of QSketch is only 0.01s when using 4,096registers, which
is acceptable. Besides, QSketch-Dyn keeps track of the weighted
cardinality on the fly, and it does not need an estimation procedure.
6 RELATED WORK
6.1 Cardinality Estimation
Harmouch et al. [ 21] give a comprehensive review of existing sketch
methods of estimating the cardinality. Whang et al. [ 40] introduce
the LPC sketch using random hash functions for element map-
ping. Various enhancements to LPC’s estimation range were later
proposed [ 6,14]. Flajolet and Martin [ 18] develop the FM sketch,
which was subsequently refined through methods like LogLog [ 13],
HyperLogLog [ 17], RoughEstimator [ 22], and HLL-TailCut+ [ 43],
reducing register size and employing multiple registers. Giroire
et al. [ 20] develop a sketching method MinCount (also known as
bottom-𝑘sketch [ 8]) which stores the 𝑘minimum hash values of
 
2439QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD ’24, August 25–29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform-10k
Figure 7: Update throughput of all methods under different numbers of registers on synthetic datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053 (c) Geometric-10k
Figure 8: Estimation time of all methods under different numbers of registers on synthetic datasets.
elements in the set. Ting [ 34] develops a martingale-based estimator
to improve the accuracy of the above sketch methods such as LPC,
HyperLogLog, and MinCount. Chen et al. [ 7] extend HyperLogLog
to sliding windows. Besides sketch methods, two sampling meth-
ods [16, 19] are also proposed for cardinality estimation. Recently,
considerable attention [ 37,42,44,46] has been given to developing
fast sketch methods for monitoring the cardinalities of network
hosts over high-speed links. Ting [ 35] developed methods to esti-
mate the cardinality of set unions and intersections from MinCount
sketches. Cohen et al. [ 10] developed a method combining MinHash
and HyperLogLog to estimate set intersection cardinalities. Karppa
et al. [ 23] optimized HyperLogLog by decomposing register values
into a base value and an offset vector, leading to more efficient
storage. Very recently, Wang et al. [ 38] proposed a method named
Half-Xor to handle element deletions in cardinality estimation.
6.2 Weighted Cardinality Estimation
To estimate the weighted cardinality, Considine et al. [ 11] used
binary representations to represent integer weights, which is not
efficient for elements with large weights. Cohen et al. [ 9] proposed a
weighted estimator based on bottom- 𝑘sketches. However, bottom-
𝑘sketches require maintaining a sorted list of the 𝑘smallest values,
which needs more updating time and memory usage. Recently,
Lemiesz [ 26] presented a method that maps each element to 𝑚ex-
ponential distributed variables. Thus it needs 𝑂(𝑚)time to process
an incoming element, which is infeasible for high-speed streams.
Therefore, Zhang et al. [ 45] proposed FastGM to accelerate [ 26].
FastGM generates these exponential variables in ascending order
and stops the generation in advance if the generated value is greater
than the maximal value in current registers. As a recent simultane-
ous work, FastExpSketch [ 27] shares the same idea with FastGM.
However, these methods store generated values with 32-bit or 64-bit
floating-point registers. When we need a large 𝑚to achieve betteraccuracy or there are many different streams, it is memory-intensive
for devices with limited computational and storage resources. In
addition, these methods need 𝑂(𝑚)to estimate weighted cardinal-
ity, and it is not efficient for them to provide anytime-available
estimation for real-time applications.
7 CONCLUSIONS AND FUTURE WORK
This paper introduces QSketch, a memory-efficient sketching tech-
nique that leverages quantization methods to transform continuous
register values into discrete integers. Unlike traditional sketching
approaches which allocate 64 bits per register, our QSketch achieves
comparable performance using only 8 bits per register. The QSketch
experiences a worst-case time of 𝑂(𝑚·𝑛)where the weights of
elements increase over time, and it needs to solve an MLE prob-
lem through the Newton-Raphson method, which introduces extra
computational overhead. Therefore, we further capitalize on the
dynamic nature of sketches by proposing QSketch-Dyn, which en-
ables real-time monitoring of weighted cardinality. This enhanced
method reduces estimation errors and maintains a constant time
complexity for updates. We validate our approach through experi-
ments conducted on both synthetic and real-world datasets. The
results demonstrate that our novel sketching approach outperforms
existing methods by approximately 30%while consuming only one-
eighth of the memory. In the future, we aim to explore weighted
cardinality in streaming scenarios, particularly focusing on han-
dling element deletions and elements with negative weights.
ACKNOWLEDGMENT
The authors thank the reviewers for their comments and sugges-
tions. This work was supported by the National Natural Science
Foundation of China (U22B2019, 62372362, 62272372, 62272379).
 
2440KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
REFERENCES
[1] 2010. Twitter. https://anlab-kaist.github.io/traces/
[2] 2018. CAIDA. https://www.caida.org/
[3]2022. https://github.com/mkarppa/hyperlogloglog/blob/master/hyperlogloglog/
PackedVector.hpp#L130
[4] 2024. https://github.com/Rezerolird/QSketch
[5]Saba Akram and Quarrat Ul Ann. 2015. Newton raphson method. International
Journal of Scientific & Engineering Research 6, 7 (2015), 1748–1752.
[6]Aiyou Chen, Jin Cao, Larry Shepp, and Tuan Nguyen. 2011. Distinct counting
with a self-learning bitmap. JASA 106, 495 (2011), 879–890.
[7]Wenji Chen, Yang Liu, and Yong Guan. 2013. Cardinality change-based early
detection of large-scale cyber-attacks. In IEEE INFOCOM. 1788–1796.
[8]Edith Cohen and Haim Kaplan. 2007. Summarizing data using bottom-k sketches.
InPODC. 225–234.
[9]Edith Cohen and Haim Kaplan. 2008. Tighter estimation using bottom k sketches.
PVLDB 1, 1 (2008), 213–224.
[10] Reuven Cohen, Liran Katzir, and Aviv Yehezkel. 2017. A minimal variance
estimator for the cardinality of big data set intersection. In ACM SIGKDD. 95–
103.
[11] Jeffrey Considine, Feifei Li, George Kollios, and John Byers. 2004. Approximate
aggregation techniques for sensor databases. In IEEE ICDE. 449–460.
[12] Harald Cramér. 1999. Mathematical methods of statistics. Vol. 26. Princeton
university press.
[13] Marianne Durand and Philippe Flajolet. 2003. Loglog counting of large cardinali-
ties. In ESA. 605–617.
[14] Cristian Estan, George Varghese, and Mike Fisk. 2003. Bitmap algorithms for
counting active flows on high speed links. In SIGCOMM. 153–166.
[15] Ronald A Fisher and Frank Yates. 1938. Statistical tables: For biological, agricultural
and medical research. Oliver and Boyd.
[16] P. Flajolet. 1990. On Adaptive Sampling. Computing 43, 4 (1990), 391–400.
[17] Philippe Flajolet, Éric Fusy, Olivier Gandouet, and Frédéric Meunier. 2007. Hyper-
loglog: the analysis of a near-optimal cardinality estimation algorithm. DMTCS
Proceedings (2007).
[18] Philippe Flajolet and G Nigel Martin. 1985. Probabilistic counting algorithms for
data base applications. JCSS 31, 2 (1985), 182–209.
[19] Phillip B Gibbons. 2001. Distinct sampling for highly-accurate answers to distinct
values queries and event reports. In VLDB, Vol. 1. 541–550.
[20] Frédéric Giroire. 2009. Order statistics and estimating cardinalities of massive
data sets. DAM 157, 2 (2009), 406–427.
[21] Hazar Harmouch and Felix Naumann. 2017. Cardinality estimation: An experi-
mental survey. PVLDB 11, 4 (2017), 499–512.
[22] Daniel M Kane, Jelani Nelson, and David P Woodruff. 2010. An optimal algorithm
for the distinct elements problem. In PODS. 41–52.
[23] Matti Karppa and Rasmus Pagh. 2022. HyperLogLogLog: Cardinality Estimation
With One Log More. In ACM SIGKDD. 753–761.
[24] S Sathiya Keerthi, Dennis DeCoste, and Thorsten Joachims. 2005. A modified
finite Newton method for fast solution of large scale linear SVMs. Journal of
Machine Learning Research 6, 3 (2005).
[25] Jérôme Kunegis, Gerd Gröner, and Thomas Gottron. 2012. Online dating recom-
mender systems: The split-complex number approach. In Proceedings of the 4th
ACM RecSys workshop on Recommender systems and the social web. 37–44.
[26] Jakub Lemiesz. 2021. On the algebra of data sketches. PVLDB 14, 9 (2021),
1655–1667.[27] Jakub Lemiesz. 2023. Efficient framework for operating on data sketches. PVLDB
16, 8 (2023), 1967–1978.
[28] David D Lewis, Yiming Yang, Tony Russell-Rose, and Fan Li. 2004. Rcv1: A
new benchmark collection for text categorization research. JMLR 5, Apr (2004),
361–397.
[29] Ping Li and Christian König. 2010. b-Bit minwise hashing. In WWW. 671–680.
[30] Xiaohui Long and Torsten Suel. 2005. Three-level caching for efficient query
processing in large web search engines. In WebConf. 257–266.
[31] Rifat Ozcan, Ismail Sengor Altingovde, and Özgür Ulusoy. 2011. Cost-aware
strategies for query result caching in web search engines. ACM TWEB 5, 2 (2011),
1–25.
[32] Christopher R Palmer, Georgos Siganos, Michalis Faloutsos, Christos Faloutsos,
and Phillip B Gibbons. 2001. The connectivity and fault-tolerance of the Internet
topology. (2001).
[33] Yiyan Qi, Pinghui Wang, Yuanming Zhang, Junzhou Zhao, Guangjian Tian, and
Xiaohong Guan. 2020. Fast generating a large number of gumbel-max variables.
InWebConf. 796–807.
[34] Daniel Ting. 2014. Streamed Approximate Counting of Distinct Elements: Beating
Optimal Batch Methods. In ACM SIGKDD. 442–451.
[35] Daniel Ting. 2016. Towards optimal cardinality estimation of unions and inter-
sections with sketches. In ACM SIGKDD. 1195–1204.
[36] De Wang, Danesh Irani, and Calton Pu. 2012. Evolutionary study of web spam:
Webb spam corpus 2011 versus webb spam corpus 2006. In IEEE CollaborateCom.
40–49.
[37] Pinghui Wang, Xiaohong Guan, Tao Qin, and Qiuzhen Huang. 2011. A data
streaming method for monitoring host connection degrees of high-speed links.
IEEE TIFS 6, 3 (2011), 1086–1098.
[38] Pinghui Wang, Dongdong Xie, Junzhou Zhao, Jinsong Li, Zhicheng Li, Rundong
Li, and Yang Ren. 2024. Half-Xor: A Fully-Dynamic Sketch for Estimating the
Number of Distinct Values in Big Tables. IEEE Transactions on Knowledge and
Data Engineering (2024).
[39] Wu Wei, Bin Li, Chen Ling, and Chengqi Zhang. 2017. Consistent Weighted
Sampling Made More Practical. In WebConf. 1035–1043.
[40] Kyu-Young Whang, Brad T Vander-Zanden, and Howard M Taylor. 1990. A
linear-time probabilistic counting algorithm for database applications. ACM
TODS 15, 2 (1990), 208–229.
[41] Viktor Witkovsk `y. 2001. Computing the distribution of a linear combination of
inverted gamma variables. Science Direct Working Paper S1574-0358 (2001), 04.
[42] Qingjun Xiao, Shigang Chen, Min Chen, and Yibei Ling. 2015. Hyper-compact
virtual estimators for big network data based on register sharing. In ACM SIG-
METRICS. 417–428.
[43] Qingjun Xiao, You Zhou, and Shigang Chen. 2017. Better with fewer bits: Im-
proving the performance of cardinality estimation of large data streams. In IEEE
INFOCOM. 1–9.
[44] M Yoon, Tao Li, Shigang Chen, and J-K Peir. 2009. Fit a spread estimator in small
memory. In IEEE INFOCOM. 504–512.
[45] Yuanming Zhang, Pinghui Wang, Yiyan Qi, Kuankuan Cheng, Junzhou Zhao,
Guangjian Tian, and Xiaohong Guan. 2023. Fast Gumbel-Max Sketch and its
Applications. IEEE TKDE (2023).
[46] Qi Zhao, Abhishek Kumar, and Jun Xu. 2005. Joint Data Streaming and Sampling
Techniques for Detection of Super Sources and Destinations.. In ACM SIGCOMM .
77–90.
 
2441QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD ’24, August 25–29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
213
#Registers100101102103104Vallue of alpha
n=102
n=103n=104
n=105
Figure 9: The value of alpha with different 𝑛and𝑚on uni-
form distribution.
A APPENDXIX
A.1 Fisher-Yates shuffle
The Fisher-Yates shuffle is commonly utilized to generate an un-
biased permutation step-by-step. The pseudocode of the shuffle
is summarized in Algorithm 4. Note that after the 𝑖-th step of the
Fisher-Yates shuffle, the first 𝑖positions of the permutation are
computed and fixed.
Algorithm 4: Fisher-Yates shuffle.
input : An initial permutation [𝜋1,...,𝜋𝑚].
output: Shuffled permutation [𝜋′
1,...,𝜋′𝑚].
1[𝜋1,...,𝜋𝑚]←[ 1,...,𝑚];
2foreach𝑖∈{1,...,𝑚}do
3𝑘←RandInt(𝑖,𝑚);
4 Swap(𝜋𝑘,𝜋𝑖);
A.2 Proof of Theorem 1
According to Equation (7), the probability that a register value
𝑅[𝑗]≤𝑟minor𝑅[𝑗]≥𝑟maxis computed as,
𝑃𝑟(𝑅[𝑗]≤𝑟min)=𝑟min∑︁
𝑟=−∞𝑃𝑟(𝑅[𝑗]=𝑟)
=∫+∞
2−(𝑟min+1)𝐶Π·𝑒−𝐶Π𝑥𝑑𝑥
=𝑒−𝐶Π·2−(𝑟min+1),
and
𝑃𝑟(𝑅[𝑗]≥𝑟max)=𝑟=+∞∑︁
𝑟min𝑃𝑟(𝑅[𝑗]=𝑟)
=∫2−𝑟max
0𝐶Π·𝑒−𝐶Π𝑥𝑑𝑥
=1−𝑒−𝑐Π·2−𝑟max.
By setting𝑃𝑟(𝑅[𝑗]≤𝑟min)<𝜖and𝑃𝑟(𝑅[𝑗]≥𝑟max)<𝜖simulta-
neously for above formulas, we have
−2(𝑟min+1)·ln𝜖<𝐶Π<−2𝑟max·ln(1−𝜖),
which is the conclusion of the theorem.A.3 Proof of Theorem 2
Given the data stream Πthe set of timestamps that each element
appears in the stream for the first time 𝑇(𝑡)
𝑠, we first derive the
expectation. Let 1(𝑅(𝑡)≠𝑅(𝑡−1))demote an indicator of whether
the state of sketch 𝑅has changed at time 𝑡, i.e.,1(𝑅(𝑡)≠𝑅(𝑡−1))=1
for𝑅(𝑡)≠𝑅(𝑡−1)and0otherwise. We note that 𝑞(𝑡)
𝑅only depends
on𝑅(𝑡−1)and then we have
E[1(𝑅(𝑡)≠𝑅(𝑡−1))|𝑞(𝑡)
𝑅]=E[1(𝑅(𝑡)≠𝑅(𝑡−1))|𝑅(𝑡−1)]=𝑞(𝑡)
𝑅.
From the linearity of expectation and the law of total expectation,
we have
E[ˆ𝐶(𝑡)
Π]=E[E[ˆ𝐶(𝑡)
Π|𝑅(𝑡−1)]]
=E[E[ˆ𝐶(𝑡−1)
Π|𝑅(𝑡−1)]+E[1(𝑅(𝑡)≠𝑅(𝑡−1))
𝑞(𝑡)
𝑅𝑤(𝑡)|𝑅(𝑡−1)]]
=E[ˆ𝐶(𝑡−1)
Π]+𝑤(𝑡)=𝐶(𝑡)
Π.
For the variance, we have
Var[ˆ𝐶(𝑡)
Π]=E[(ˆ𝐶(𝑡)
Π)2]−E[ˆ𝐶(𝑡)
Π]2=E[(ˆ𝐶(𝑡)
Π)2]−(𝐶(𝑡)
Π)2.
Following a similar derivation with the expectation, we have
E[(ˆ𝐶(𝑡)
Π)2]=E[E[(ˆ𝐶(𝑡)
Π)2|𝑅(𝑡−1)]],
where E[(ˆ𝐶(𝑡)
Π)2|𝑅(𝑡−1)]is computed as
E[(ˆ𝐶(𝑡)
Π)2|𝑅(𝑡−1)]
=(ˆ𝐶(𝑡−1)
Π)2+2𝑤(𝑡)ˆ𝐶(𝑡−1)
Π
𝑞(𝑡)
𝑅E[1(𝑅(𝑡)≠𝑅(𝑡−1))|𝑅(𝑡−1)]+
(𝑤(𝑡)
𝑞(𝑡)
𝑅)2E[(1(𝑅(𝑡)≠𝑅(𝑡−1)))2|𝑅(𝑡−1)]
=(ˆ𝐶(𝑡−1)
Π)2+2𝑤(𝑡)ˆ𝐶(𝑡−1)
Π+(𝑤(𝑡))2
𝑞(𝑡)
𝑅.
Then, we have
E[(ˆ𝐶(𝑡)
Π)2]=E[(ˆ𝐶(𝑡−1)
Π)2+2𝑤(𝑡)ˆ𝐶(𝑡−1)
Π+(𝑤(𝑡))2
𝑞(𝑡)
𝑅]
=E[(ˆ𝐶(𝑡−1)
Π)2]+2𝑤(𝑡)E[ˆ𝐶(𝑡−1)
Π]+E[(𝑤(𝑡))2
𝑞(𝑡)
𝑅]
=∑︁
𝑖∈𝑇(𝑡)
𝑠E[(𝑤(𝑖))2
𝑞(𝑖)
𝑅]+2∑︁
𝑖,𝑗∈𝑇(𝑡)
𝑠∧𝑖≠𝑗𝑤(𝑖)𝑤(𝑗).
Finally, we obtain
Var[ˆ𝐶(𝑡)
Π]=E[(ˆ𝐶(𝑡)
Π)2]−E[ˆ𝐶(𝑡)
Π]2=∑︁
𝑖∈𝑇(𝑡)
𝑠(𝑤(𝑖))2E[1−𝑞(𝑖)
𝑅
𝑞(𝑖)
𝑅].
An exact expression for E[1−𝑞(𝑖)
𝑅
𝑞(𝑖)
𝑅]can be derived with the prob-
ability𝑃(𝑅(𝑡)[1]=𝑟1,...,𝑅(𝑡)[𝑚]=𝑟𝑚|Π). However, it is too
 
2442KDD ’24, August 25–29, 2024, Barcelona, Spain Yiyan Qi et al.
28
210
212
214
216
218
220
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056104
103
102
101
/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Accuracy
28
210
212
214
216
218
220
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056105
103
101
101103105/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Update Throughput
Figure 10: Experiments on CAIDA dataset under a different number of registers.
complex to analyze. Hence, we try to approximate the variance via
the empirical analysis.
Var[ˆ𝐶(𝑡)
Π]<𝑤(𝑡)
max∑︁
𝑖∈𝑇(𝑡)
𝑠E[𝑤(𝑖)
𝑞(𝑖)
𝑅]−𝑤(𝑡)
max𝐶(𝑡)
Π
=(𝛼𝑑𝑖𝑠(𝑛,𝑚)−1)𝑤(𝑡)
max𝐶(𝑡)
Π,
where𝑤(𝑡)
max=max𝑖∈𝑇(𝑡)
𝑠𝑤(𝑖)and𝛼𝑑𝑖𝑠(𝑛,𝑚)is a function of num-
ber of elements 𝑛and number of registers 𝑚.
As an illustration, we consider a uniform distribution from the
interval(0,1). Figure 9 depicts the variation in the function’s value
across different values of 𝑚and𝑛. As a result, we can get an up-
per bound of the variance together with the weighted cardinality
estimation.
A.4 Results on Large-Scale Dataset CAIDA
We further conduct experiments on the CAIDA [ 2] dataset, which
consists of streams of anonymized IP items collected from high-
speed monitors by CAIDA in 2018. A 1-minute CAIDA networktraffic trace contains about 27M packets. For each packet, we con-
sider the tuple (source IP, target IP) as the identifier of the element
e, and the packet size as the weight of the element e. Experimental
results are summarized in Figure 10. We vary the number of regis-
ters in each sketch 𝑚∈{28,210,212,214,216,218,220}, and evaluate
the RRMSE as well as the update throughput. All methods achieve
better estimation accuracy when using more registers at the cost
of lower update throughput. Besides, we observe that:
•QSketch achieves similar estimation accuracy as LM, FastGM,
and FastGM, and QSketch-Dyn performs best among all meth-
ods. This is consistent with previous results. For example, when
using𝑚=220registers, the estimation accuracy of QSketch-Dyn is
about twice that of other methods.
•The update throughput for QSketch-Dyn remains nearly
consistent across varying numbers of registers and is higher
than other methods. This is also consistent with previous results.
For example, when use 𝑚=219registers, the update throughput
of QSketch-Dyn is about 1 Mops, while the update throughput
of FastGM, QSketch, and FastExp Sketch is only about 0.2 Mops,
which means that QSketch-Dyn is about 5×faster.
 
2443