Efficient Detection of Long Consistent Cycles
and its Application to Distributed Synchronization*
Shaohan Li
University of Minnesota
li000743@umn.eduY unpeng Shi
University of California, Davis
ypshi@ucdavis.eduGilad Lerman
University of Minnesota
lerman@umn.edu
Abstract
Group synchronization plays a crucial role in global
pipelines for Structure from Motion (SfM). Its formulation is
nonconvex and it is faced with highly corrupted measurements.
Cycle consistency has been effective in addressing these chal-
lenges. However , computationally efficient solutions are needed
for cycles longer than three, especially in practical scenarios
where 3-cycles are unavailable. To overcome this computational
bottleneck, we propose an algorithm for group synchronization
that leverages information from cycles of lengths ranging from
three to six with a time complexity of order O(n3)(orO(n2.373)
when using a faster matrix multiplication algorithm). We estab-
lish non-trivial theory for this and related methods that achieves
competitive sample complexity, assuming the uniform corrup-
tion model. To advocate the practical need for our method, we
consider distributed group synchronization, which requires at
least 4-cycles, and we illustrate state-of-the-art performance by
our method in this context.
1. Introduction
Structure from Motion (SfM) asks to recover the 3D structure
of a stationary scene from multiple images taken by cameras
from different orientations and locations. In the past decade, the
global SfM pipeline has become increasingly popular due to its
several advantages over the incremental pipelines [ 17,31]. First
of all, global SfM requires only one implementation of bundle
adjustment, making it more efficient in computation. Second,
it estimates camera poses in a global optimization framework
which mitigates the drifting issue of the incremental pipelines.
Despite the popularity of global SfM pipelines, the estimation
of global camera poses (e.g., orientations) remains a highly chal-
lenging problem. For instance, estimating camera orientations
from their relative measurements, often called rotation synchro-
nization, is a highly nonconvex graph optimization problem.
In typical scenarios of highly noisy or corrupted measurements
*This work was supported by NSF award DMS-2152766.
Supplementary code: https://github.com/sli743/LongSyncof relative orientations, many common solutions of rotation
synchronization have poor accuracy and slow convergence.
Given these challenges, theoretical developments have
demonstrated the critical role of cycle-consistency information
in inferring corrupted measurements [ 25]. In practice, the
consistency constraint on 3-cycles was utilized to estimate
the error of each measured relative orientation. It also helped
nonconvex iterative rotation synchronization solvers avoid
spurious local minima and achieve significantly higher accuracy
[39]. However, the usage of 3-cycles largely limits the
application of these improved algorithms to other important
scenarios. One scenario involves a sparse viewing graph lacking
sufficient 3-cycles. This often occurs when the size of the graph
is too large to densely measure the relative orientations on its
edges, which could happen in certain case for the molecular
orientation estimation in cryo-electron microscopy imaging.
Another scenario is orientation estimation for each piece of
jigsaw puzzles, where the graph is a 2D lattice and 3-cycle
does not exist. Lastly, in distributed SfM, edges between any
two clusters of nodes form a bipartite graph, and cycles of odd
length do not exist. Our numerical results primarily emphasize
the practical scenario of distributed SfM, which holds particular
relevance for the broader computer vision community.
Despite the multiple critical applications of long-cycle
consistency, inferring measurement noise from long cycles is
challenging in both computation and theory. First of all, the
number of cycles grows exponentially with the cycle length, and
measuring cycle inconsistencies for each long cycle is computa-
tionally intractable. Moreover, developing theoretical guarantees
for long-cycle inference methods is fundamentally more difficult
than the 3-cycle case. Indeed, in a random graph setting, a set of
longer cycles are more likely to share common edges, making
their consistency score highly correlated. Therefore, new tools
are required to handle the correlated empirical process.
In this work, we propose the first practical method,
LongSync, for inferring edge corruption levels from long
cycle consistency information. For this purpose, we carefully
modify and vectorize the Cycle Edge Message Passing (CEMP)
method [ 25]. This nontrivial modification drastically reduces its
computational complexity when using longer cycles. Moreover,
This CVPR paper is the Open Access version, provided by the Computer Vision Foundation.
Except for this watermark, it is identical to the accepted version;
the final published version of the proceedings is available on IEEE Xplore.
5260
by employing a more delicate analysis and incorporating new
tools from probability theory and combinatorics, we develop
a significantly stronger exact recovery result with a general
cycle length under a popular probabilistic model. The sample
complexity in our theory is the lowest among all practical
rotation synchronization methods. Although we limit our
scope to the application of distributed SfM, our algorithm and
theory applies to any finite-dimensional linear group in group
synchronization, and not just SO(3)in rotation synchronization.
1.1. Related Work
Earlier rotation synchronization methods [ 2,10–
13,18,33,42,43] seek to minimize a least squares
energy function. They can be described as relaxed versions of
the maximum likelihood estimator under the additive Gaussian
noise model, but they are not robust in the presence of outliers
or heavy-tailed noise. Nevertheless, in the case of global
SfM, the initially estimated relative camera rotations can be
severely corrupted due to the erroneous keypoint matches and
the subsequent poor estimation of fundamental matrices.
To handle outliers, robust rotation synchronization methods
either minimize a robust energy function or reweigh/trim the
viewing graph based on the corruption levels of the edges.
Wang and Singer [ 49] minimizes a corresponding ℓ1objective
function using semidefinite programming (SDP) relaxation,
which is slow in practice. Other energy minimization methods
are typically nonconvex, which include the Weiszfeld algorithm
[20] and the Riemannian subgradient method [ 29] for ℓ1
minimization, and the iteratively reweighted least squares
(IRLS) for minimizing general ℓp[5] and Geman-McClure [ 4]
loss functions. However, all these methods heavily rely on good
initialization. Sidhartha and Govindu [ 41] partially remedy the
issue using adaptive Geman-McClure loss functions, but their
approach remains sensitive to the initialized weights. Maunu
and Lerman [ 30] propose to solve rotation synchronization
by an iterative robust averaging method that utilizes Tukey
depth, but they have not demonstrated effective performance
for real SfM applications. Arrigoni et al. [ 1] applies a low-rank
and sparse matrix decomposition method to SO(3) and SE(3)
synchronization, but it is even less robust to outliers than IRLS.
Instead of employing a robust objective function, Shen
et al. [ 36] and Zach et al. [ 51] uses the 3-cycle consistency
constraint to detect and remove corrupted relative orientations.
Lerman and Shi [ 25] take one step further to estimate the
corruption level of each relative measurement by a novel
cycle-edge message passing (CEMP) algorithm. They then
use the estimated corruption levels to reweigh the graph and
solve rotation synchronization using a weighted least squares
method. This message passing procedure was further combined
with IRLS to boost its accuracy in [ 39]. Particular versions
and extensions of this procedure for permutation and partial
permutation synchronization, which are relevant to the matching
component of SfM, were discussed in [27, 40].However, all the previously mentioned cycle-based methods
[25,27,36,38–40,51] only use 3-cycles in practice, limiting
their application for distributed synchronization. Indeed, the
standard distributed synchronization often requires “stitching”
local solutions by synchronizing the relative rotations between
clusters. Each of these inter-cluster rotations is estimated by
“averaging” the edges between the two clusters. These edges
form a bipartite graph, and the minimal cycle length is 4.
As pointed in [ 51], the number of operations for computing
long cycle consistency information scales exponentially with
the cycle length. Therefore, none of the existing distributed
rotation synchronization methods directly exploits long cycle
information due to this computational challenge.
The earlier distributed methods for SO(d)synchronization,
such as [ 45] and [ 44], minimize a least squares energy and
are not robust to outliers. A series of distributed SfM methods
[14–16] implement incremental SfM algorithms for each
cluster. However, these methods do not employ a standard
rotation synchronization algorithm, as they require additional
information such as the number of keypoint matches between
images. Moreover, the incremental methods are slower since
they require multiple rounds of global rotation synchronization.
MultiSync [ 9] synchronizes the inter-cluster rotations directly
using all inter-cluster edges among all clusters, by formulating
a novel synchronization problem on a multi-graph. Although
it utilizes a more unified formulation, its objective function is
least squares which largely limits its robustness to outliers.
A recent and different type of methods for rotation
synchronization use deep learning [ 21,26,34]. However, these
methods are supervised and thus may not generalize well
when switching datasets. Moreover, like many other previous
methods, they lack theoretical guarantees.
A common theoretical setting to assess the performance of
rotation synchronization algorithms is the uniform corruption
model (UCM) described in §4. We provide the best sample
complexity for LongSync, even with only 3 cycles, among all
previously established estimates for the UCM model.
1.2. Contributions of This Work
•We propose the first practical algorithm that infers edge
corruption levels from long cycle consistency information.
The computation complexity of our method is reduced from
O(nc)toO(n3)(or possibly O(n2.373)) for cycle length
c≤6andO(n[(c+3)/2])forc>6.
•We establish sample complexity estimates for our method
under the uniform corruption model, where we get closer to
the information theoretic bound than any other existing work.
Our proof requires delicate analysis and it also improves
previous estimates for the CEMP algorithm.
•We introduce a new graph partition and graph preprocessing
method that utilizes our inference method, and demonstrate
the effectiveness of our pipeline in boosting the performance
of distributed synchronization.
5261
•Extensive numerical experiments demonstrate the outstanding
performance of our method.
2. Problem Formulation and Preliminaries
Assume a graph G= ([n],E)where [n]is the set of nodes
indexed by {1,2,···,n}andEis the set of edges. Given
a mathematical group G, each graph node is assigned an
underlying ground truth group element R∗
i, where R∗
i∈ G
and we use star superscript to emphasize the ground truth.
For each edge ij∈E, we observe a relative group ratio
Rij∈G, whose clean counterpart is R∗
ij=R∗
iR∗−1
j.Group
synchronization aims to recover the ground truth group
elements {R∗
i}i∈[n]from the possibly noisy and corrupted
measurements {Rij}ij∈E. In this paper, we focus on the case
of rotation synchronization, which is a special case of group
synchronization with G=SO(d). For applications in camera
orientation synchronization ( d= 3), we estimate absolute
rotations for each node i∈[n]from measured relative rotations
of edges in E. Note that since {R∗
i}i∈[n]and{R∗
iR0}i∈[n]
generate the same set of relative rotations, one can only estimate
{R∗
i}i∈[n]up to a global rotation. The generalization to any
linear groups is discussed in the supplementary material.
2.1. Notations and Definitions
We denote the adjacency matrix of graph GasA, and form a
pairwise observation matrix R∈Rdn×dnby stacking the Rij’s
(forij̸∈E, setRij=03×3):
R:=
R11R12···R1n
R21R22···R2n
............
Rn1Rn2···Rnn
.
We list the matrix operations used in the paper. For matrices
XandY, the operations X⊗Y,X⊙Y,X⊘Yrespectively
denotes the Kronecker product, Hardmard (element-wise)
multiplication and Harmard division between XandY.X⊙k
denotes the element-wise matrix k-power. For block matrices,
⟨X,Y⟩blockdenotes the blockwise inner product of XandY,
i.e.⟨X,Y⟩block(i,j)=⟨X[i,j],Y[i,j]⟩, where [i,j]refers to the
corresponding block of the matrix.
2.2. Review of CEMP for c-Cycles
We assume the above setting of SO(d)synchronization. Let
Dbe any bi-invariant metric on SO(d). We assume a fixed
number of cycles, c, and denote by Nc
ijthe set of simple cycles
of length c(or simple c-cycles) containing edge ij. CEMP [ 25]
aims to estimate for each edge ijthe corruption level
s∗
ij=D(Rij,R∗
ij), (1)
from the set of cycle inconsistency measures
dL=D(RL,Rij) (2)where cycle L= (ik1, k1k2,···, kc−2j, ji)∈Nc
ijand
RL:=Rik1Rk1k2···Rkc−2j. The estimated s∗
ijcan then
be used for extracting a clean subgraph, or to implement a
weighted least squares solver where higher weights are assigned
to cleaner edges.
It is obvious that if all the edges in Lare clean then dL=0.
Moreover, due to bi-invariance of D, the following holds true
dL=s∗
ijwhenever L∈Gc
ij, (3)
where Gc
ijis the set of good c-cycles with respect to ij, i.e. the
set of cycles L∈Nc
ijsuch that ik1,···,kc−2jare clean. This
gives a sufficient condition for dLto be an exact estimator of s∗
ij.
To estimate the corruption levels of each edge ij, CEMP
initializes the edge weight of each ij∈Easw(0)
ij=1. It then
iteratively updates the corruption level estimate as the following
convex combination of dL’s:
s(t)
ij=X
L∈Nc
ijw(t)
LdL/z(t)
ij (4)
where z(t)
ij=P
L∈Nc
ijw(t)
L. The cycle weights w(t+1)
L are
computed from the edge weights w(t+1)
e=e−βts(t)
e:
w(t+1)
L=Y
e∈L\{ij}w(t+1)
e=Y
e∈L\{ij}e−βts(t)
e, (5)
so that w(t+1)
L focuses on good cycles. The cycle weights and
edge corruption levels are alternatingly updated and improved
from each other. Interestingly, it is proved in [ 25] under two
different corruption models that CEMP converges linearly to
the ground truth corruption estimates under mild conditions for
c=3. In practice, CEMP only uses 3-cycles for consideration of
efficiency. For longer cycles, the complexity of CEMP scales ex-
ponentially with the cycle length c(which is discussed in §3.2),
and the convergence guarantee of CEMP remains unknown.
3. Our method: LongSync
3.1. LongSync: Modification of CEMP
Our goal is to develop a scalable variant of CEMP for any fixed
number of cycles, c≥3. The main computational bottleneck
of step (4)in CEMP is that computing and summing the cycle
inconsistency measures takesP
ij∈E|Nc
ij|=O(nc)operations
and memory. Therefore, to develop a scalable algorithm,
we aim to take weighted average over dLwithout explicitly
computing and storing each dL. To achieve this, we propose
the following specification and modification on CEMP:
•Use Chordal distance on SO(d). We suggest the distance
function
D(R1,R2)=p
1−⟨R1,R2⟩/d.
This distance is proportional to the Chordal distance on
SO(3), which is the Euclidean distance between two
rotations embedded in Rd×d.
5262
•Use weighted quadratic average for corruption level
update. Instead of updating the corruption level estimates
by a weighted average of dL, we use the weighted quadratic
average of dL, namely
s(t)
ij=sX
L∈Nc
ijw(t)
Ld2
L/z(t)
ij (6)
where the update rule of cycle weights remains the same:
w(t+1)
L=Y
e∈L\{ij}w(t+1)
e=Y
e∈L\{ij}e−βts(t)
e. (7)
As a result, d2
L=d2(RL,Rij) = 1−⟨RL,Rij⟩/dis linear
in bothRLandRij. Therefore one can switch the order of
d2and the weighted summation, so that the computation of
s(t)
ijcan be vectorized. Indeed, by this linearity and equations
(4)and(2), and note that z(t)
ij=P
L∈Nc
ijw(t)
L, we obtain the
following equation:
s(t)
ij=X
L∈Nc
ijw(t)
Ld2
L/z(t)
ij1/2
=X
L∈Nc
ijw(t)
LD2(RL,Rij)/z(t)
ij1/2
=
D2X
L∈Nc
ijw(t)
LRL,Rij
/z(t)
ij1/2
=
1−DX
L∈Nc
ijw(t)
LRL,RijE
/dX
L∈Nc
ijw(t)
L1/2
(8)
Equation (8)can be vectorized using the trick of matrix
power if we allow repeated nodes for each cycle. That is, one
can stack the s(t)
ij’s and w(t)
ij’s into matrices S(t)andW(t), and
vectorize (8) as
S(t)=
A−D
W(t)⊗1d⊙Rc−1
,RE
block
⊘d(W(t))c−1⊙1/2
. (9)
Indeed, by (7)and the definition of RL,P
L∈Cc
ijw(t)
LRL
is the ij-th block of (W(t)⊗1d⊙R)c−1, andP
L∈Cc
ijw(t)
Lis
theij-th element of W(t)c−1, where Cc
ijis the set of c-cycles
containing ijwith possibly repeated nodes.
In the case of utilizing only simple cycles, (8)and(9)
are not equivalent and we need to correct (9)to remove the
cycles with repeated nodes, so that only simple cycles in
Nc
ijremain. Let gc(W,R)be the matrix valued function
where gc(W,R)(i,j) =P
L∈Nc
ij(Q
e∈L\{ij}w(t)
e)RL. Let
fc(W)be the matrix valued function where fc(W)(i,j) =P
L∈Nc
ij(Q
e∈L\{ij}w(t)
e). The following result holds:Proposition 3.1. The update rule of LongSync (8)is equivalent
to the following matrix equations:
S(t)=
A−D
hc(W(t),R),RE
block⊙A⊙1/2
, (10)
whereW(t+1)=A⊙exp(−βtS(t))and
hc(W(t),R):=gc(W(t),R)⊘(d·fc(W(t))⊗1d).
Hereexpdenotes the elementwise exponential function.
We use equation (10)as the update rule of LongSync and
propose the vectorized LongSync algorithm in algorithm 1.
Algorithm 1 (LongSync)
Input: pairwise rotation matrix R∈Rdn×dn, adjacency matrix
A∈[0,1]n×n, cycle length c, positive parameters {βt}t≥1,
time step T
W(0)(i,j)←A
fort=0:Tdo
S(t)←
A−D
hc(W(t),R),RE
block⊙A⊙1/2
(11)
W(t+1)←A⊙exp(−βtS(t)) (12)
end for
Output: edge weights W(T+1), corruption levels S(T)
We claim that gcandfccan be computed with a sequence
of matrix operations, thus greatly reducing the time and space
consumption of LongSync compared to its original form. For
c≤6, the time complexity of computing gcandfcisO(r(dn)),
where r(n)is the complexity for multiplying two n×n
matrices; for c≥7the time complexity is at most O(n[(c+3)/2]).
This claim is proved in the supplementary material. We list the
formula for gcandfcforc=3,4,5,6inspired by [ 35,46]. The
formula for c=6is moved to the supplementary material due
to the space limit. For c≥7the formula becomes extremely
complicated. We remark that in practice, the cycles of length
greater than 6 are often not used.
We finally remark that although Algorithm 1 only utilizes
cycles of a fixed length, one can easily generalize it to
incorporate cycles of different lengths. Indeed, the equation
(10)could use a convex combination of hc’s that corresponds
to different values of c. That is, for a preselected set of cycle
lengths C, the equation (11) in Algorithm 1 is replaced by
S(t)= 
A−*X
c∈Cλchc(W(t),R),R+
block⊙A!⊙1/2
(13)
where the coefficients λcsatisfiesP
c∈Cλc= 1to ensure a
convex combination. Here each λcis user-specified to reflect
the importance of the cycles of length c. However, the optimal
5263
choice of these parameters under certain statistical model
remains unclear.
For simplicity, in the experiments we only use a fixed cycle
length to avoid choosing λc. We have observed that such simple
choice still yields satisfying accuracy in camera orientation
estimation on both synthetic and real data. We refer the readers
to §5 and 6 for more details.
c Formula of fc(W) Formula of gc(W,R)
3W2P2
4W3−d(W2)W P3−dblock(P2)P
−Wd(W2)+W⊙3−Pdblock(P2)+P⊙3
5W4−d(W3)W P4−dblock(P3)P
−d(W2)W2−dblock(P2)P2
−W2d(W2) −P2dblock(P2)
−Wd(W2)W −Pdblock(P2)P
+3W⊙2W2+3P⊙2P2
+WW⊙3+W⊙3W +PP⊙3+P⊙3P
Table 1. Formulas for fcandgc. Here we let P=(W⊗1d)⊙Rfor
shorter notation. d(X)returns the diagonal of matrix X,dblock(X)
returns the diagonal block matrix from the d×ddiagonal blocks of
matrixX.
3.2. Computational Complexity
We derive the space and time complexity for LongSync, and
demonstrate its advantages over CEMP . The initialization step
involves setting the weights of all edges to 1, which takes
timeO(|E|)and space O(n2). For each iteration, LongSync
updates the matrices S(t)andW(t)with equations (11)
and (12), respectively. Computing W(t+1)involves two
matrix subtractions, one scalar-matrix multiplication and one
element-wise matrix exponential operation on S(t)∈Rn×n.
Therefore the update step (12)takes at most O(n2)time and
space. Equation (11), on the other hand, involves a sequence
of matrix operations on P(t)=(W(t)⊗1d)⊙R∈Rdn×dnand
W(t)∈Rn×n, including matrix multiplications, element-wise
multiplications and diagonal block selections. Computing
P(t)takes O(d2n2)memory and O(d2n2)time. The matrix
operations on P(t)takeO(Kcd3n3)time and O(d2n2)space,
and the matrix operations on W(t)takeO(Kcn3)time and
O(n2)space, where Kcis the number of terms in the equation
forfcandgc. Therefore, each iteration over ttakesO(Kcd3n3)
time and O(d2n2)space. To sum up, for LongSync, the
time complexity is O(Kcd3n3)and the space complexity is
O(d2n2). Forc=3,4,5,6, the number Kcis equal to 1,3,9,32.
In comparison, we consider the initialization step of CEMP .
For each edge ij∈EandL∈Nc
ij, initializing CEMP involves
computing and storing all the cycle inconsistency measures dL
using equation (2). For each L∈Nc
ij, computing dLinvolves
multiplying crotations, which takes O(cd3)time and O(d2)
space. This step is repeated for each ij∈EandL∈Nc
ij,
therefore the total time complexity is O(cd3P
ij∈E|Nc
ij|)andthe total space complexity is O(d2P
ij∈E|Nc
ij|). Since for each
edge there are (n−2)(n−3)···(n−c+1)= O(nc−2)cycle can-
didates, we know that |Nc
ij|∼O(nc−2)for each ij∈Ein the
worst case scenario of a dense graph. Therefore the initialization
of CEMP takes O(cd3nc−2|E|)time and O(d2nc−2|E|)space
in the worst case. Given c≥4and|E|∼n2, CEMP requires
much more time and space than LongSync.
4. Theory for Uniform Corruption Model
In this section, we present the exact recovery guarantee of
LongSync under the uniform corruption model (UCM). UCM is
a popular probabilistic model that is widely adopted for synthetic
experiments of many previous works on group synchronization
[8,25,28,29,32,42]. The model UCM( n,p,q g) assumes that G
is an Erd ˝os-R´enyi graph with edge connection probability p. For
each edge ij∈E,Rijis generated independently as follows:
Rij=(
R∗
ij w.p.qg;
˜Rij∼Haar(G)w.p.1−qg.
We also developed an exact recovery theory for a general
model of adversarial corruption, which we include in section
C.1 of the supplementary material. An informal version of our
main result for UCM is stated in Theorem 4.1. Although the
application of this paper is focused on rotation synchronization,
the following theory for UCM is valid for any compact group
G, as explained in the supplementary material.
Theorem 4.1. Let0<r< 1,0<q < 1,0<p≤1,G=SO(3).
Assume LongSync is applied with cycles of length c,n/logn∼
p−(c−1)/(c−2−ϵ)q−7(c−1)/3(c−2)
g for some ϵ>0and
1/βt+1=r/βtfor all t≥1.
Then with appropriate choices of β0,β1,r, and high probability,
max ij∈E|s∗
ij−s(t)
ij|≤1
2cβtfor all t≥1.
The major difficulty of proving Theorem 4.1 is the depen-
dence in the cycle inconsistency measures for cycles in Nc
ij
when c≥4. Unlike the 3-cycle case, the cycle inconsistency
measure of a 4-cycle L1= (ik1,k1k2,k2j)is correlated with
that of L2= (ik1,k1k3,k3j)under UCM. Therefore the key
concentration inequalities for the proof cannot be concluded
from the standard Chernoff bounds. To overcome this
theoretical obstacle, we have integrated various mathematical
techniques from [ 3,7,22–24,48] to prove the theorem, whose
details are included in the supplementary material.
Theorem 4.1 provides an upper bound of the sample
complexity (the required graph size n) of LongSync for exact
recovery of the ground truth solutions. This sample complexity
is the closest to the information theoretic bound among all
existing rotation synchronization methods. The comparison
with previous works is summarized in Table 2.
5264
Reference Sample Complexity
[25] for CEMP O(p−2q−28/3
g )
[29] for ReSync O(p−2q−7
g)
Ours for CEMP O(p−2−ϵq−14/3
g )
Ours for LongSync ( c=3) O(p−2−ϵq−14/3
g )
Ours for LongSync ( c=4) O(p−1.5−ϵq−3.5
g)
Ours for LongSync (any c) O
p−c−1
c−2−ϵq−7(c−1)
3(c−2)
g
Ours for LongSync ( c→∞ ) O(p−1−ϵq−7/3
g)
Information Theoretic Bound [6] O(p−1q−2
g)
Table 2. Comparison of the sample complexity requirement. Lower
absolute values of the powers on p,qgindicate better results. ϵis an
arbitrarily small positive real number.
5. Synthetic Data Experiment
We test LongSync on synthetic datasets generated with
Uniform Corruption Model (UCM) and Uniform Bipartite
Corruption Model (UBCM) respectively described in §5.1 and
5.2. For both models with their corresponding viewing graphs
G= ([n],E), we sample the ground truth absolute rotation
matrices {R∗
i}i∈[n]independently from the Haar measure
on SO(3), and we generate the observed relative rotations
{Rij}ij∈Eindependently as follows:
Rij=(
R∗
iR∗
j w.p.qg;
˜Rij∼Haar(SO(3)) w.p.1−qg.
We use LongSync with cycle length c,βt=min(2t,20)and
T=10 and record the edge weights. For UCM we set c=4,5
and for UBCM we only use c=4since no 5-cycles exist. For our
method, we first build a weighted graph whose edge weights are
estimated by LongSync. We then extract a maximum spanning
tree (MST) of the resulting weighted graph. The resulting span-
ning tree is expected to be the cleanest possible spanning tree.
To initialize our solution of absolute rotations, we first fix R1as
the identity rotation, and find the rest of Ri’s by consecutively
multiplying the relative rotations along the spanning tree using
the formula Ri=RijRj. To refine our initialized solution, we
apply IRLS with Geman-McClure [ 4] loss functions to mini-
mizeP
ij∈EρGM(d∠(Rij,RiRT
j)), where d∠is the geodesic
distance in SO(3). We refer to this method as LongSync+IRLS.
To demonstrate the advantages of utilizing longer cycle
information, we compare our method with IRLS initialized by
other two different spanning trees. The first one is the random
spanning tree, which uses no cycle information. The other one
the MST extracted from the CEMP-estimated weights. Note
that CEMP only uses 3-cycle information. We refer to these
methods as IRLS and CEMP+IRLS respectively.
Since the solution of absolute rotations is determined up to
a global rotation, we align our estimated rotation {ˆRi}with
{R∗
i}byRalignthat minimizes the ℓ1rotation alignment error
0.86 0.88 0.9 0.92
q050100150Mean errorLongSync4 + IRLS
LongSync5 + IRLS
CEMP + IRLS
IRLS
0.8 0.81 0.82 0.83 0.84 0.85
q050100150Mean errorLongSync4 + IRLS
CEMP + IRLS
IRLSFigure 1. Average errors for IRLS, CEMP+IRLS and LongSync
+IRLS with c=4, 5, using the uniform corruption (top) and uniform
bipartite corruption (bottom) models. The mean errors are measured
in degrees. LongSync4 and LongSync5 refer to LongSync with 4 and
5 cycles, respectively.
P
i∈[n]∥ˆRiRalign−R∗
i∥F. We report the mean estimation error
in degrees: 180·P
i∈[n]d∠(ˆRiRalign,R∗
i)/n.
5.1. Uniform Corruption Model
For UCM( n,p,q g), we take n=200 andp=1and corruption
probability q=1−qgranges from 0.86 to 0.92. We report the
average mean estimation error from 20 trials of the uniform
corruption model in the top panel of Figure 1.
We note that LongSync uniformly improves IRLS, and the
mean error of LongSync decreases as the cycle length increases.
When q>0.86, the expected number of clean 3-cycles for each
edge is less than 4, and therefore longer cycles are helpful. The
numerical result aligns with our theory that using longer cycles
may tolerate higher corruption with fixed graph size n.
5.2. Uniform Bipartite Corruption Model
For UBCM, we first generate the graph and relative rotations by
UCM( n,p,q g) with n=200 ,p=1andq=1−qgranging from
0.8 to 0.85. Then we split the nodes into two clusters of equal
size and remove the intra-cluster edges for both clusters. The
resulting graph is bipartite, where only cycles of even lengths
exist. We report the mean estimation error from 20 trials in the
bottom panel of Figure 1.
We observe that LongSync with 4-cycles almost exactly
recovers the rotations, while for other algorithms the rotation
estimates are not even close to the ground truth.
5265
6. Real Data Experiment
We test distributed synchronization with LongSync on the Pho-
toTourism dataset [ 50] to demonstrate its advantages in accuracy
and speed over other baselines. PhotoTourism is a large scale
dataset consisting of 15 sets of images taken for 3D recon-
struction. The smallest dataset consists of 247 cameras, and the
largest dataset consists of 5433 cameras. The input graph and ini-
tial pairwise rotation estimates are provided in the dataset. In the
following, we first explain the common steps for distributed syn-
chronization, and our improvement using LongSync. We then
describe our graph processing method for filtering bad nodes
and edges, which also is applicable to other baseline methods.
Steps in Distributed Synchronization:
1.Graph partitioning. The first step involves partitioning
the graph G=([n],E)intoKclusters Gi=(Vi,Ei),i∈[K].
In this paper we apply spectral clustering algorithm [ 37]
on the adjacency matrix G, where K= 0.6√npand
p=2|E|/(n(n−1)).
2.Synchronization within clusters. Run standard synchro-
nization solvers for each cluster. In this work, we use the
current state-of-the-art method MPLS [ 39]. Note that for
each camera pin cluster k, one can only estimate the true
rotation R∗
pup to a global rotation Rk. Namely, one only
obtains ˆRp≈R∗
pR−1
kwhereRkis unknown and is the
same for all cameras in cluster k.
3.Estimation of inter-cluster rotations. To find R∗
pof all
cameras, one needs to solve Rkfor all clusters. Namely, one
needs to rotate and stitch the solutions of all clusters so that
they are in the same reference frame. To do this, it is common
to first estimate the inter-clsuter rotations Rkl:=RkR−1
l
between pairs of clusters k,l, and then synchronize these
relative rotations. To estimate each Rkl, we note that Rkl=
R∗−1
pR∗
pqR∗
qfor each p∈Vkandq∈Vl. Therefore, one can
use the rotations in the set Skl:={ˆR−1
pRpqˆRq}p∈Vk,q∈Vl
to approximate Rkl. We remark that this step is crucial to the
overall performance of distributed methods, and we compare
the following methods for solving Rkl:
•MultSync [ 9]: Run synchronization on a multi-graph
where each edge klis assigned a set of relative rotations
{ˆR−1
pRpqˆRq}p∈Vk,q∈Vl. This combines the step 3 and
4 in a unified least squares formulation.
•Edge averaging using IRLS: We initialize ˆRklwith the
quaternion ℓ2mean of the set Skland refine it using
ℓ1-rotation averaging [ 19]. We refer to this method as
IRLS in our comparison.
•Edge averaging using LongSync: We first perform
LongSync with 4-cycles to estimate the weights of these
inter-cluster edges (there are no 3-cycles for a bipartite
graph). We next initialize ˆRklas the quaternion weighted
ℓ2mean of Skl, using the edge weights from LongSync
by their LongSync weights. Lastly, we refine the solution
using [19].4.Synchronization of inter-cluster rotations. This step is
skipped for MultiSync. For other methods described in step
3, we find Rk(up to a rotation) for each cluster kfrom the
estimated {Rkl}k,l∈[K]by MPLS.
5.Rotation merging. Finally, for each camera pin cluster k,
the rotation estimate of pis given by Rfinal
p=ˆRpR−1
k.
Next, we introduce our graph processing method to further
boost the performance of all tested methods.
Extra Improvement by Graph Processing:
•Spectral clustering with Jaccard Index. For step 1, we use
the Jaccard index matrix as the similarity matrix for spectral
clustering, instead of the adjacency matrix. The n×nJaccard
index matrix AJis defined as follows:
AJ(i,j)=(
0 ij̸∈E
|Ni∩Nj|
|Ni∪Nj|ij∈E(14)
where NiandNjdenote the sets of neighboring nodes of
node iandj, respectively. In this way, AJ(i,j)is higher
for the pair ijcontained in many 3-cycles, which is a more
robust and nicely scaled statistics ( ∈[0,1]) for measuring the
local graph density around edge ij.
•Refinement of intra-cluster edges and nodes. For step
2, after the MPLS step, we perform CEMP with 3-cycles
to estimate the corruption level of the intra-cluster edges
for each cluster. We remove a camera if the number of
neighboring ‘good’ edges, i.e. the edges with corruption level
less than 0.1, is less than 4. The numbers 4 and 0.1 are chosen
to balance the number of remaining cameras and the quality
of intra-cluster rotation estimates. In order to eliminate the
sparsely connected components inside the cluster, we use the
Matlab built-in hierarchical spectral clustering function on the
remaining cameras with the ‘cutoff’ and ‘depth’ parameters
as 2 and 4, and we keep the largest component. The absolute
rotations for the remaining cameras are estimated by MPLS.
We remark that one could replace CEMP by LongSync
with 3-cycles. However, we have not observed significant
difference in the performance.
We respectively name MultiSync and IRLS with our new
graph processing method as MultiSync(New) and IRLS(new).
“LongSync” in our experiment refers to the full version of
our algorithm: use LongSync weights for edge averaging
in Step 3, with the graph processing step. We also compare
with MPLS on the whole dataset, since it is a state-of-the-art
non-distributed method, but we note that MPLS is significantly
slower than all distributed methods. We report median
error 180·median ({d∠(ˆRiRalign,R∗
i)}i∈[n]of the tested
methods on 14 datasets in Figure 2. We exclude the result of
Gendarmenmarkt since all methods return large estimation
errors in the figure. The full results, including that of mean
error are included in the supplementary material.
In Figure 3, for each distributed method, we report the
ratio (in percentage) between its total runtime on all datasets
and that of the non-distributed MPLS. Namely, we compute
5266
012345678
ALM EI MM MND ND NYC PDP RF TL US VC PCD TFG YMLongSync
IRLS (New)
IRLS
MultiSync (New)
MultiSync
MPLS on full dataFigure 2. Median error for rotations for each dataset measured in degrees.
0%10%20%30%40%50%60%
Runtime Median Error Mean ErrorLongSync
IRLS (New)
IRLS
MultiSync (New)
MultiSync
Figure 3. Runtime ratio and average median and mean error gaps
between the distributed methods and MPLS on the entire graph.
P
d∈Dtdist,d/P
d∈DtMPLS,d, where Dis the set of 15 datasets,
and each tdist,dandtMPLS,dis respectively the runtime of
the distributed method and MPLS on data d. In the same
figure, we present the mean/median error gap between
each distributed method and MPLS. The mean and median
error gap is respectively defined as (¯edist−¯eMPLS)/¯edistand
(ˆedist−ˆeMPLS)/ˆedist, where ¯eandˆerespectively denote the mean
and median error over all cameras.
From Figure 2 and 3, our method outperforms other dis-
tributed methods on 13 out of 15 datasets. The most significant
improvement in mean error and median error are respectively
28.6%and46.4%(in Notre Dame) compared to the best per-
forming method between IRLS(new) and MultiSync(new). The
improvement is even more significant when comparing to the
original version of these baseline methods without our graph pro-
cessing method. The only two datasets without improvement are
Gendarmenmarkt and Union Square. Our method is comparable
to others on Union Square, and all methods return large errors on
Gendarmenmarkt due to many repetitive patterns in its 3D scene.The average mean and median error gap between our method
and full MPLS are respectively 38.3%and18.4%. Compared to
the best performing method among others, our method reduces
the average median error gap by 40.8%, and the average mean
error gap by 9.6%. In terms of runtime, our method is uniformly
faster than MultiSync and it is scalable on the largest dataset,
taking less than 6%of the total runtime of full MPLS. In conclu-
sion, our method significantly improves the result of distributed
rotation synchronization without compromising runtime.
In the supplementary material, we further demonstrate the
improvement by our new graph processing method, which
significantly improves the results of LongSync (without extra
graph processing) in 14 of the 15 datasets. On these 14 datasets,
the average reduction on mean error is 59.2%and the average
reduction on median error is 28.5%.
7. Conclusion
We propose LongSync, a robust and efficient algorithm for
group synchronization. It modifies and vectorizes CEMP which
enables efficient computation when using longer cycles. The
theory we developed for LongSync is the strongest among
all other existing results under UCM. Experiment shows that
LongSync, together with our improved graph preprocessing
method, achieves superior accuracy for distributed synchroniza-
tion on large real datasets with competitive runtime. However,
our method also has some limitations. First of all, in theory there
is still a small gap of sample complexity from our method to the
information theoretic one. Filling this gap is an open problem,
which requires new tools and possibly more sophisticated anal-
ysis. Second, our graph preprocessing method is quite heuristic,
and an automatic way of choosing parameters is needed. Our
work also opens a door for some important future directions,
including distributed partial permutation synchronization for
multi-image matching, angular synchronization for Cryo-EM
and Jigsaw Puzzles, and analysis of their algorithms.
5267
References
[1]Federica Arrigoni, Beatrice Rossi, Pasqualina Fragneto, and
Andrea Fusiello. Robust synchronization in so(3) and se(3) via
low-rank and sparse matrix decomposition. Computer Vision
and Image Understanding , 174:95–113, 2018. 2
[2]A. S. Bandeira, N. Boumal, and A. Singer. Tightness of
the maximum likelihood semidefinite relaxation for angular
synchronization. arXiv preprint arXiv:1411.3272 , 2014. 2
[3]Olivier Bousquet. A Bennett concentration inequality and its
application to suprema of empirical processes. C. R. Math. Acad.
Sci. Paris , 334(6):495–500, 2002. 5, 14, 16, 21
[4]Avishek Chatterjee and V enu Madhav Govindu. Efficient and
robust large-scale rotation averaging. In IEEE International
Conference on Computer Vision, ICCV 2013, Sydney, Australia,
December 1-8, 2013 , pages 521–528, 2013. 2, 6
[5]Avishek Chatterjee and V enu Madhav Govindu. Robust relative
rotation averaging. IEEE Trans. Pattern Anal. Mach. Intell. ,
40(4):958–972, 2018. 2
[6]Y uxin Chen, Changho Suh, and Andrea J. Goldsmith. Infor-
mation recovery from pairwise measurements. IEEE Trans. Inf.
Theory , 62(10):5881–5905, 2016. 6
[7]Kereszt ´ely Corradi and Andr ´as Hajnal. On the maximal number
of independent circuits in a graph. Acta Mathematica Hungarica ,
14(3-4):423–439, 1963. 5, 14
[8]Mihai Cucuringu. Synchronization over Z2 and community
detection in signed multiplex networks with constraints. J.
Complex Networks , 3(3):469–506, 2015. 5
[9]Andrea Porfiri Dal Cin, Luca Magri, Federica Arrigoni, Andrea
Fusiello, and Giacomo Boracchi. Synchronization of group-
labelled multi-graphs. In 2021 IEEE/CVF International Confer-
ence on Computer Vision (ICCV) , pages 6433–6443, 2021. 2, 7
[10] Frank Dellaert, David M. Rosen, Jing Wu, Robert E. Mahony,
and Luca Carlone. Shonan rotation averaging: Global optimality
by surfing so(p)n. In Andrea V edaldi, Horst Bischof, Thomas
Brox, and Jan-Michael Frahm, editors, Computer Vision - ECCV
2020 - 16th European Conference, Glasgow, UK, August 23-28,
2020, Proceedings, Part VI , volume 12351 of Lecture Notes in
Computer Science , pages 292–308. Springer, 2020. 2
[11] Anders Eriksson, Carl Olsson, Fredrik Kahl, and Tat-Jun Chin.
Rotation averaging and strong duality, 2017.
[12] Anders P . Eriksson, Carl Olsson, Fredrik Kahl, and Tat-Jun
Chin. Rotation averaging and strong duality. In 2018 IEEE
Conference on Computer Vision and Pattern Recognition, CVPR
2018, Salt Lake City, UT, USA, June 18-22, 2018 , pages 127–135.
Computer Vision Foundation / IEEE Computer Society, 2018.
[13] Anders P . Eriksson, Carl Olsson, Fredrik Kahl, and Tat-Jun Chin.
Rotation averaging with the chordal distance: Global minimizers
and strong duality. IEEE Trans. Pattern Anal. Mach. Intell. ,
43(1):256–268, 2021. 2
[14] Xiang Gao, Hainan Cui, Menghan Li, Zexiao Xie, and Shuhan
Shen. Irav3: Hierarchical incremental rotation averaging on the
fly.IEEE Trans. Circuits Syst. Video Technol. , 33(4):2001–2006,
2023. 2
[15] Xiang Gao, Hainan Cui, and Shuhan Shen. Incremental
rotation averaging revisited and more: A new rotation averaging
benchmark. arXiv preprint , abs/2309.16924, 2023.
[16] Xiang Gao, Lingjie Zhu, Hainan Cui, Zexiao Xie, and Shuhan
Shen. IRA++: distributed incremental rotation averaging. IEEE
Trans. Circuits Syst. Video Technol. , 32(7):4885–4892, 2022. 2[17] Thomas Goldstein, Paul Hand, Choongbum Lee, Vladislav
V oroninski, and Stefano Soatto. Shapefit and shapekick for robust,
scalable structure from motion. In Computer Vision - ECCV 2016
- 14th European Conference, Amsterdam, The Netherlands, Octo-
ber 11-14, 2016, Proceedings, Part VII , pages 289–304, 2016. 1
[18] V .M. Govindu. Lie-algebraic averaging for globally consistent
motion estimation. In Proceedings of the 2004 IEEE Computer
Society Conference on Computer Vision and Pattern Recognition,
2004. CVPR 2004. , volume 1, pages I–I, 2004. 2
[19] R. Hartley, K. Aftab, and J. Trumpf. L1 rotation averaging
using the weiszfeld algorithm. In Computer Vision and
Pattern Recognition (CVPR), 2011 IEEE Conference on , pages
3041–3048. IEEE, 2011. 7
[20] Richard I. Hartley, Khurrum Aftab, and Jochen Trumpf. L1
rotation averaging using the weiszfeld algorithm. In The 24th
IEEE Conference on Computer Vision and Pattern Recognition,
CVPR 2011, Colorado Springs, CO, USA, 20-25 June 2011 ,
pages 3041–3048, 2011. 2
[21] Xiangru Huang, Zhenxiao Liang, Xiaowei Zhou, Yao Xie,
Leonidas J. Guibas, and Qixing Huang. Learning transformation
synchronization. In Proceedings of the IEEE/CVF Conference on
Computer Vision and Pattern Recognition (CVPR) , June 2019. 2
[22] Svante Janson. Poisson approximation for large deviations.
Random Structures & Algorithms , 1(2):221–229, 1990. 5, 14, 16
[23] Svante Janson. Large deviations for sums of partly depen-
dent random variables. Random Structures & Algorithms ,
24(3):234–248, 2004. 18, 21
[24] Jeong Han Kim and V an H Vu. Concentration of multivariate
polynomials and its applications. Combinatorica , 20(3):417–434,
2000. 5, 14, 18
[25] Gilad Lerman and Y unpeng Shi. Robust group synchronization
via cycle-edge message passing. F oundations of Computational
Mathematics , 22(6):1665–1741, 2022. 1, 2, 3, 5, 6, 13, 14, 16,
19, 21
[26] Heng Li, Zhaopeng Cui, Shuaicheng Liu, and Ping Tan. RAGO:
recurrent graph optimizer for multiple rotation averaging.
InIEEE/CVF Conference on Computer Vision and Pattern
Recognition, CVPR 2022, New Orleans, LA, USA, June 18-24,
2022 , pages 15766–15775. IEEE, 2022. 2
[27] Shaohan Li, Y unpeng Shi, and Gilad Lerman. Fast, accurate and
memory-efficient partial permutation synchronization. In Pro-
ceedings of the IEEE/CVF Conference on Computer Vision and
Pattern Recognition (CVPR) , pages 15735–15743, June 2022. 2
[28] Shuyang Ling. Near-optimal performance bounds for orthogonal
and permutation group synchronization via spectral methods.
arXiv preprint arXiv:2008.05341 , 2020. 5
[29] Huikang Liu, Xiao Li, and Anthony Man-Cho So. Resync:
Riemannian subgradient-based robust rotation synchronization.
InAdvances in Neural Information Processing Systems: 37th
Annual Conference on Neural Information Processing Systems ,
2023. 2, 5, 6
[30] Tyler Maunu and Gilad Lerman. Depth descent synchronization
in SO(D). Int. J. Comput. Vis. , 131(4):968–986, 2023. 2
[31] Onur ¨Ozyesil and Amit Singer. Robust camera location
estimation by convex programming. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition , pages
2674–2683, 2015. 1
[32] Deepti Pachauri, Risi Kondor, and Vikas Singh. Solving the
multi-way matching problem by permutation synchronization. In
5268
C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q.
Weinberger, editors, Advances in Neural Information Processing
Systems 26 , pages 1860–1868. Curran Associates, Inc., 2013. 5
[33] ´Alvaro Parra, Shin-Fang Ch’ng, Tat-Jun Chin, Anders P . Eriksson,
and Ian Reid. Rotation coordinate descent for fast globally opti-
mal rotation averaging. In IEEE Conference on Computer Vision
and Pattern Recognition, CVPR 2021, virtual, June 19-25, 2021 ,
pages 4298–4307. Computer Vision Foundation / IEEE, 2021. 2
[34] Pulak Purkait, Tat-Jun Chin, and Ian Reid. Neurora: Neural
robust rotation averaging, 2020. 2
[35] Ian C Ross and Frank Harary. On the determination of redun-
dancies in sociometric chains. Psychometrika , 17(2):195–208,
1952. 4, 12
[36] Tianwei Shen, Siyu Zhu, Tian Fang, Runze Zhang, and Long
Quan. Graph-based consistent matching for structure-from-
motion. In European Conference on Computer Vision , pages
139–155. Springer, 2016. 2
[37] Jianbo Shi and J. Malik. Normalized cuts and image segmen-
tation. IEEE Transactions on Pattern Analysis and Machine
Intelligence , 22(8):888–905, 2000. 7
[38] Y unpeng Shi and Gilad Lerman. Estimation of camera locations
in highly corrupted scenarios: All about that base, no shape
trouble. In 2018 IEEE Conference on Computer Vision and
Pattern Recognition, CVPR 2018, Salt Lake City, UT, USA, June
18-22, 2018 , pages 2868–2876, 2018. 2
[39] Y unpeng Shi and Gilad Lerman. Message passing least squares
framework and its application to rotation synchronization. In
Proceedings of the 37th International Conference on Machine
Learning (ICML) , 2020. 1, 2, 7
[40] Y unpeng Shi, Shaohan Li, and Gilad Lerman. Robust multi-
object matching via iterative reweighting of the graph connection
laplacian. Advances in Neural Information Processing Systems ,
2020-December, 2020. 2
[41] Chitturi Sidhartha and V enu Madhav Govindu. It is all in the
weights: Robust rotation averaging revisited. In International
Conference on 3D Vision, 3DV 2021, London, United Kingdom,
December 1-3, 2021 , pages 1134–1143. IEEE, 2021. 2
[42] Amit Singer. Angular synchronization by eigenvectors and
semidefinite programming. Applied and computational
harmonic analysis , 30(1):20–36, 2011. 2, 5
[43] A. Singer and Y . Shkolnisky. Angular synchronization by eigen-
vectors and semidefinite programming: Analysis and application
to class averaging in cryo-electron microscopy, 2009. 2
[44] Johan Thunberg, Florian Bernard, and Jorge Goncalves.
Distributed methods for synchronization of orthogonal matrices
over graphs. Automatica , 80:243–252, jun 2017. 2
[45] Roberto Tron and Ren ´e Vidal. Distributed image-based 3-d
localization of camera sensor networks. In Proceedings of the
48th IEEE Conference on Decision and Control, CDC 2009,
December 16-18, 2009, Shanghai, China , pages 901–908, 2009. 2
[46] Anton V oropaev and Sergey Perepechko. The number of
fixed length cycles in undirected graph. explicit formulae in
case of small lengths. Bulletin of PFUR. Series Mathematics,
Information Sciences, Physics , pages 5–11, 01 2012. 4
[47] Anton V oropaev and Sergey Perepechko. The number of
fixed length cycles in undirected graph. explicit formulae in
case of small lengths. Bulletin of PFUR. Series Mathematics,
Information Sciences, Physics , pages 5–11, 01 2012. 13
[48] V an H Vu. A large deviation result on the number of smallsubgraphs of a random graph. Combinatorics, Probability and
Computing , 10(1):79–94, 2001. 5, 14, 17
[49] Lanhui Wang and Amit Singer. Exact and stable recovery of
rotations for robust synchronization. Information and Inference ,
2013. 2
[50] Kyle Wilson and Noah Snavely. Robust global translations
with 1dsfm. In Computer Vision - ECCV 2014 - 13th European
Conference, Zurich, Switzerland, September 6-12, 2014,
Proceedings, Part III , pages 61–75, 2014. 7
[51] Christopher Zach, Manfred Klopschitz, and Marc Pollefeys.
Disambiguating visual relations using loop constraints. In The
Twenty-Third IEEE Conference on Computer Vision and Pattern
Recognition, CVPR 2010, San Francisco, CA, USA, 13-18 June
2010 , pages 1426–1433, 2010. 2
5269
