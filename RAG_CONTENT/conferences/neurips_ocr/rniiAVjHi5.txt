Universality of AdaGrad Stepsizes for Stochastic
Optimization: Inexact Oracle, Acceleration and
Variance Reduction
Anton Rodomanov
CISPA∗
anton.rodomanov@cispa.deXiaowen Jiang
Saarland University and CISPA∗
xiaowen.jiang@cispa.deSebastian Stich
CISPA∗
stich@cispa.de
Abstract
We present adaptive gradient methods (both basic and accelerated) for solving
convex composite optimization problems in which the main part is approximately
smooth (a.k.a. (δ, L)-smooth) and can be accessed only via a (potentially biased)
stochastic gradient oracle. This setting covers many interesting examples including
Hölder smooth problems and various inexact computations of the stochastic gradi-
ent. Our methods use AdaGrad stepsizes and are adaptive in the sense that they do
not require knowing any problem-dependent constants except an estimate of the
diameter of the feasible set but nevertheless achieve the best possible convergence
rates as if they knew the corresponding constants. We demonstrate that AdaGrad
stepsizes work in a variety of situations by proving, in a unified manner, three
types of new results. First, we establish efficiency guarantees for our methods in
the classical setting where the oracle’s variance is uniformly bounded. We then
show that, under more refined assumptions on the variance, the same methods
without any modifications enjoy implicit variance reduction properties allowing us
to express their complexity estimates in terms of the variance only at the minimizer.
Finally, we show how to incorporate explicit SVRG-type variance reduction into
our methods and obtain even faster algorithms. In all three cases, we present both
basic and accelerated algorithms achieving state-of-the-art complexity bounds. As
a direct corollary of our results, we obtain universal stochastic gradient methods
for Hölder smooth problems which can be used in all situations.
1 Introduction
Motivation. Gradient methods are among the most popular and efficient optimization algorithms
for solving machine learning problems. To achieve the best convergence speed for these algorithms,
their stepsizes needs to be chosen properly. While there exist various theoretical recommendations,
dictated by the convergence analysis, on how to select stepsizes based on various problem-dependent
parameters, they are usually impractical because the corresponding constants may be unknown or their
worst-case estimates might be too pessimistic. Furthermore, every applied problem usually belongs
to multiple problem classes at the same time, and it is not always evident in advance which of them
better suits the concrete problem instance one works with. For classical optimization algorithms, this
problem is typically resolved by using a line search. This is a simple yet powerful mechanism which
automatically chooses the best stepsize by checking at each iteration a certain condition involving the
objective value, its gradient, etc.
However, the line-search approach is usually unsuitable for problems of stochastic optimization,
where gradients are observed with random noise (unless some extra assumptions are made, see [57]).
For these problems, it is common instead to apply so-called adaptive methods which set up their
∗CISPA Helmholtz Center for Information Security, Saarbrücken, Germany
38th Conference on Neural Information Processing Systems (NeurIPS 2024).stepsizes by simply accumulating on-the-fly certain information about observed stochastic gradients.
The first such an algorithm, AdaGrad [17, 39], was obtained from theoretical considerations but
quickly inspired several other heuristic methods like RMSProp [56] and Adam [32] that are now at
the forefront of training machine learning models.
Excellent practical performance of adaptive methods on various applied problems naturally sparked a
lot of theoretical interest in these algorithms. An important observation was done by Levy, Yurtsever,
and Cevher [34] who showed that AdaGrad possesses a certain universality property, in the sense
that it works for several problem classes simultaneously. Specifically, they showed that AdaGrad
converges both for nonsmooth problems with bounded gradient and also for smooth problems with
Lipschitz gradient, without needing to know neither the corresponding Lipschitz constants, nor
the oracle’s variance but enjoying the rates which are characteristic for algorithms which have the
knowledge of these constants. They also presented an accelerated version of AdaGrad with similar
properties. An independent version of the accelerated AdaGrad including diagonal scaling was
proposed by Deng, Cheng, and Lan [12]. Further improvements and generalization of these ideas
were considered in [18, 28, 30].
Nonsmooth and smooth problems are the extremes of the more general Hölder class of problems.
The fact that AdaGrad methods simultaneously work for these two extreme cases does not seem to be
a coincidence and suggests that these algorithms should work more generally for any problem with
intermediate level of smoothness. Some further confirmations to this were recently provided in [48]
although in a rather restricted setting of deterministic problems and only for the basic AdaGrad
method. The stochastic case and acceleration were constituting an open problem which was recently
resolved in [49] for a slightly modified AdaGrad stepsize (see (4)).
All the previously discussed results were proved only for the classical stochastic optimization setting
where the variance of stochastic gradients is assumed to be uniformly bounded. In a recent work,
Attia and Koren [2] showed that the basic AdaGrad method for smooth problems works under the
more general assumption when the variance is bounded by a constant plus a multiple of the squared
gradient norm. On a related note, it was also shown recently that AdaGrad stepsizes can be used inside
gradient methods with SVRG-type variance-reduction. The first such an algorithm was proposed
in [16]. The accelerated SVRG method enjoying optimal worst-case oracle complexity for smooth
finite-sum optimization problems was later presented in [36].
Contributions. In this work, we further extend the results mentioned above by demonstrating that
AdaGrad stepsizes are even more universal than was shown previously in the literature. Specifically,
we consider the composite optimization problem where the main part is approximately smooth
(a.k.a. (δ, L)-smooth) and can be accessed only via a (potentially biased) stochastic gradient oracle.
This setting is more general than typically considered in the literature on adaptive methods and
covers many interesting examples, including smooth, nonsmooth and, more generally, Hölder smooth
problems, problems in which the objective function is given itself as another optimization problem
whose solution can be computed only approximately, etc.
Our contributions can be summarized as follows:
1.We start, in Section 3, with identifying the key property of AdaGrad stepsizes, which allows us to
apply these stepsizes, in a unified manner, in a variety of situations we consider later. We present
our two mains algorithms, UniSgd andUniFastSgd which are the classical stochastic gradient
method (SGD) and its accelerated version, respectively, equipped with AdaGrad stepsizes.
2.We then establish, in Section 4, efficiency guarantees for these methods in the classical setting
where the oracle’s variance is assumed to be uniformly bounded.
3.In Section 5, we complement these results by showing that, under additional assumptions that
the variance is itself approximately smooth w.r.t. the objective function, the same UniSgd and
UniFastSgd without any modifications enjoy implicit variance reduction properties allowing us
to express their complexity estimates in terms of the variance only at the minimizer.
4.Under the additional assumption that one can periodically compute the full (inexact) gradient of
the objective function, we show, in Section 6, how to incorporate explicit SVRG-type variance
reduction into our methods, obtaining new UniSvrg andUniFastSvrg algorithms which enjoy
even faster convergence rates by completely eliminating the variance.
Our results are summarized in Table 1 (in the BigO-notation). In all the situations, we present both
basic and accelerated algorithms whose only essential parameter is an estimate Dof the diameter
2Table 1: Summary of main results for solving problem (1)with our methods. “Convergence rate” is expressed in
terms of the expected function residual at iteration k(ort, depending on the method). “SO complexity” denotes
the cumulative stochastic-oracle complexity of the method since its start and up to iteration k(ort), which is
defined as the number of queries to the stochastic oracle pg; for SVRG methods, we assume that querying the
(inexact) full-gradient oracle sgisntimes more expensive than pg, and define the SO complexity as Npg+nNsg,
where NpgandNsgare the number of queries to pgandsg, respectively. The second and third columns should be
understood in terms of the BigO-notation which we omit for brevity.
Method Convergence rate SO complexity Assumptions Reference
UniSgd (Alg. 1)LfD2
k+σD√
k+δfk1, 2, 3 Thm. 4
(Lf+Lpg)D2
k+σ∗D√
k+δf+δpg 1, 2, 6 Thm. 7
UniFastSgd (Alg. 2)LfD2
k2+σD√
k+kδfk1, 2, 3 Thm. 5
LfD2
k2+LpgD2
k+σ∗D√
k+kδf+δpg 1, 2, 6 Thm. 8
UniSvrg (Alg. 3)(Lf+Lpg)D2
2t +δf+δpg 2t+nlogt 1, 2, 6, 9 Thm. 10
UniFastSvrg (Alg. 4)(Lf+Lpg)D2
n(t−log log n)2+t(δf+δpg) nt 1, 2, 6 Thm. 11
of the feasible set; the methods automatically adapt to all other problem-dependent constants. In
a number of special cases, our algorithms achieve known state-of-the-art complexity bounds, but
not restricted to those special cases. In Section 7, we illustrate the significance of our results by
demonstrating that complexities for our methods on stochastic optimization problems with Hölder
smooth components can be obtained as simple corollaries from our main results.
2 Preliminaries
Notation. We work in the space Rdequipped with the standard inner product ⟨·,·⟩and a certain
Euclidean norm: ∥x∥:=⟨Bx, x⟩1/2, where Bis a fixed positive definite matrix. The dual norm is
defined in the standard way: ∥s∥∗:= max ∥x∥=1⟨s, x⟩=⟨s, B−1s⟩1/2.
For a convex function ψ:Rd→R∪ {+∞}, its (effective) domain is the following set: domψ:=
{x∈Rd:ψ(x)<+∞}. By∂ψ(x), we denote the subdifferential of ψat a point x∈domψ; the
specific subgradients are typically denoted by ∇ψ(x).
A convex function f:Rd→Ris called (ν, H)-Hölder smooth for some ν∈[0,1]andH≥0iff
∥∇f(x)− ∇f(y)∥∗≤H∥x−y∥νfor all x, y∈Rdand all ∇f(x)∈∂f(x),∇f(y)∈∂f(y).
Apart from the special case of ν= 0, such a function fis differentiable at every point, i.e., ∂f(x)is
a singleton. A (1, L)-Hölder smooth function is usually called L-smooth.
For a convex function ψ:Rd→R∪{+∞}, point x∈Rd, vector g∈Rd, and coefficient M≥0, by
Prox ψ(x, g, M ):= argminy∈domψ{⟨g, y⟩+ψ(y)+M
2∥y−x∥2}, we denote the proximal mapping.
When M= 0, we allow the solution to be chosen arbitrarily.
For a convex function f:Rd→R, points x, y∈Rdand∇f(x)∈∂f(x), we denote the Bregman
distance by β∇f(x)
f(x, y):=f(y)−f(x)− ⟨∇ f(x), y−x⟩(≥0). When the specific subgradient
∇f(x)is clear from the context, we use the simplified notation βf(x, y).
The positive part of t∈Ris[t]+:= max {t,0}. For τ >0, we also use log+τ:= max {1,logτ}.
Problem Formulation. In this paper, we consider the composite optimization problem
F∗:= min
x∈domψ
F(x):=f(x) +ψ(x)
, (1)
where f:Rd→Ris a convex function, and ψ:Rd→R∪{+∞}is a proper closed convex function
which is assumed to be sufficiently simple in the sense that the proximal mapping Prox ψcan be
easily computed. We assume that this problem has a solution which we denote by x∗.
To quantify the smoothness level of the objective function, we use the following assumption:
3Algorithm 1 (sxN, xN, MN)∼=UniSgdpg,ψ(x0, M 0, N;D)
Input: Oraclepg, comp. part ψ, point x0∈domψ, coefficient M0, iteration limit N, diameter D.
1:g0∼=pg(x0).
2:fork= 0, . . . , N −1do
3: xk+1= Prox ψ(xk, gk, Mk),gk+1∼=pg(xk+1).
4: Mk+1=M+(Mk, D2, xk, xk+1, gk, gk+1) ▷e.g.,(3)=q
M2
k+1
D2∥gk+1−gk∥2∗.
5:return (sxN, xN, MN), wheresxN:=1
NPN
i=1xi.
Assumption 1. The function fin problem (1)is approximately smooth: there exist constants
Lf, δf≥0andsf:Rd→R,sg:Rd→Rdsuch that, for any x, y∈Rd,βf,sf,sg(x, y):=f(y)−
sf(x)− ⟨sg(x), y−x⟩satisfies the following inequality: 0≤βf,sf,sg(x, y)≤Lf
2∥x−y∥2+δf.
Assumption 1 is well-known in the literature under the name (δ, L)-oracle and was originally
introduced in [15]. It covers many interesting examples. For instance, if fisL-smooth, then
Assumption 1 is satisfied with sf=f,sg=∇f,δf= 0andLf=L. More generally, if the function f
is(ν, H f(ν))-Hölder smooth, then Assumption 1 is satisfied with sf=f,sg=∇f(arbitrary selection
of subgradients), any δf>0andLf:= [1−ν
2(1+ν)δf]1−ν
1+ν[Hf(ν)]2
1+ν(see Theorem 13). If fcan be
uniformly approximated by an L-smooth function ϕ, i.e.,ϕ(x)≤f(x)≤ϕ(x)+δ, then Assumption 1
is satisfied with sf=ϕ,sg=∇ϕandδf=δ. Iffrepresents another auxiliary optimization problem
with a strongly concave objective, e.g., f(x) = max uΨ(x, u), whose solution su(x)can only be found
with accuracy δ, then fsatisfies Assumption 1 with sf(x) = Ψ( x,su(x)),sg(x) =∇uΨ(x,su(x))and
δf=δ. For more details and other interesting examples, we refer the reader to [15].
In what follows, we assume that we have access to an unbiased stochastic oracle pgforsg. Formally,
this is a pair pg= (g, ξ)consisting of a random variable ξand a mapping g:Rd×Imξ→Rd
(with Imξbeing the image of ξ). When queried at a point x, the oracle automatically generates an
independent copy ξof its randomness and then returns pgx=g(x, ξ)(notation:pgx∼=pg(x)). We call
gandξthe function component and the random variable component of pg, respectively. At this point,
we only assume that our stochastic oracle pgis un unbiased estimator of sg, and later make various
assumptions on its variance.
Another important assumption on problem (1), that we need in our analysis, is the boundedness of
the feasible set domψ.
Assumption 2. There exists D > 0such that ∥x−y∥ ≤Dfor any x, y∈domψ.
Assumption 2 is rather standard in the literature on adaptive methods for stochastic convex op-
timization (see [16, 18, 30, 34, 36, 49]) and can always be ensured with D= 2R0whenever
one has the knowledge of an upper bound R0on the distance from the initial point x0to the so-
lution x∗. To that end, it suffices to rewrite the problem (1)in the following equivalent form:
minx∈domψD[f(x) +ψD(x)], where ψDis the sum of ψand the indicator function of the ball
B0:={x∈Rd:∥x−x0∥ ≤R0}. Note that this transformation keeps the function ψDreasonably
simple as its proximal mapping can be computed via that of ψby solving a certain one-dimensional
nonlinear equation, which can be done very efficiently by Newton’s method (at no extra queries to the
stochastic oracle); in some special cases, the corresponding nonlinear equation can even be solved
analytically, e.g., when ψ= 0, the proximal mapping of ψDis simply the projection on B0.
Throughout this paper, we refer to Dfrom Assumption 2 as the diameter of the feasible set, and
assume that its value is known to us. This will be the only essential parameter in our methods.
3 Main Algorithms and Stepsize Update Rules
We now present our two main algorithms for solving problem (1):UniSgd (Algorithm 1), and
its accelerated version, UniFastSgd (Algorithm 2). Except the specific choice of the stepsize
coefficients Mk, both algorithms are rather standard: the first one is the classical SGD method, and
the second one is the classical accelerated gradient method for stochastic optimization [33], also
known as the Method of Similar Triangles (see, e.g., Section 6.1.3 in [46]).
Both methods are expressed in terms of a certain abstract stepsize update rule M+(·)defined as
follows. Given the current stepsize coefficient M≥0, constant Ω>0(the scaled squared diameter),
4Algorithm 2 UniFastSgdpg,ψ(x0;D)
Input: Stochastic oracle pg, composite part ψ, point x0∈domψ, diameter D.
1:v0=x0,M0=A0= 0.
2:fork= 0,1, . . . do
3: ak+1=1
2(k+ 1) ,Ak+1=Ak+ak+1.
4: yk=Ak
Ak+1xk+ak+1
Ak+1vk,gyk∼=pg(yk).
5: vk+1= Prox ψ(vk, gyk,Mk
ak+1).
6: xk+1=Ak
Ak+1xk+ak+1
Ak+1vk+1,gxk+1∼=pg(xk+1).
7: Mk+1=a2
k+1
Ak+1M+ Ak+1
a2
k+1Mk,a2
k+1
A2
k+1D2, yk, xk+1, gyk, gxk+1
▷e.g.,(3)=r
M2
k+a2
k+1
D2∥gxk+1−gyk∥2∗.
current point x∈domψwith the stochastic gradient pgx∼=pg(x), next iterate px+=x+(pgx)∈domψ
(which is the result of the deterministic function applied to pgx), and the corresponding stochastic
gradientpgx+∼=pg(px+), the update rule computes xM+=M+(M,Ω, x,px+,pgx,pgx+)(deterministic
function of its arguments) such that xM+≥Mand the following inequality holds for any ĎM > c 2Lf:
E[p∆(xM+) + (xM+−M)Ω + βf,sf,sg(px+, x)]
≤c1
ĎM−c2LfE[Varpg(px+) + Var pg(x)] +c3δf+c4E
[min{xM+,ĎM} −M]+Ω	
,(2)
wherep∆(xM+):=βf,sf,sg(x,px+) +⟨sg(x)−pgx,px+−x⟩−xM+
2∥px+−x∥2,c1, c2, c3, c4>0are some
absolute constants, and Varpg(x):=Eξ[∥g(x, ξ)−sg(x)∥2
∗]is the variance of pg. The expectations
in (2) are taken w.r.t. the randomness (ξ, ξ+)coming from pgx≡g(x, ξ),pgx+≡g(px+, ξ+).
The main example is the following AdaGrad rule:
xM+=r
M2+1
Ω∥pgx+−pgx∥2∗. (3)
For this rule, we have c1=5
2,c2= 4,c3= 6,c4= 2(see Lemma 20). Another interesting example
recently suggested in [49] is xM+found from the equation
(xM+−M)Ω =h
⟨pgx+−pgx,px+−x⟩ −xM+
2∥px+−x∥2i
+. (4)
This equation admits a unique solution which can be easily written down in closed form (see
Lemma E.1 in [49]). For this rule, we have c1= 1,c2= 2,c3= 6,c4= 2(see Lemma 21).
Inequality (2)is the only property we need from the stepsize update rule to establish all forthcoming
results. This inequality is exactly what is typically used inside the convergence proofs for stochastic
gradient methods with predefined stepsizes Mk≡ĎM(in which case M=xM+=ĎM), where
ĎMdepends on problem-dependent constants. The key property of AdaGrad stepsizes (either (3)
or(4)) is that they ensure the same inequality but now ĎMis the virtual stepsize existing only
in the theoretical analysis. The price for this is the extra error term [min{xM+,ĎM} −M]+Ω
appearing in the right-hand side of (2). The crucial property of this error term is that it is telescopic,Pk
i=0[min{Mi+1,ĎM} −Mi]+Ω = [min {Mk+1,ĎM} −M0]+Ω(see Lemma 18) and therefore its
total cumulative impact is always bounded by the controllable constant ĎMΩ. Although a number of
other works on theoretical analysis of AdaGrad methods for smooth optimization use some similar
ideas about the virtual stepsize (e.g., [30, 34, 36]), this is the first time one has abstracted away all the
technical details and identified the specific inequality (2)responsible for the universality of AdaGrad.
4 Uniformly Bounded Variance
In this section, we assume that the variance of our stochastic oracle is uniformly bounded.
Assumption 3. For the stochastic oracle pg, we have σ2:= supx∈domψVarpg(x)<+∞, where
Varpg(x):=Eξ[∥g(x, ξ)−sg(x)∥2
∗].
5Under this assumption, we can establish the following efficiency estimates for our UniSgd and
UniFastSgd methods (the proofs are deferred to Appendix C).
Theorem 4. Let Algorithm 1 with M0= 0be applied to problem (1)under Assumptions 1–3. Then,
for the point sxNgenerated by the algorithm, we have
E[F(sxN)]−F∗≤c2c4LfD2
N+ 2σDr
2c1c4
N+c3δf.
Theorem 5. Let Algorithm 2 be applied to problem (1)under Assumptions 1–3. Then, for any k≥1,
E[F(xk)]−F∗≤4c2c4LfD2
k(k+ 1)+ 4σDr
2c1c4
3k+c3
3(k+ 2)δf.
We see that, in contrast to UniSgd , the accelerated algorithm UniFastSgd is not robust to the
oracle’s errors: it accumulates them with time at the rate of O(kδ). This is not surprising since the
same phenomenon also occurs in the classical accelerated gradient method, even when the oracle is
deterministic and the algorithm has the knowledge about all constants (see [15]).
The complexity results from Theorems 4 and 5 are similar to those from [13]. However, it is important
that our methods are adaptive and do not require knowing the constants Lfandσ.
In the specific case when δf= 0, we recover the same convergence rates as in [30, 34], although our
methods work for the more general composite optimization problem and, in contrast to [34], do not
require that ∇f(x∗) = 0 .
5 Implicit Variance Reduction
The assumption of uniformly bounded variance may not hold for some problems, or the corresponding
constant σ2might be quite large, which is why there has recently been a growing interest in various
alternative variance bound assumptions [5, 22, 24, 29, 42, 54, 59]. One interesting option is expressing
complexity bounds via the variance at the minimizer, σ2
∗:= Varpg(x∗), assuming that the stochastic
oraclepgsatisfies some extra smoothness conditions. Let us show that, for our Algorithms 1 and 2,
we can also establish such bounds, moreover, this can be done without any modifications to the
algorithms .
In this section, we study problem (1)under Assumptions 1 and 2 and also under the following
additional smoothness assumption on the variance:
Assumption 6. There exist δpg, Lpg≥0such that Varpg(x, y)≤2Lpg[βf,sf,sg(x, y) +δpg]for any
x, y∈Rd, where Varpg(x, y):=Eξ[∥[g(x, ξ)−g(y, ξ)]−[sg(x)−sg(y)]∥2
∗].
Note that Varpg(x, y)is the usual variance of the estimator g(x, ξ)−g(y, ξ)which uses the same
randomness ξfor both arguments. Hence, Varpg(x, y)≤E[∥g(x, ξ)−g(y, ξ)∥2
∗]for any x, y.
Furthermore, if pgbis the mini-batch version of pgof size b(i.e., the average of bi.i.d. samples of pg(x)
at any point x), then Varpgb(x, y) =1
bVarpg(x, y)for any x, y.
For instance, if f(x) =Eξ[fξ(x)], where each function fξis convex and (δξ, Lξ)-approximately
smooth with components (sfξ,sgξ), then, the stochastic gradient oracle pg, defined by g(x, ξ):=sgξ(x)
satisfies Assumption 6 with sf(x) =Eξ[sfξ(x)],sg(x) =Eξ[sgξ(x)], and δpg=1
LmaxEξ[Lξδξ] (≤
Eξ[δξ]),Lpg=Lmax, where Lmax:= supξLξ(see Lemma 16). Furthermore, if pgbis the mini-batch
version ofpgof size b, thenpgbsatisfies Assumption 6 with the same δpgb=δpgbutLpgb=1
bLpg=1
bLmax
which can be much smaller than Lmaxwhen bis large enough.
Under the new assumption on the variance, UniSgd enjoys the following convergence rate (see
Appendix D.1 for the proof).
Theorem 7. Let Algorithm 1 with M0= 0be applied to problem (1)under Assumptions 1, 2 and 6,
and let σ2
∗:= Varpg(x∗). Then, for the point sxNproduced by the method, we have
E[F(sxN)]−F∗≤c4(c2Lf+ 12c1Lpg)D2
N+ 2σ∗Dr
6c1c4
N+c3δf+4
3δpg.
Comparing the above result with Theorem 4, we see that we have essentially replaced the uniform
bound σwith the more refined one σ∗at the cost of replacing LfwithLf+Lpgandδfwithδf+δpg.
6Algorithm 3 UniSvrgpg,sg,ψ(x0;D)
Input: Oraclespg,sg, composite part ψ, point x0∈domψ, diameter D.
1:˜x0=x0,M0= 0.
2:fort= 0,1, . . . do
3: (˜xt+1, xt+1, Mt+1)∼=UniSgd pGt,ψ(xt, Mt,2t+1;D)withpGt= SvrgOracpg,sg(˜xt).
This corresponds to classical results on the usual SGD for which we know all problem dependent-
constants. However, our method is universal and works automatically under both assumptions from
the previous section and the current one, and therefore enjoys the best among the rates given by
Theorems 4 and 7.
For the accelerated algorithm, we have the following result (whose proof is located in Appendix D.2).
Theorem 8. Let Algorithm 2 be applied to problem (1)under Assumptions 1, 2 and 6, and let
σ2
∗:= Varpg(x∗). Then, for any k≥1, we have
E[F(xk)]−F∗≤4c2c4LfD2
k(k+ 1)+24c1c4LpgD2
k+ 1+ 4σ∗Dr
2c1c4
k+c3
3(k+ 2)δf+4
3δpg.
Comparing our previous complexity bound for UniFastSgd under the assumption on uniformly
bounded variance (Theorem 5) with the bound from Theorem 8, we see that, instead of simply
replacing σwithσ∗,LfwithLf+Lpgandδfwithδf+δpg, which was the case for the basic method,
the situation is now not that simple. Specifically, the LfandLpgterms now converge at different
rates: O(1
k2)andO(1
k), respectively. While this may seem strange at first, this behavior is actually
unavoidable, at least in the case when δf=δpg= 0(see, e.g., Section E in [59]). For the case when
δf=δpg= 0, the complexity result from Theorem 8 is similar to the results for the Accelerated SGD
algorithm from [59]. However, the latter paper studies a specific setting where f(x) =E[fξ(x)],
where each component fξisLmax-smooth and then assumes that fis also Lmax-smooth, instead of
working with the constant Lfwhich can be much smaller than Lmax. A similar separation of the
constants LfandLpg, which we do, was recently considered in [24], where the authors obtained some
similar rates to our Theorem 8. However, it is important that, unlike the algorithms considered in [24,
59], our UniFastSgd is universal and does not require knowing any problem-dependent constants
except D. Furthermore, our results are more general because we allow the oracle to be inexact.
6 Explicit Variance Reduction with SVRG
Let us now show that we can also incorporate explicit SVRG-type variance reduction into our methods.
In this section, we consider problem (1)under Assumptions 1, 2 and 6. All the proofs are deferred to
Appendix E.
In addition to the stochastic oracle pg, we now assume that we can also compute the (approximate)
full-gradient oracle sg. This allows us to define the following auxiliary SVRG oracle induced by pg
with center ˜x∈Rd(notationpG= SvrgOracpg,sg(˜x)) as the oracle with the same random variable
component ξaspgand the function component given by G(x, ξ) =g(x, ξ)−g(˜x, ξ) +sg(˜x).
OurUniSvrg method is presented in Algorithm 3. This is the classical epoch-based SVRG algorithm
which can be seen as the adaptive version of the SVRG++ method from [1]. A similar scheme was
suggested in [16], however, instead of accumulating gradient differences as in (3), their method
accumulates gradients and therefore does not work without the additional assumption of ∇f(x∗) = 0
(which may not hold for constrained optimization).
Let us now present the complexity guarantees. To do so, we first need to introduce, one more
assumption we need in our analysis.
Assumption 9. The variance of pgsatisfies Varpg(x, y)≤4Lpg[β∇f(x)
f(x, y) + 2δpg]for any x, y∈Rd
and any ∇f(x)∈∂f(x).
Assumption 9 is very similar to Assumption 6. The only difference between them is that the
former contains the standard Bregman distance in the right-hand side, while the latter contains
its approximation βf,sf,sg(x, y)involving the approximate function value sf(x)and the approximate
gradientsg(x). Nevertheless, both assumptions are actually satisfied for the main examples we
discussed after introducing Assumption 6 (see Lemma 16).
7Algorithm 4 UniFastSvrgpg,sg,ψ(x0, N;D)
Input: Oraclespg,sg, composite part ψ, point x0∈domψ, epoch length N, diameter D.
1:˜x0= Prox ψ(x0,sg(x0),0),v0=x0,M0= 0,A0=1
N.
2:fort= 0,1, . . . do
3: at+1=√At,At+1=At+at+1.
4: (˜xt+1, vt+1, Mt+1)∼=UniTriSvrgEpochpg,sg,ψ(˜xt, vt, Mt, At, at+1, N;D).
Algorithm 5 (˜x+, v+, M +)∼=UniTriSvrgEpochpg,sg,ψ(˜x, v 0, M 0, A, a, N ;D)
Input: Oraclespg,sg, comp. part ψ, points ˜x, v 0, coefficients M0, A, a , epoch length N, diameter D.
1:A+=A+a,x0=A
A+˜x+a
A+v0,pG= SvrgOracpg,sg(˜x),Gx0∼=pG(x0).
2:fork= 0, . . . , N −1do
3: vk+1= Prox ψ(vk, Gxk,Mk
a).
4: xk+1=A
A+˜x+a
A+vk+1,Gxk+1∼=pG(xk+1).
5: Mk+1=a2
A+M+ A+
a2Mk,a2
A2
+D2, xk, xk+1, Gxk, Gxk+1
▷e.g.,(3)=q
M2
k+a2
D2∥Gxk+1−Gxk∥2∗.
6:return (sxN, vN, MN), wheresxN:=1
NPN
k=1xk.
Theorem 10. LetUniSvrg (as defined by Algorithm 3) be applied to problem (1)under Assumptions 1,
2, 6 and 9. Then, for any t≥1andsc3:= max {c3,1}, we have
E[F(˜xt)]−F∗≤[(c2c4+ 1)Lf+ 48c1c4Lpg]D2
2t+ 2sc3δf+8
3δpg.
To construct ˜xt, the algorithm needs to make O(2t)queries topgandO(t)queries tosg.
We now present an accelerated version of UniSvrg , see Algorithm 4. As UniSvrg , this method
is also epoch-based, and its epoch is very similar to UniFastSgd (Algorithm 4) in the sense that
it also iterates similar-triangle steps. However, the triangles in UniTriSvrgEpoch are of the form
(˜x, vk, vk+1), i.e., they always share the common vertex ˜x, in contrast to the triangles (xk, vk, vk+1)
inUniFastSgd (inUniTriSvrgEpoch , the role of the average points ykis played by xk). We note
that our UniFastSvrg is essentially the primal version of the VRADA method from [53], but equipped
with AdaGrad stepsizes. Alternative accelerated SVRG schemes with AdaGrad stepsizes (3)were
recently proposed in [36]; however, they seem to be much more complicated.
The special choice of the initial reference point ˜x0at Line 1 is rather standard and motivated by the
desire to keep the initial function residual appropriately bounded: F(˜x0)−F∗≤1
2LfD2+δf; the
simplest way to achieve this is to make the full gradient step from any feasible point (see Lemma 34).
Theorem 11. LetUniFastSvrg (Algorithm 4) be applied to problem (1)under Assumptions 1, 2
and 6, and let N≥9. Then, for any t≥t0:=⌈log2log3N⌉ −1 (≥0), it holds that
E[F(˜xt)]−F∗≤9[(c2c4+1
2)Lf+ 6c1c4Lpg]D2
N(t−t0+ 1)2+ (c3t+ 1)δf+5
3tδpg.
To construct ˜xt, the algorithm needs to make O(Nt)queries topgandO(t)queries tosg. Assuming
that the complexity of querying sgisntimes bigger than that of querying pgand choosing N= Θ( n),
we get the total stochastic-oracle complexity of O(nt).
Note that Theorem 11, unlike Theorem 10, does not require the extra Assumption 9. This suggests
that Assumption 9 might be somewhat artificial and could potentially be removed from Theorem 10
as well. However, we do not know how to do it, even in the simplest case when δf=δpg= 0and the
algorithm has the knowledge of the constants LfandLpgfrom Assumptions 1 and 6.
7 Application to Hölder Smooth Problems
To illustrate how powerful our results are, let us quickly consider the specific example of solving the
stochastic optimization problem with Hölder smooth components.
Example 12.Suppose that the function fin problem (1)is the expectation of other functions,
f(x) =Eξ[fξ(x)], where each function fξis convex and (ν, H ξ(ν))-Hölder smooth. Consider the
8Table 2: Corollaries of our results for the case when problem (1)has Hölder smooth components, as defined
in Example 12. “SO complexity” is the stochastic-oracle complexity for reaching accuracy ϵin terms of the
expected function residual, defined as in Table 1 but with pg=pgb,sg=∇f,n=nb.
Method SO complexity Reference
UniSgd (Alg. 1) Hf(ν)
ϵ2
1+νD2+1
bminσ2D2
ϵ2, Hmax(ν)
ϵ2
1+νD2+σ2
∗D2
ϵ2	
Cors. 37, 40
UniFastSgd (Alg. 2) Hf(ν)D1+ν
ϵ2
1+3ν+1
bminσ2D2
ϵ2, Hmax(ν)
ϵ2
1+νD2+σ2
∗D2
ϵ2	
Cors. 38, 41
UniSvrg (Alg. 3)
Nν(ϵ):= Hf(ν)
ϵ2
1+νD2+1
b Hmax(ν)
ϵ2
1+νD2
+nblog+Nν(ϵ) Cor. 43
UniFastSvrg (Alg. 4) [nν
bHf(ν)D1+ν
ϵ]2
1+3ν+ [nν
bHmax(ν)D1+ν
b(1+ν)/2ϵ]2
1+3ν+nblog log nb Cor. 44
standard mini-batch stochastic gradient oracle pgbof size b, defined by gb(x, ξ[b]) =1
bPb
j=1∇fξj(x),
where ξ[b]:= (ξ1, . . . , ξ b)withbi.i.d. copies of ξ, and∇fξ(x)∈∂fξ(x)is an arbitrary selection of
subgradients for each ξ. We define Hf(ν)as the Hölder constant for the function fandHmax(ν):=
supξHξ(ν)as the worst among Hölder constants for each fξ. Note that we always have Hf(ν)≤
Eξ[Hξ(ν)]butHf(ν)can, in principle, be much smaller than the right-hand side. Also, define
σ2:= supx∈domψVarpg1(x)≡supx∈domψEξ[∥∇fξ(x)− ∇f(x)∥2
∗]andσ2
∗:= Varpg1(x∗)≡
Eξ[∥∇fξ(x∗)− ∇f(x∗)∥2
∗]. We assume that the computation of pgbcan be parallelized and the
computation of ∇fisnbtimes more expensive than that of pgb.
To solve the above problem, we can apply any of the methods we presented before. The resulting
oracle complexities (in terms of the BigO-notation) are summarized in Table 2; the precise statements
the corresponding results and their proofs are deferred to Appendix F.
Note that our problem is characterized by a large number of parameters, ν,Hf(ν),Hmax(ν),σ,σ∗.
For each combination of these parameters, we get a certain complexity guarantee for each of our
methods, and it is impossible to say in advance which combination results in the smaller complexity
bound. However, it is not important for our methods since none of them needs to know any of these
constants to ensure the corresponding bound. This means that our algorithms are universal : they
automatically figure out the best problem class for a specific problem given to them.
8 Experiments
Let us illustrate the performance of our methods in preliminary numerical experiments2on solving
f∗:= min
∥x∥≤Rn
f(x):=1
nnX
i=1[⟨ai, x⟩ −bi]q
+o
, (5)
where ai, bi∈Rd,q∈[1,2]andR >0.
This test problem covers several interesting applications. Indeed, if q= 2, we get the classical Least
squares problem. If q= 1, this is the well-known Support-Vector Machines (SVM) problem. In both
cases, the ball-constraint ∥x∥ ≤Racts as a regularizer, and problem (5)is, in fact, equivalent to
minx∈Rd[f(x) +µ
2∥x∥2]for a certain µ≥0(this follows, e.g., from the KKT optimality conditions)
such that µdecreases when Rincreases.
Another interesting application of (5), which we consider in this section, is the polyhedron feasibility
problem : find x∗∈Rd,∥x∗∥ ≤R, inside the polyhedron P={x:⟨ai, x⟩ ≤bi, i= 1, . . . , n }.
Such a point exists iff f∗= 0. Note that (5)is a problem with Hölder smooth components of degree
ν=q−1. By varying qin(5), we can therefore check the adaptivity of different methods to the
unknown to them Hölder characteristics of the objective function.
The data for our problem is generated randomly. First, we generate x∗uniformly from the sphere of
radius 0.95Rcentered at the origin. Then, we generate i.i.d. vectors aiwith components uniformly
distributed on [−1,1]. We then make sure that ⟨an, x∗⟩<0by inverting the sign of anif necessary.
Next, we generate positive reals siuniformly in [0,−0.1cmin], where cmin:= min i⟨ai, x∗⟩<0,
and set bi=⟨ai, x∗⟩+si. By construction, x∗is a solution of our problem with f∗= 0, and the
origin x0= 0 lies outside the polyhedron since there exists j(corresponding to cmin) such that
bj=cmin+sj≤0.9cmin<0.
2The corresponding source code is available at https://github.com/mlolab/universal-adagrad-experiments.
90 50000 100000 150000 200000 250000
number of stochastic oracle calls 101
100101102103104105f(x)-f
q = 1
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 100101102103104105106107f(x)-f
q = 1.3
0 20000 40000 60000
number of stochastic oracle calls 102104106108f(x)-f
q = 1.6
0 5000 10000 15000
number of stochastic oracle calls 106
103
1001031061091012f(x)-f
q = 2
UniSgd (ours) UniFastSgd (ours) AdaSVRG UniSvrg (ours) AdaVRAG AdaVRAE FastSvrg UniFastSvrg (ours)Figure 1: Comparison of different methods on the polyhedron feasibility problem (5).
0 5000 10000 15000 20000
number of stochastic oracle calls 105106107108f(x)-f
UniSgd
batchsize=64
batchsize=512
batchsize=4096
0 2000 4000 6000 8000 10000 12000 14000
number of stochastic oracle calls 101103105107f(x)-f
UniFastSgd
batchsize=64
batchsize=512
batchsize=4096
0 5000 10000 15000 20000 25000 30000 35000
number of stochastic oracle calls 104105106107108f(x)-f
UniSvrg
batchsize=64
batchsize=512
batchsize=4096
0 2500 5000 7500 10000 12500 15000 17500 20000
number of stochastic oracle calls 101103105107f(x)-f
UniFastSvrg
batchsize=64
batchsize=512
batchsize=4096
Figure 2: Impact of mini-batch size on performance of our methods.
We compare UniSvrg (Algorithm 3) against AdaSVRG [16] (with parameters K= 3andη=D=
2R). We next compare UniFastSvrg (Algorithm 4) against AdaVRAE and AdaVRAG [36]. We
also compare it with the FastSvrg method with constant stepsize, which is the primal version of the
VRADA method from [53]; the stepsize is selected by doing a grid search over {10j:j=−3, . . . , 4}
and choosing the best value in the sense that the algorithm is neither too slow nor has a large error.
We report UniSgd (Algorithm 1) and UniFastSgd (Algorithm 2) together with these methods. For
UniFastSvrg , contrary to the theoretical recommendation of choosing ˜x0as the result of the full
gradient step, we found it slightly more useful to simply set ˜x0=x0. For all our methods, we use the
AdaGrad stepsize (3); the other stepsize (4)works very similarly (see Appendix H.2 for a detailed
comparison). For all methods, we use the standard mini-batch stochastic oracle of size b= 256 .
The results are shown in Fig. 1, where we fix n= 104,d= 103,R= 106and consider different
values of q∈ {1,1.3,1.6,2}. We plot the total number of stochastic oracle calls against the function
residual. We treat one mini-batch oracle computation as one stochastic oracle call. If we compute the
full gradient, we count this as n/bstochastic oracle calls where nis the total number of samples and
bdenotes the mini-batch size.
We see that, except the AdaSVRG method, all SVRG algorithms typically converge much faster
than the usual SGD methods without explicit variance reduction, at least after a few computations
of the full gradient. Among the non-accelerated SVRG methods, UniSvrg converges consistently
faster than AdaSVRG, while UniFastSvrg performs the best across the accelerated ones. Note that
FastSvrg with constant stepsize is not converging when the problem is not Lipschitz smooth ( q <2),
in contrast to our universal methods.
In Fig. 2, we also illustrate the impact of the mini-batch size bon the convergence of our methods.
We consider the same values of n,d,Ras before and fix q= 1.5. As we can see, in the idealized
situation, when one can implement the mini-batch oracle computations by perfect parallelism, there is
a significant speedup in convergence when increasing the mini-batch size, as predicted by our theory.
For additional experiments, including the discussion of implicit variance reduction, see Appendix H.
9 Conclusions
In this paper, we showed that AdaGrad stepsizes can be applied, in a unified manner, in a large variety
of situations, leading to universal methods suitable for multiple problem classes at the same time.
Note that this does not come for free. We still need to know one parameter, the diameter Dof the
feasible set. While it is not necessary to know this parameter precisely, the cost of underestimating
or overestimating it, can be high (all complexity bounds would be multiplied by the ratio between
our guess and the true D). At the same time, there already exist some parameter-free methods
which are based on AdaGrad and aim to solve precisely this problem [6, 11, 25, 31, 41]. It is
therefore interesting to consider extensions of our results to these more advanced algorithms. Another
interesting direction is, of course, nonconvex problems.
10Acknowledgements
The authors are thankful to the anonymous reviewers for their comments and suggestions. Sebastian
Stich acknowledges funding support from the Meta Research Award and the Google Research Award.
References
[1] Z. Allen-Zhu and Y . Yuan. Improved SVRG for Non-Strongly-Convex or Sum-of-Non-Convex
Objectives. In International Conference on Machine Learning , pages 1080–1089, 2016.
[2] A. Attia and T. Koren. SGD with AdaGrad Stepsizes: Full Adaptivity with High Probability to
Unknown Parameters, Unbounded Gradients and Affine Variance. In International Conference
on Machine Learning , pages 1147–1171, 2023.
[3] R. Babanezhad Harikandeh, M. O. Ahmed, A. Virani, M. Schmidt, J. Kone ˇcn`y, and S. Sallinen.
StopWasting My Gradients: Practical SVRG. Advances in Neural Information Processing
Systems , 28, 2015.
[4] D. P. Bertsekas. Stochastic optimization problems with nondifferentiable cost functionals.
Journal of Optimization Theory and Applications , 12(2):218–231, 1973.
[5] L. Bottou, F. E. Curtis, and J. Nocedal. Optimization Methods for Large-Scale Machine
Learning. SIAM Review , 60(2):223–311, 2018.
[6] Y . Carmon and O. Hinder. Making SGD Parameter-Free. In Conference on Learning Theory ,
pages 2360–2389, 2022.
[7] C.-C. Chang and C. -J. Lin. LIBSVM: a library for support vector machines. ACM Transactions
on Intelligent Systems and Technology , 2:27:1–27:27, 3, 2011.
[8] A. Cotter, O. Shamir, N. Srebro, and K. Sridharan. Better mini-batch algorithms via accelerated
gradient methods. Advances in Neural Information Processing Systems , 24, 2011.
[9] A. Cutkosky and K. Boahen. Online Learning Without Prior Information. In Conference on
Learning Theory , pages 643–677, 2017.
[10] A. Cutkosky and F. Orabona. Black-Box Reductions for Parameter-free Online Learning in
Banach Spaces. In Conference On Learning Theory , pages 1493–1529, 2018.
[11] A. Defazio and K. Mishchenko. Learning-Rate-Free Learning by D-Adaptation. In Interna-
tional Conference on Machine Learning , pages 7449–7479, 2023.
[12] Q. Deng, Y . Cheng, and G. Lan. Optimal Adaptive and Accelerated Stochastic Gradient
Descent. arXiv preprint arXiv:1810.00553 , 2018.
[13] O. Devolder. Stochastic first order methods in smooth convex optimization. CORE Discussion
Papers, 2011/70 , 2011.
[14] O. Devolder. Exactness, Inexactness and Stochasticity in First-Order Methods for Large-Scale
Convex Optimization . PhD thesis, Université catholique de Louvain (UCL), 2013.
[15] O. Devolder, F. Glineur, and Y . Nesterov. First-order methods of smooth convex optimization
with inexact oracle. Mathematical Programming , 146:37–75, 2013. DOI:10.1007/s10107-
013-0677-5 .
[16] B. Dubois-Taine, S. Vaswani, R. Babanezhad, M. Schmidt, and S. Lacoste-Julien. SVRG meets
AdaGrad: painless variance reduction. Machine Learning , 111(12):4359–4409, 2022.
[17] J. Duchi, E. Hazan, and Y . Singer. Adaptive Subgradient Methods for Online Learning and
Stochastic Optimization. Journal of Machine Learning Research , 12(7), 2011.
[18] A. Ene, H. L. Nguyen, and A. Vladu. Adaptive Gradient Methods for Constrained Convex
Optimization and Variational Enequalities. In Proceedings of the AAAI Conference on Artificial
Intelligence , volume 35 of number 8, pages 7314–7321, 2021.
[19] E. Gorbunov, F. Hanzely, and P. Richtárik. A Unified Theory of SGD: Variance Reduction,
Sampling, Quantization and Coordinate Descent. In International Conference on Artificial
Intelligence and Statistics , pages 680–690, 2020.
[20] R. M. Gower, P. Richtárik, and F. Bach. Stochastic quasi-gradient methods: variance reduction
via Jacobian sketching. Mathematical Programming , 188(1):135–192, 2021.
[21] R. M. Gower, M. Schmidt, F. Bach, and P. Richtárik. Variance-Reduced Methods for Machine
Learning. Proceedings of the IEEE , 108(11):1968–1983, 2020.
11[22] R. M. Gower, N. Loizou, X. Qian, A. Sailanbayev, E. Shulgin, and P. Richtárik. SGD: General
Analysis and Improved Rates. In International Conference on Machine Learning , pages 5200–
5209, 2019.
[23] G. N. Grapiglia and Y . Nesterov. Regularized Newton Methods for Minimizing Functions with
Hölder Continuous Hessians. SIAM Journal on Optimization , 27(1):478–506. DOI:10.1137/
16M1087801 .
[24] S. Ilandarideva, A. Juditsky, G. Lan, and T. Li. Accelerated stochastic approximation with
state-dependent noise. arXiv preprint arXiv:2307.01497 , 2023.
[25] M. Ivgi, O. Hinder, and Y . Carmon. DoG is SGD’s Best Friend: A Parameter-Free Dynamic
Step Size Schedule. In International Conference on Machine Learning , pages 14465–14499,
2023.
[26] A. Jacobsen and A. Cutkosky. Unconstrained Online Learning with Unbounded Losses. In
International Conference on Machine Learning , pages 14590–14630, 2023.
[27] R. Johnson and T. Zhang. Accelerating Stochastic Gradient Descent using Predictive Variance
Reduction. Advances in Neural Information Processing Systems , 26, 2013.
[28] P. Joulani, A. Raj, A. Gyorgy, and C. Szepesvári. A Simpler Approach to Accelerated Op-
timization: Iterative Averaging Meets Optimism. In International Conference on Machine
Learning , pages 4984–4993, 2020.
[29] A. Juditsky, A. Kulunchakov, and H. Tsyntseus. Sparse recovery by reduced variance stochastic
approximation. Information and Inference: A Journal of the IMA , 12(2):851–896, 2023.
[30] A. Kavis, K. Y . Levy, F. Bach, and V . Cevher. UniXGrad: A Universal, Adaptive Algorithm
with Optimal Guarantees for Constrained Optimization. Advances in Neural Information
Processing Systems , 32, 2019.
[31] A. Khaled, K. Mishchenko, and C. Jin. DoWG Unleashed: An Efficient Universal Parameter-
Free Gradient Descent Method. Advances in Neural Information Processing Systems , 36:6748–
6769, 2023.
[32] D. P. Kingma and J. Ba. Adam: A Method for Stochastic Optimization. International Confer-
ence on Learning Representations (ICLR) , 2015.
[33] G. Lan. An optimal method for stochastic composite optimization. Mathematical Programming ,
133(1):365–397, 2012.
[34] K. Y . Levy, A. Yurtsever, and V . Cevher. Online Adaptive Methods, Universality and Accelera-
tion. Advances in Neural Information Processing Systems , 31, 2018.
[35] C. Liu and M. Belkin. Accelerating SGD with momentum for over-parameterized learning.
arXiv preprint arXiv:1810.13395 , 2018.
[36] Z. Liu, T. D. Nguyen, A. Ene, and H. Nguyen. Adaptive Accelerated (Extra-)Gradient Methods
with Variance Reduction. In International Conference on Machine Learning , pages 13947–
13994, 2022.
[37] S. Ma, R. Bassily, and M. Belkin. The Power of Interpolation: Understanding the Effectiveness
of SGD in Modern Over-parametrized Learning. In International Conference on Machine
Learning , pages 3325–3334, 2018.
[38] M. Mahdavi, L. Zhang, and R. Jin. Mixed Optimization for Smooth Functions. Advances in
Neural Information Processing Systems , 26, 2013.
[39] H. B. McMahan and M. Streeter. Adaptive Bound Optimization for Online Convex Optimiza-
tion. arXiv preprint arXiv:1002.4908 , 2010.
[40] Z. Mhammedi and W. M. Koolen. Lipschitz and Comparator-Norm Adaptivity in Online
Learning. In Conference on Learning Theory , pages 2858–2887, 2020.
[41] K. Mishchenko and A. Defazio. Prodigy: An Expeditiously Adaptive Parameter-Free Learner.
arXiv preprint arXiv:2306.06101 , 2023.
[42] E. Moulines and F. Bach. Non-Asymptotic Analysis of Stochastic Approximation Algorithms
for Machine Learning. Advances in Neural Information Processing Systems , 24, 2011.
[43] I. Necoara, Y . Nesterov, and F. Glineur. Linear convergence of first order methods for non-
strongly convex optimization. Mathematical Programming , 175:69–107, 2019.
[44] D. Needell, R. Ward, and N. Srebro. Stochastic Gradient Descent, Weighted Sampling, and the
Randomized Kaczmarz Algorithm. Advances in Neural Information Processing Systems , 27,
2014.
12[45] Y . Nesterov. Universal gradient methods for convex optimization problems. Mathematical
Programming , 152:381–404, 2015. DOI:10.1007/s10107-014-0790-0 .
[46] Y . Nesterov. Lectures on Convex Optimization , volume 137. Springer, 2nd edition, 2018.
[47] F. Orabona. Simultaneous Model Selection and Optimization through Parameter-free Stochastic
Learning. Advances in Neural Information Processing Systems , 27, 2014.
[48] F. Orabona. Normalized Gradients for All. arXiv preprint arXiv:2308.05621 , 2023.
[49] A. Rodomanov, A. Kavis, Y . Wu, K. Antonakopoulos, and V . Cevher. Universal Gradient
Methods for Stochastic Convex Optimization. arXiv preprint arXiv:2402.03210 , 2024.
[50] M. Schmidt, N. Le Roux, and F. Bach. Minimizing finite sums with the stochastic average
gradient. Mathematical Programming , 162:83–112, 2017.
[51] M. Schmidt and N. L. Roux. Fast Convergence of Stochastic Gradient Descent under a Strong
Growth Condition. arXiv preprint arXiv:1308.6370 , 2013.
[52] S. Shalev-Shwartz and T. Zhang. Stochastic Dual Coordinate Ascent Methods for Regularized
Loss Minimization. Journal of Machine Learning Research , 14(1), 2013.
[53] C. Song, Y . Jiang, and Y . Ma. Variance Reduction via Accelerated Dual Averaging for
Finite-Sum Optimization. In Advances in Neural Information Processing Systems , volume 33,
pages 833–844, 2020.
[54] S. U. Stich. Unified Optimal Analysis of the (Stochastic) Gradient Method. arXiv preprint
arXiv:1907.04232 , 2019.
[55] M. Streeter and H. B. McMahan. No-Regret Algorithms for Unconstrained Online Convex
Optimization. In Proceedings of the 25th International Conference on Neural Information
Processing Systems , volume 2, pages 2402–2410, 2012.
[56] T. Tieleman. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent
magnitude. Coursera: Neural Networks for Machine Learning , 4(2):26, 2012.
[57] S. Vaswani, A. Mishkin, I. Laradji, M. Schmidt, G. Gidel, and S. Lacoste-Julien. Painless
Stochastic Gradient: Interpolation, Line-Search, and Convergence Rates. Advances in Neural
Information Processing Systems , 32, 2019.
[58] C. Wang, X. Chen, A. J. Smola, and E. P. Xing. Variance Reduction for Stochastic Gradient
Optimization. Advances in Neural Information Processing Systems , 26, 2013.
[59] B. E. Woodworth and N. Srebro. An Even More Optimal Stochastic Optimization Algorithm:
Minibatching and Interpolation Learning. Advances in Neural Information Processing Systems ,
34:7333–7345, 2021.
[60] L. Zhang, M. Mahdavi, and R. Jin. Linear Convergence with Condition Number Independent
Access of Full Gradients. Advances in Neural Information Processing Systems , 26, 2013.
13A General Auxiliary Results
A.1 Approximately Smooth Functions
Theorem 13 (Lemma 2 in [45]) .Letf:Rd→Rbe a convex (ν, H)-Hölder smooth function for
some ν∈[0,1]andH≥0. Then, for any δ >0, any x, y∈Rdand any ∇f(x)∈∂f(x), it holds
thatβ∇f(x)
f(x, y)≤L
2∥x−y∥2+δwithL= [1−ν
2(1+ν)δ]1−ν
1+νH2
1+ν(with the convention that 00= 1).
Theorem 14. Letf:Rd→Rbe a(δ, L)-approximately smooth convex function with components
(sf,sg), i.e., for any x, y∈Rdandβf,sf,sg(x, y):=f(y)−sf(x)− ⟨sg(x), y−x⟩, we have
0≤βf,sf,sg(x, y)≤L
2∥x−y∥2+δ. (6)
Then, for any x, y∈Rdand any ∇f(x)∈∂f(x), the following inequalities hold:
sf(x)≤f(x)≤sf(x) +δ, (7)
⟨sg(x)−sg(y), x−y⟩ ≤βf,sf,sg(x, y) +βf,sf,sg(y, x)≤ ⟨sg(x)−sg(y), x−y⟩+ 2δ, (8)
⟨sg(x)−sg(y), x−y⟩ ≤L∥x−y∥2+ 2δ, (9)
∥sg(x)−sg(y)∥2
∗≤2L(βf,sf,sg(x, y) +δ), (10)
∥∇f(x)−sg(y)∥2
∗≤2L(β∇f(x)
f(x, y) +δ), (11)
∥sg(x)−sg(y)∥2
∗≤L2∥x−y∥2+ 4Lδ, (12)
∥sg(x)−sg(y)∥2
∗≤4L(β∇f(x)
f(x, y) + 2δ), (13)
β∇f(x)
f(x, y)≤L∥x−y∥2+ 2δ. (14)
Proof. Inequality (7) follows immediately from (6) by substituting y=x.
To prove (8), we rewrite
βf,sf,sg(x, y) +βf,sf,sg(y, x) =⟨sg(x)−sg(y), x−y⟩+ [f(x)−sf(x)] + [f(y)−sf(y)],
and then apply (7).
Using the first part of (8) and applying (6) twice, we obtain (9).
To prove (10) and (11), let us fix some sf1(x)∈Randsg1(x)∈Rdsuch that βf,sf1,sg1(z):=
f(z)−sf1(x)− ⟨sg1(x), z−x⟩ ≥0for any z∈Rd. Note that we can choose either (sf1,sg1) = (sf,sg)
or(sf1,sg1) = (f,∇f). In view of (6), for any z∈Rd, we can write the following inequalities:
0≤βf,sf1,sg1(z)≤sf(y)−sf1(x)− ⟨sg1(x), y−x⟩+⟨sg(y)−sg1(x), z−y⟩+L
2∥z−y∥2+δ.
Minimizing the right-hand side in z∈Rdand rearranging, we conclude that
1
2L∥sg(y)−sg1(x)∥2
∗≤sf(y)−sf1(x)− ⟨sg1(x), y−x⟩+δ≤βf,sf1,sg1(x, y) +δ,
where the final inequality is due to (7). Substituting now either (sf1,sg1) = (sf,sg)or(sf1,sg1) =
(f,∇f), we obtain either (10) or (11), respectively.
Inequality (12) follows immediately from (6) and (10).
Inequality (13) follows from (11):
∥sg(x)−sg(y)∥2
∗≤2∥∇f(x)−sg(y)∥2
∗+ 2∥sg(x)− ∇f(x)∥2
∗
≤4L(β∇f(x)
f(x, y) +δ) + 4Lδ= 4L(β∇f(x)
f(x, y) + 2δ).
14To prove (14), we proceed as follows using first (6), then (7), and then (11):
β∇f(x)
f(x, y)≡f(y)−f(x)− ⟨∇ f(x), y−x⟩
≤sf(x)−f(x) +⟨sg(x)− ∇f(x), y−x⟩+L
2∥y−x∥2+δ
≤ ⟨sg(x)− ∇f(x), y−x⟩+L
2∥y−x∥2+δ
≤√
2Lδ∥y−x∥+L
2∥y−x∥2+δ
=r
L
2∥y−x∥+√
δ2
≤L∥y−x∥2+ 2δ,
where the final inequality is (a+b)2≤2a2+ 2b2,a, b≥0.
Remark 15.Some of the inequalities from Theorem 14, namely, (7), (10) and (12), were established
already in [15]. We nevertheless prefer to present the corresponding proofs since they are rather
simple, and we use the associated ideas for proving the other new inequalities.
Lemma 16. Letf:Rd→Rbe the function f(x):=Eξ[fξ(x)], where each fξ:Rd→Ris convex
and(δξ, Lξ)-approximately smooth with components (sfξ,sgξ). Further, let pgbe the stochastic oracle
defined by g(x, ξ):=sgξ(x), and letsf(x):=Eξ[sfξ(x)],sg(x):=Eξ[sgξ(x)]. Then,pgis an unbiased
oracle forsgand, for any x, y∈Rd,Lmax:= supξLξandsδ:=1
LmaxEξ[Lξδξ], it holds that
Varpg(x, y)≤2Lmax[βf,sf,sg(x, y) +sδ]. (15)
Furthermore, for any x, y∈Rdand any ∇f(x)∈∂f(x), it also holds that
Varpg(x, y)≤4Lmax[β∇f(x)
f(x, y) + 2sδ]. (16)
Proof. According to our definition of sg, we have Eξ[sgξ(x)] =sg(x)for any x, sopgis indeed an
unbiased oracle for sg. Further, for any x, y∈Rd, we can estimate
Varpg(x, y)≡Eξ
∥[sgξ(x)−sgξ(y)]−[sg(x)−sg(y)]∥2
∗
≤Eξ
∥sgξ(x)−sgξ(y)∥2
∗
≤Eξ
2Lξ 
βfξ,sfξ,sgξ(x, y) +δξ
≤2Lmax 
Eξ[βfξ,sfξ,sgξ(x, y)] +sδ
= 2Lmax[βf,sf,sg(x, y) +sδ],
wheresδis as defined in the statement; the second inequality follows from Theorem 14 (inequal-
ity(10)), and the final identity is due to the linearity of βf,sf,sg(x, y)in(f,sf,sg)and the fact that, by
our definitions, Eξ[fξ(x)] =f(x),Eξ[sfξ(x)] =sf(x),Eξ[sgξ(x)] =sg(x)for any x. This proves (15).
The proof of (16) is similar but now we apply (13) instead of (10):
Varpg(x, y)≤Eξ
∥sgξ(x)−sgξ(y)∥2
∗
≤Eξ
4Lξ 
β∇fξ(x)
fξ(x, y) + 2δξ
≤4Lmax 
Eξ[β∇fξ(x)
fξ(x, y)] + 2sδ
= 4Lmax[β∇f(x)
f(x, y) + 2sδ],
where we have used the fact that ∂f(x) =Eξ[∂fξ(x)](see Proposition 2.2 in [4]), meaning that, for
any∇f(x)∈∂f(x), we can find a selection of ∇fξ(x)∈∂fξ(x)such that ∇f(x) =Eξ[∇fξ(x)].
A.2 Miscellaneous
Lemma 17. Letψ:Rd→R∪ {+∞}be a proper closed convex function, x∈domψ,g∈Rd,
M≥0, and let
x+:= Prox ψ(x, g, M ).
Then, for any y∈domψ, we have
⟨g, y−x+⟩+ψ(y) +M
2∥x−y∥2≥ψ(x+) +M
2∥x−x+∥2+M
2∥x+−y∥2.
15Proof. Indeed, by definition, x+is the minimizer of the function h:Rd→R∪ {+∞}given by
h(y):=⟨g, y⟩+ψ(y) +M
2∥x−y∥2, which is strongly convex with parameter M(or simply convex
ifM= 0). Hence, for any y∈domψ(= dom h), we have h(y)≥h(x+) +M
2∥y−x+∥2, which
is exactly the claimed inequality.
Lemma 18. LetN≥1be an integer, (Mk)N
k=0be a nondecreasing nonnegative sequence of reals,
and letĎM≥0. Then,
N−1X
k=0[min{Mk+1,ĎM} −Mk]+= [min {MN,ĎM} −M0]+.
Proof. It suffices to prove the identity only in the special case when N= 2, i.e., to show that γ0+γ1=
Γ, where γ0:= [min {M1,ĎM}−M0]+,γ1:= [min {M2,ĎM}−M1]+,Γ:= [min {M2,ĎM}−M0]+.
The general case then easily follows by induction.
To prove the identity, we use our assumption that M0≤M1≤M2and consider three possible
cases. If M1≥ĎM, then γ0+γ1= [ĎM−M0]++ 0 = [ĎM−M0]+= Γ. IfM1<ĎM≤M2,
thenγ0+γ1= (M1−M0) + (ĎM−M1) =ĎM−M0= Γ. Finally, if M2<ĎM, then γ0+γ1=
(M1−M0) + (M2−M1) =M2−M0= Γ.
Lemma 19. Letpgbe a stochastic oracle in Rd. Then, for any x, y, z ∈Rdand any τ >0, we have
Varpg(x)≤(1 +τ) Varpg(y) + (1 + τ−1) Varpg(x, y),
Varpg(x, y)≤(1 +τ) Varpg(x, z) + (1 + τ−1) Varpg(y, z).
Proof. Both inequalities are direct consequences of the standard inequality ∥s1+s2∥2
∗≤(1 +
τ)∥s1∥2
∗+ (1 + τ−1)∥s2∥2
∗which is valid for any s1, s2∈Rdand any τ > 0. Indeed, let g
andξbe, respectively, the function and the random variable components of pg, and let ∆(x, ξ):=
g(x, ξ)−E[g(x, ξ)]for any x∈Rd. Then, for any x, y, z ∈Rdandτ >0, we can estimate
Varpg(x)≡E[∥∆(x, ξ)∥2
∗] =E[∥∆(y, ξ) + [∆( x, ξ)−∆(y, ξ)]∥2
∗]
≤(1 +τ)E[∥∆(y, ξ)∥2
∗] + (1 + τ−1)E[∥∆(x, ξ)−∆(y, ξ)∥2
∗]
≡(1 +τ) Varpg(y) + (1 + τ−1) Varpg(x, y).
Similarly,
Varpg(x, y)≡E
∥∆(x, ξ)−∆(y, ξ)∥2
∗
=E
∥[∆(x, ξ)−∆(z, ξ)]−[∆(y, ξ)−∆(z, ξ)]∥2
∗
≤(1 +τ)E
∥∆(x, ξ)−∆(z, ξ)∥2
∗
+ (1 + τ−1)E
∥∆(y, ξ)−∆(z, ξ)∥2
∗
≡(1 +τ) Varpg(x, z) + (1 + τ−1) Varpg(y, z).
B Omitted Proofs for Section 3
Lemma 20 (AdaGrad stepsize) .Let function fsatisfy Assumption 1. Consider the stepsize update
rulexM+=M+(M,Ω, x,px+,pgx,pgx+)defined by
xM+:=r
M2+1
Ω∥pgx+−pgx∥2∗.
Then, this stepsize update rules satisfies (2)withc1=5
2,c2= 4,c3= 6,c4= 2.
Proof. Letp∆(ĎM):=βf,sf,sg(x,px+) +⟨sg(x)−pgx,px+−x⟩−ĎM
2∥px+−x∥2. From our Assumption 1
and Theorem 14 (inequality (8)), it follows that βf,sf,sg(x,px+)+βf,sf,sg(px+, x)≤ ⟨sg(px+)−sg(x),px+−
x⟩+ 2δf. Hence,
E[p∆(xM+)+βf,sf,sg(px+, x)]≤Eh
⟨sg(px+)−pgx,px+−x⟩−xM+
2∥px+−x∥2i
+2δf=E[p∆1(xM+)]+2δf,
16wherep∆1(xM+):=⟨pgx+−pgx,px+−x⟩ −xM+
2∥px+−x∥2. Hence,
Γ:=E[p∆(xM+) + (xM+−M)Ω + βf,sf,sg(px+, x)]≤E[p∆1(xM+) + (xM+−M)Ω] + 2 δf.
From the definition of xM+, it follows that ∥pgx+−pgx∥2
∗= (xM2
+−M2)Ω = (xM++M)(xM+−M)Ω.
SincexM+≥M, this means that
1
2xM+∥pgx+−pgx∥2
∗≤(xM+−M)Ω≤1
xM+∥pgx+−pgx∥2
∗
Let us now upper bound pΓ:=p∆1(xM+) + (xM+−M)Ω. For this, let us fix an arbitrary constant
ĎM≥0and consider two cases. If xM+≥ĎM, we can bound
pΓ≤p∆1(xM+) +1
xM+∥pgx+−pgx∥2
∗≤p∆1(ĎM) +1
ĎM∥pgx+−pgx∥2
∗=:pΓ(ĎM).
IfxM+≤ĎM, we can bound
pΓ≤1
2xM+∥pgx+−pgx∥2
∗+ (xM+−M)Ω≤2(xM+−M)Ω = 2[min {xM+,ĎM} −M]+Ω.
Combining the two cases, we get pΓ≤[pΓ(ĎM)]++ 2[min {xM+,ĎM} −M]+Ω. Thus,
Γ≤E[pΓ] + 2 δf≤E
[pΓ(ĎM)]+	
+ 2E
[min{xM+,ĎM} −M]+Ω	
+ 2δf.
Let us now estimate the first term. Denote pS:=pgx−sg(x)andpS+:=pgx+−sg(px+). Then,
pΓ(ĎM)≡ ⟨pgx+−pgx,px+−x⟩ −ĎM
2∥px+−x∥2+1
ĎM∥pgx+−pgx∥2
∗
≤ ⟨sg(px+)−sg(x),px+−x⟩+2
ĎM∥sg(px+)−sg(x)∥2
∗
+⟨pS+−pS,px+−x⟩+2
ĎM∥pS+−pS∥2
∗−ĎM
2∥px+−x∥2
Using now our Assumption 1 and Theorem 14 (inequalities (9)and(12)), we can continue as follows:
pΓ(ĎM)≤Lf∥px+−x∥2+ 2δf+2
ĎM(L2
f∥px+−x∥2+ 4Lfδf)
+⟨pS+−pS,px+−x⟩+2
ĎM∥pS+−pS∥2
∗−ĎM
2∥px+−x∥2
≤ ⟨pS+−pS,px+−x⟩+2
ĎM∥pS+−pS∥2
∗−ĎM−2Lf(1 +2Lf
ĎM)
2∥px+−x∥2+ 2
1 +4Lf
ĎM
δf
≤2
ĎM+1
2[ĎM−2Lf(1 +2Lf
ĎM)]
∥pS+−pS∥2
∗+ 2
1 +4Lf
ĎM
δf.
Consequently,
E
[pΓ(ĎM)]+	
≤2
ĎM+1
2[ĎM−2Lf(1 +2Lf
ĎM)]
E[∥pS+−pS∥2
∗] + 2
1 +4Lf
ĎM
δf.
In particular, for ĎM > 4Lf, we can estimate2
ĎM+1
2[ĎM−2Lf(1+2Lf
ĎM)]≤2
ĎM+1
2(ĎM−4Lf)≤5
2(ĎM−4Lf).
Therefore, for any ĎM > 4Lf,
E
[pΓ(ĎM)]+	
≤5
2(ĎM−4Lf)E[∥pS+−pS∥2
∗]+4δf=5
2(ĎM−4Lf)E[Varpg(px+)+Varpg(x)]+4δf,
where the final identity follows from the fact that E[∥pS+−pS∥2
∗] =E[∥pS+∥2
∗] +E[∥pS∥2
∗] =
E[Varpg(px+)] + Var pg(x)(becausepS+, conditioned on the randomness ξdefiningpgx≡g(x, ξ),
has zero mean).
17Combining everything together, we get
Γ≤5
2(ĎM−4Lf)E[Varpg(px+) + Var pg(x)] + 6 δf+ 2E
[min{xM+,ĎM} −M]+Ω	
.
This is exactly (2) with c1=5
2,c2= 4,c3= 6,c4= 2.
Lemma 21. Let function fsatisfy Assumption 1. Consider the stepsize update rule xM+=
M+(M,Ω, x,px+,pgx,pgx+)defined as the solution of the following equation:
(xM+−M)Ω = [p∆1(xM+)]+,p∆1(xM+):=⟨pgx+−pgx,px+−x⟩ −xM+
2∥px+−x∥2.
Then, this stepsize update rules satisfies (2)withc1= 1,c2= 2,c3= 6,c4= 2.
Proof. Let us define p∆(ĎM):=βf,sf,sg(x,px+) +⟨sg(x)−pgx,px+−x⟩ −ĎM
2∥px+−x∥2. Starting as in
the proof of Lemma 20, we see that
Γ:=E[p∆(xM+) + (xM+−M)Ω + βf,sf,sg(px+, x)]≤E[p∆1(xM+) + (xM+−M)Ω] + 2 δf,
with the same p∆1(·)as defined in the statement.
Let us now upper bound pΓ:=p∆1(xM+) + (xM+−M)Ω. For this, let us fix an arbitrary constant
ĎM≥0and consider two cases. If xM+≥ĎM, we can bound, using the monotonicity of p∆1(·),
pΓ =p∆1(xM+) + [p∆1(xM+)]+≤p∆1(ĎM) + [p∆1(ĎM)]+≤2[p∆1(ĎM)]+.
IfxM+≤ĎM, we can bound
pΓ≤[p∆1(xM+)]++ (xM+−M)Ω = 2(xM+−M)Ω = 2[min {xM+,ĎM} −M]+Ω.
Combining the two cases, we get pΓ≤2[p∆1(ĎM)]++ 2[min {xM+,ĎM} −M]+Ω,and hence
Γ≤E[pΓ] + 2 δf≤2E
[p∆1(ĎM)]+	
+ 2E
[min{xM+,ĎM} −M]+Ω	
+ 2δf.
Let us now estimate the first term. According to our Assumption 1 and Theorem 14 (inequality (9)),
we have ⟨sg(px+)−sg(x),px+−x⟩ ≤Lf∥px+−x∥2+ 2δf. Hence, denoting pS:=pgx−sg(x)and
pS+:=pgx+−sg(px+), we can estimate, for any ĎM > 2Lf,
p∆1(ĎM) =⟨sg(px+)−sg(x),px+−x⟩+⟨pS+−pS,px+−x⟩ −ĎM
2∥px+−x∥2
≤ ⟨pS+−pS,px+−x⟩ −ĎM−2Lf
2∥px+−x∥2+ 2δf≤1
2(ĎM−2Lf)∥pS+−pS∥2
∗+ 2δf.
Hence,
E
[p∆1(ĎM)]+	
≤1
2(ĎM−2Lf)E[∥pS+−pS∥2
∗]+2δf=1
2(ĎM−2Lf)E[Varpg(px+)+Varpg(x)]+2δf,
where the final identity follows from the fact that E[∥pS+−pS∥2
∗] =E[∥pS+∥2
∗] +E[∥pS∥2
∗] =
E[Varpg(px+)] + Var pg(x)(becausepS+, conditioned on the randomness ξdefiningpgx≡g(x, ξ),
has zero mean).
Thus,
Γ≤1
ĎM−2LfE[Varpg(px+) + Var pg(x)] + 6 δf+ 2E
[min{xM+,ĎM} −M]+Ω	
,
which is exactly (2) with c1= 1,c2= 2,c3= 6,c4= 2.
18C Omitted Proofs for Section 4
C.1 Universal SGD
Lemma 22 (Stochastic Gradient Step) .Consider problem (1)under Assumption 1. Let pgbe an
unbiased oracle for sg. Letx∈domψbe a point, M≥0be a coefficient, pgx∼=pg(x), and let
px+= Prox ψ(x,pgx, M).
Denotep∆(M):=βf,sf,sg(x,px+) +⟨sg(x)−pgx,px+−x⟩ −M
2∥px+−x∥2. Then,
Eh
F(px+)−F∗+M
2∥px+−x∗∥2i
+βf,sf,sg(x, x∗)≤M
2∥x−x∗∥2+E[p∆(M)].
If further Assumption 2 is satisfied, and xM+≥Mis a random coefficient (possibly dependent on pgx),
then, we also have
Eh
F(px+)−F∗+xM+
2∥px+−x∗∥2i
+βf,sf,sg(x, x∗)≤M
2∥x−x∗∥2+Ep∆(xM+)+(xM+−M)D2
.
Proof. From Lemma 17, it follows that
sf(x) +⟨pgx,px+−x⟩+ψ(px+) +M
2∥px+−x∗∥2+M
2∥px+−x∥2
≤sf(x) +⟨pgx, x∗−x⟩+ψ(x∗) +M
2∥x−x∗∥2.
Passing to expectations and rewriting
E[sf(x) +⟨pgx, x∗−x⟩+ψ(x∗)] =sf(x) +⟨sg(x), x∗−x⟩+ψ(x∗) =F(x∗)−βf,sf,sg(x, x∗),
and
sf(x) +⟨pgx,px+−x⟩+ψ(px+) =F(px+)−[f(px+)−sf(x)− ⟨pgx,px+−x⟩]
=F(px+)−[βf,sf,sg(x,px+) +⟨sg(x)−pgx,px+−x⟩],
we obtain the first of the claimed inequalities.
To prove the second one, we simply add to both sides of the already proved first inequality the
expected value of
xM+−M
2∥px+−x∗∥2+p∆(M)−p∆(xM+) =xM+−M
2 
∥px+−x∗∥2+∥px+−x∥2
and then bound ∥px+−x∗∥ ≤ D,∥px+−x∥ ≤ Dusing our Assumption 2 and the fact that
x,px+, x∗∈domψ.
Lemma 23 (Universal Stochastic Gradient Step) .Consider problem (1)under Assumptions 1 and 2.
Letpgbe an unbiased oracle for sg. Further, let x∈domψbe a point, M≥0be a coefficient,
pgx∼=pg(x), and let
px+= Prox ψ(x,pgx, M),pgx+∼=pg(px+),xM+=M+(M, D2, x,px+,pgx,pgx+).
Then, for any ĎM > c 2Lf, it holds that
Eh
F(px+)−F∗+xM+
2∥px+−x∗∥2+βf,sf,sg(px+, x)i
+βf,sf,sg(x, x∗)
≤M
2∥x−x∗∥2+c1
ĎM−c2LfE[Varpg(px+)+Varpg(x)]+c3δf+c4E
[min{xM+,ĎM}−M]+D2	
.
Proof. According to Lemma 22,
Eh
F(px+)−F∗+xM+
2∥px+−x∗∥2i
+βf,sf,sg(x, x∗)≤M
2∥x−x∗∥2+Ep∆(xM+)+(xM+−M)D2
,
19wherep∆(xM+):=βf,sf,sg(x,px+)+⟨sg(x)−pgx,px+−x⟩−xM+
2∥px+−x∥2. At the same time, according
to the main requirement (2) on the stepsize update rule, for any ĎM > c 2Lf,
Ep∆(xM+) + (xM+−M)D2+βf,sf,sg(px+, x)
≤c1
ĎM−c2LfE[Varpg(px+) + Var pg(x)] +c3δf+c4E
[min{xM+,ĎM} −M]+D2	
.
Combining the two displays, we get the claim.
Lemma 24 (Universal SGD: General Guarantee) .Consider problem (1)under Assumptions 1 and 2.
Letpgbe an unbiased oracle for sg. Further, let x∈domψbe a point, M≥0be a coefficient, N≥1
be an integer, and let
(sxN, xN, MN)∼=UniSgdpg,ψ(x0, M0, N;D),
as defined by Algorithm 1, and let x0, . . . , x Nbe the corresponding points generated inside the
algorithm. Then, for any ĎM > c 2Lf, it holds that
Eh
N[F(sxN)−F∗] +MN
2∥xN−x∗∥2+N−1X
k=0[βf,sf,sg(xk+1, xk) +βf,sf,sg(xk, x∗)]i
≤M0
2∥x0−x∗∥2+c1
ĎM−c2LfN−1X
k=0E[Varpg(xk+1) + Var pg(xk)] +c3Nδf
+c4E
[min{MN,ĎM} −M0]+D2	
.
Proof. Each iteration kof the algorithm, when conditioned on xk, follows the construction from
Lemma 23 (with x=xk,pgx=gk,M=Mk,px+=xk+1,pgx+=gk+1,xM+=Mk+1). Hence, we
can write, after passing to full expectations, that, for each k= 0, . . . , N −1,
Eh
F(xk+1)−F∗+Mk+1
2∥xk+1−x∗∥2+βf,sf,sg(xk+1, xk) +βf,sf,sg(xk, x∗)i
≤EhMk
2∥xk−x∗∥2+c1
ĎM−c2Lf[Varpg(xk+1)+Varpg(xk)]+c4[min{Mk+1,ĎM}−Mk]+D2i
+c3δf,
whereĎM > 2Lfis an arbitrary constant. Telescoping the above inequalities (using Lemma 18) and
then bounding N[F(sxN)−F∗]≤PN
k=1[F(xk)−F∗](using the convexity of Fand our choice of
sxN=1
NPN
k=1xk), we get the claim.
Theorem 4. Let Algorithm 1 with M0= 0be applied to problem (1)under Assumptions 1–3. Then,
for the point sxNgenerated by the algorithm, we have
E[F(sxN)]−F∗≤c2c4LfD2
N+ 2σDr
2c1c4
N+c3δf.
Proof. Applying Lemma 24, substituting our choice of M0= 0, estimating Varpg(·)≤σ2and
dropping the nonnegative βf,sf,sg(·,·)terms, we obtain
E[F(sxN)]−F∗≤1
N
c4ĎMD2+2c1σ2N
ĎM−c2Lf+c3Nδf
=c4ĎMD2
N+2c1σ2
ĎM−c2Lf+c3δf,
whereĎM > 2Lfis an arbitrary constant. The optimal ĎMwhich minimizes the right-hand side is
ĎM=c2Lf+σ
Dq
2c1
c4N. Substituting this choice into the above display, we get
E[F(sxN)]−F∗≤c4D2
N
c2Lf+σ
Dr
2c1
c4N
+2c1σ2
σ
Dq
2c1
c4N+c3δf
=c2c4LfD2
N+ 2σDr
2c1c4
N+c3δf.
20C.2 Universal Fast SGD
Lemma 25 (Stochastic Triangle Step) .Consider problem (1)under Assumption 1. Let pgbe an
unbiased oracle for sg, letx, v∈domψbe points and M, A≥0,a >0be coefficients. Further, for
A+:=A+a, let
y=Ax+av
A+,pgy∼=pg(y),pv+= Prox ψ(v,pgy, M/a ),px+=Ax+apv+
A+.
Denotep∆(M):=βf,sf,sg(y,px+) +⟨sg(y)−pgy,px+−y⟩ −MA +
2a2∥px+−y∥2. Then,
Eh
A+[F(px+)−F∗] +M
2∥pv+−x∗∥2i
+Aβf,sf,sg(y, x) +aβf,sf,sg(y, x∗)
≤A[F(x)−F∗] +M
2∥v−x∗∥2+A+E[p∆(M)].
If further Assumption 2 is satisfied, and xM+≥Mis a random coefficient (possibly dependent on pgy),
then we also have
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2i
+Aβf,sf,sg(y, x) +aβf,sf,sg(y, x∗)
≤A[F(x)−F∗] +M
2∥v−x∗∥2+E[A+p∆(xM+) + (xM+−M)D2],
Proof. Denoting θ:=Aβf,sf,sg(y, x) +aβf,sf,sg(y, x∗)and using the fact that E[pgy] =sg(y), we can
rewrite
AF(x) +aF(x∗) +M
2∥v−x∗∥2
=A[sf(y) +⟨sg(y), x−y⟩+βf,sf,sg(y, x) +ψ(x)]
+a[sf(y) +⟨sg(y), x∗−y⟩+βf,sf,sg(y, x∗) +ψ(x∗)] +M
2∥v−x∗∥2
=A+sf(y) +⟨sg(y), Ax+ax∗−A+y⟩+Aψ(x) +aψ(x∗) +M
2∥v−x∗∥2+θ
=Eh
A+sf(y) +⟨pgy, Ax+ax∗−A+y⟩+Aψ(x) +aψ(x∗) +M
2∥v−x∗∥2i
+θ.
Further, by the definition of pv+and Lemma 17,
⟨pgy, x∗−pv+⟩+ψ(x∗) +M
2a∥v−x∗∥2≥ψ(pv+) +M
2a∥v−pv+∥2+M
2a∥pv+−x∗∥2.
This means that
A+sf(y) +⟨pgy, Ax+ax∗−A+y⟩+Aψ(x) +aψ(x∗) +M
2∥v−x∗∥2
≥A+sf(y) +⟨pgy, Ax+apv+−A+y⟩+Aψ(x) +aψ(pv+) +M
2∥v−pv+∥2+M
2∥pv+−x∗∥2
≥A+[sf(y) +⟨pgy,px+−y⟩+ψ(px+)] +M
2∥v−pv+∥2+M
2∥pv+−x∗∥2
=A+F(px+) +M
2∥pv+−x∗∥2−A+p∆(M),
where the second inequality is due to the definition of px+and the convexity of ψ, and
p∆(M):=f(px+)−sf(y)− ⟨pgy,px+−y⟩ −M
2A+∥v−pv+∥2
=βf,sf,sg(y,px+) +⟨sg(y)−pgy,px+−y⟩ −MA +
2a2∥px+−y∥2
sincepx+−y=a
A+(pv+−v)(by the definitions of yandpx+). Substituting the above inequality into
the first display and rearranging, we get the first of the claimed inequalities.
21To prove the second one, we simply add to both sides of the already proved first inequality the
expected value of
xM+−M
2∥pv+−x∗∥2+A+[p∆(M)−p∆(xM+)] =xM+−M
2
∥pv+−x∗∥2+A2
+
a2∥px+−y∥2
and then bound, using the fact that px+−y=a
A+(pv+−v)together with our Assumption 2,
∥pv+−x∗∥2+A2
+
a2∥px+−y∥2=∥pv+−x∗∥2+∥pv+−v∥2≤2D2.
Lemma 26 (Universal Stochastic Triangle Step) .Consider problem (1)under Assumptions 1 and 2,
and letpgbe an unbiased oracle for sg. Letx, v∈domψbe points, M, A≥0,a >0be coefficients.
Further, for A+:=A+a, let
y=Ax+av
A+,pgy∼=pg(y),pv+= Prox ψ(v,pgy, M/a ),px+=Ax+apv+
A+,
pgx+∼=pg(px+),xM+=a2
A+M+A+
a2M,a2
A2
+D2, y,px+,pgy,pgx+
.
Then, for any ĎM > c 2Lfa2
A+, it holds that
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2+A+βf,sf,sg(px+, y)i
+Aβf,sf,sg(y, x) +aβf,sf,sg(y, x∗)
≤A[F(x)−F∗] +M
2∥v−x∗∥2+c1a2
ĎM−c2Lfa2
A+E[Varpg(px+) + Var pg(y)]
+c3A+δf+c4E
[min{xM+,ĎM} −M]+D2	
.
Proof. According to Lemma 25 (together with the fact that xM+≥Mwhich is guaranteed by the
requirement on the stepsize update rule), we have
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2i
+Aβf,sf,sg(y, x) +aβf,sf,sg(y, x∗)
≤A[F(x)−F∗] +M
2∥v−x∗∥2+E
A+p∆(xM+) + (xM+−M)D2
,
wherep∆(xM+):=βf,sf,sg(y,px+)+⟨sg(y)−pgy,px+−y⟩−xM+A+
2a2∥px+−y∥2. Further, according to the
main requirement (2)on the stepsize update rule (applied in the variables M′:=A+
a2M,Ω:=a2
A2
+D2,
xM′
+:=A+
a2xM+,ĎM′:=A+
a2ĎMfor which we have M′Ω =MD2
A+,xM′
+Ω =xM+D2
A+,ĎM′Ω =ĎMD2
A+),
it holds that
Eh
p∆(xM+) + (xM+−M)D2
A++βf,sf,sg(px+, y)i
≤c1
A+
a2ĎM−c2LfE[Varpg(px+) + Var pg(y)] +c3δf+c4En
[min{xM+,ĎM} −M]+D2
A+o
,
whereĎM > c 2Lfa2
A+is an arbitrary constant. Multiplying both sides of the above display by A+and
adding the result to the first display, we obtain the claim.
Lemma 27 (Universal Fast SGD: General Guarantee) .Consider Algorithm 2 applied to problem (1)
under Assumptions 1 and 2. Then, for any k≥1and anyĎM > c 2Lf, it holds that
Eh
Ak[F(xk)−F∗] +k−1X
i=0[Ai+1βf,sf,sg(xi+1, yi) +ai+1βf,sf,sg(yi, x∗)]i
≤c4ĎMD2+c1
ĎM−c2Lfk−1X
i=0a2
i+1E[Varpg(xi+1) + Var pg(yi)] +c3δfkX
i=1Ai,
22where ak=1
2k,Ak=1
4k(k+ 1) ,Pk
i=1a2
i=1
24k(k+ 1)(2 k+ 1) ,Pk
i=1Ai=1
12k(k+ 1)( k+ 2)
for each k≥1.
Proof. Each iteration kof the algorithm, when conditioned on (xk, vk), follows the construction
from Lemma 26 (with x=xk,v=vk,M=Mk,A=Ak,a=ak+1,A+=Ak+1,y=yk,
pgy=gyk,pv+=vk+1,px+=xk+1,pgx+=gxk+1,xM+=Mk+1), where Akandakare the following
coefficients: ak=1
2k,Ak=Pk
i=1ai=1
4k(k+ 1). Applying Lemma 26 (dropping the nonnegative
βf,sf,sg(y, x)term) and passing to full expectations, we therefore obtain, for each k≥0,
Eh
Ak+1[F(xk+1)−F∗] +Mk+1
2∥vk+1−x∗∥2+Ak+1βf,sf,sg(xk+1, yk) +ak+1βf,sf,sg(yk, x∗)i
≤Eh
Ak[F(xk)−F∗] +Mk
2∥vk−x∗∥2+c1a2
k+1
ĎM−c2Lfa2
k+1
Ak+1[Varpg(xk+1) + Var pg(yk)]i
+c3Ak+1δf+c4E
[min{Mk+1,ĎM} −Mk]+D2	
,
whereĎMis an arbitrary constant such that ĎM > c 2Lfa2
k+1
Ak+1. Note however that, for our sequences ak
andAk, we havea2
k
Ak=1
4k2
1
4k(k+1)=k
k+1≤1. Therefore, we can replacec1a2
k+1
ĎM−c2Lfa2
k+1
Ak+1in the above
display withc1a2
k+1
ĎM−c2Lfunder the requirement that ĎM > c 2Lf. Doing this and then telescoping the
above inequalities (applying Lemma 18), and using the fact that M0=A0= 0, we get the claimed
inequality.
It remains to do some standard computations to see thatPk
i=1a2
i≡1
4Pk
i=1i2=1
24k(k+1)(2 k+1)
andPk
i=1Ai≡1
4Pk
i=1i(i+ 1) =1
4(1
6k(k+ 1)(2 k+ 1) +1
2k(k+ 1)) =1
12k(k+ 1)( k+ 2).
Theorem 5. Let Algorithm 2 be applied to problem (1)under Assumptions 1–3. Then, for any k≥1,
E[F(xk)]−F∗≤4c2c4LfD2
k(k+ 1)+ 4σDr
2c1c4
3k+c3
3(k+ 2)δf.
Proof. Letk≥1be arbitrary and Fk:=E[F(xk)]−F∗. Applying Lemma 27, dropping the
nonnegative βf,sf,sg(·,·)terms and bounding Varpg(·)≤σ2, we obtain, for an arbitrary constant
ĎM > c 2Lf,
Fk≤1
Ak
c4ĎMD2+2c1σ2
ĎM−c2LfkX
i=1a2
i+c3δfkX
i=1Ai
=4
k(k+ 1)
c4ĎMD2+c1k(k+ 1)(2 k+ 1)σ2
12(ĎM−c2Lf)+c3
12k(k+ 1)( k+ 2)δf
=4c4ĎMD2
k(k+ 1)+c1(2k+ 1)σ2
3(ĎM−c2Lf)+δk,
where δk:=c3
3(k+ 2)δf. We now choose ĎM > c 2Lfwhich minimizes the right-hand side. This is
ĎM=c2Lf+σ
2Dq
c1
3c4k(k+ 1)(2 k+ 1) , for which we get
Fk≤4c4D2
k(k+ 1)
c2Lf+σ
2Drc1
3c4k(k+ 1)(2 k+ 1)
+c1(2k+ 1)σ2
3σ
2Dq
c1
3c4k(k+ 1)(2 k+ 1)+δk
=4c2c4LfD2
k(k+ 1)+ 4σDs
c1c4(2k+ 1)
3k(k+ 1)+δk≤4c2c4LfD2
k(k+ 1)+ 4σDr
2c1c4
3k+δk.
23D Omitted Proofs for Section 5
D.1 Universal SGD
Theorem 7. Let Algorithm 1 with M0= 0be applied to problem (1)under Assumptions 1, 2 and 6,
and let σ2
∗:= Varpg(x∗). Then, for the point sxNproduced by the method, we have
E[F(sxN)]−F∗≤c4(c2Lf+ 12c1Lpg)D2
N+ 2σ∗Dr
6c1c4
N+c3δf+4
3δpg.
Proof. Letx0, . . . , x Nbe the points generated inside the method and let FN:=E[F(sxN)]−F∗.
Using Lemma 19 and Assumption 6, we can estimate, for any 0≤k≤N−1,
Varpg(xk+1) + Var pg(xk)≤3 Varpg(xk) + 2 Var pg(xk+1, xk)
≤6σ2
∗+ 6 Var pg(xk, x∗) + 2 Var pg(xk+1, xk)
≤6σ2
∗+ 12Lpg[βf,sf,sg(xk, x∗) +δpg] + 4Lpg[βf,sf,sg(xk+1, xk) +δpg]
= 6σ2
∗+ 4Lpg[3βf,sf,sg(xk, x∗) +βf,sf,sg(xk+1, xk) + 4δpg].
Substituting this bound into the general guarantee given by Lemma 24 (and taking into account the
fact that M0= 0), we obtain
NFN+N−1X
k=0E[βf,sf,sg(xk+1, xk) +βf,sf,sg(xk, x∗)]
≤c4ĎMD2+6c1σ2
∗N
ĎM−c2Lf+αN−1X
k=0E[βf,sf,sg(xk+1, xk) + 3βf,sf,sg(xk, x∗)] +N(c3δf+ 4αδpg),
whereĎM > c 2Lfis an arbitrary constant and α:=4c1Lpg
ĎM−c2Lf. Requiring now that 3α≤1or,
equivalently, that ĎM≥c2Lf+ 12c1Lpg=:ĎMmin, we can cancel the nonnegative βf,sf,sg(·,·)terms
on both sides and obtain
FN≤c4ĎMD2
N+6c1σ2
∗
ĎM−c2Lf+δ,
where δ:=c3δf+4
3δpg. The optimal coefficient ĎM∗minimizing the right-hand side is ĎM∗=
c2Lf+σ∗
Dq
6c1N
c4. However, we still need to respect the constraint ĎM≥ĎMmin. Choosing ĎM=
c2Lf+ 12c1Lpg+σ∗
Dq
6c1N
c4, we conclude that
FN≤c4D2
N
c2Lf+ 12c1Lpg+σ∗
Dr
6c1N
c4
+6c1σ2
∗
σ∗
Dq
6c1N
c4+δ
=c4(c2Lf+ 12c1Lpg)D2
N+ 2σ∗Dr
6c1c4
N+δ.
D.2 Universal Fast SGD
Theorem 8. Let Algorithm 2 be applied to problem (1)under Assumptions 1, 2 and 6, and let
σ2
∗:= Varpg(x∗). Then, for any k≥1, we have
E[F(xk)]−F∗≤4c2c4LfD2
k(k+ 1)+24c1c4LpgD2
k+ 1+ 4σ∗Dr
2c1c4
k+c3
3(k+ 2)δf+4
3δpg.
Proof. Letk≥1be arbitrary and Fk:=E[F(xk)]−F∗. Using Lemma 19 and Assumption 6, we
can estimate, for each i,
Varpg(xi+1) + Var pg(yi)≤3 Varpg(yi) + 2 Var pg(xi+1, yi)
≤6σ2
∗+ 6 Var pg(yi, x∗) + 2 Var pg(xi+1, yi)
≤6σ2
∗+ 12Lpg[βf,sf,sg(yi, x∗) +δpg] + 4Lpg[βf,sf,sg(xi+1, yi) +δpg]
= 6σ2
∗+ 4Lpg[3βf,sf,sg(yi, x∗) +βf,sf,sg(xi+1, yi) + 4δpg].
24Substituting this bound into the guarantee given by Lemma 27, we obtain
AkFk+k−1X
i=0E[Ai+1βf,sf,sg(xi+1, yi) +ai+1βf,sf,sg(yi, x∗)]
≤c4ĎMD2+k−1X
i=0αi+1E[βf,sf,sg(xi+1, yi)+3βf,sf,sg(yi, x∗)+4δpg]+6c1σ2
∗
ĎM−c2LfkX
i=1a2
i+c3δfkX
i=1Ai,
where αi+1:=4c1Lpga2
i+1
ĎM−c2Lf,ai=1
2i,Ak=1
4k(k+ 1) ,Pk
i=1a2
i=1
24k(k+ 1)(2 k+ 1) ,Pk
i=1Ai=
1
12k(k+ 1)( k+ 2) . Requiring now that 3αi+1≤ai+1for all i= 0, . . . , k −1or, equivalently, that
ĎM≥c2Lf+ 12c1Lpgak≡c2Lf+ 6c1Lpgk, we can cancel the nonnegative βf,sf,sg(·,·)terms on both
sides and obtain
Fk≤1
Ak
c4ĎMD2+6c1σ2
∗
ĎM−c2LfkX
i=1a2
i+c3δfkX
i=1Ai+4
3Akδpg
=4
k(k+ 1)
c4ĎMD2+c1σ2
∗k(k+ 1)(2 k+ 1)
4(ĎM−c2Lf)+c3
12δfk(k+ 1)( k+ 2)
+4
3δpg
=4c4ĎMD2
k(k+ 1)+c1σ2
∗(2k+ 1)
ĎM−c2Lf+δk,
where δk:=c3
3(k+ 2)δf+4
3δpg.
The minimizer of the right-hand side is ĎM∗=c2Lf+σ∗
2Dq
c1
c4k(k+ 1)(2 k+ 1). However, recall
that we also need to satisfy the constraint ĎM≥c2Lf+ 6c1Lpgk. Choosing ĎM=c2Lf+ 6c1Lpgk+
σ∗
2Dq
c1
c4k(k+ 1)(2 k+ 1) , we obtain
Fk≤4c4D2
k(k+ 1)
c2Lf+ 6c1Lpgk+σ∗
2Drc1
c4k(k+ 1)(2 k+ 1)
+c1σ2
∗(2k+ 1)
σ∗
2Dq
c1
c4k(k+ 1)(2 k+ 1)+δk
=4c2c4LfD2
k(k+ 1)+24c1c4LpgD2
k+ 1+ 4σ∗Ds
c1c4(2k+ 1)
k(k+ 1)+δk
≤4c2c4LfD2
k(k+ 1)+24c1c4LpgD2
k+ 1+ 4σ∗Dr
2c1c4
k+δk.
E Omitted Proofs for Section 6
Lemma 28 (Basic property of SVRG oracle) .Letpgbe a stochastic oracle in Rd, and letpG=
SvrgOracpg(˜x)for some ˜x∈Rd. Then, for any x∈Rd, the mean value of pGatxis the same as that
ofpgatx, while VarpG(x) = Var pg(x,˜x).
Proof. Letgandξbe, respectively, the function and the random variable components of pg, and let
g(x):=Eξ[g(x, ξ)],g(˜x):=Eξ[g(˜x, ξ)]. Then, by definition, pGis the oracle with the same random
variable component ξand the function component Gdefined by G(x, ξ) =g(x, ξ)−g(˜x, ξ) +g(˜x).
Consequently, Eξ[G(x, ξ)] =g(x), and
VarpG(x) =Eξ
∥G(x, ξ)−g(x)]∥2
∗
=Eξ
∥[g(x, ξ)−g(˜x, ξ)]−[g(x)−g(˜x)]∥2
∗
= Varpg(x,˜x).
E.1 Universal SVRG
Lemma 29 (Universal SVRG Epoch) .Consider problem (1)under Assumptions 1, 2, 6 and 9. Let
x,˜x∈domψbe points, M≥0be a coefficient, N≥1be an integer, pG= SvrgOracpg(˜x), and let
(˜x+, x+, M+)∼=UniSgd pG,ψ(x, M, N ;D),
25as defined by Algorithm 1. Then, for any ĎM≥c2Lf+ 12c1Lpg,α:=4c1Lpg
ĎM−c2Lf, and any ∇f(x∗)∈
∂f(x∗), it holds that
Eh
N[F(˜x+)−F∗] +M+
2∥x+−x∗∥2i
≤6αNβ∇f(x∗)
f(x∗,˜x)+M
2∥x−x∗∥2+N(c3δf+16αδpg)+c4D2E
[min{M+,ĎM}−M]+	
.
Proof. Sincepgis an unbiased oracle for sg, so ispG(Lemma 28). Therefore, we can apply Lemma 24
to get
Eh
N[F(˜x+)−F∗] +M+
2∥x+−x∗∥2+N−1X
k=0[βf,sf,sg(xk+1, xk) +βf,sf,sg(xk, x∗)]i
≤M
2∥x−x∗∥2+c1
ĎM−c2LfN−1X
k=0E[VarpG(xk+1) + Var pG(xk)] +c3Nδf
+c4E
[min{M+,ĎM} −M]+D2	
,
whereĎM > c 2Lfis an arbitrary constant and xkare the points generated inside UniSgd .
Applying now Lemmas 19 and 28 and Assumptions 6 and 9, we can estimate, for each k,
VarpG(xk+1) + Var pG(xk) = Var pg(xk+1,˜x) + Var pg(xk,˜x)≤2 Varpg(xk+1, xk) + 3 Var pg(xk,˜x)
≤2 Varpg(xk+1, xk) + 6 Var pg(xk, x∗) + 6 Var pg(x∗,˜x)
≤4Lpg[βf,sf,sg(xk+1, xk) +δpg] + 12 Lpg[βf,sf,sg(xk, x∗) +δpg] + 24 Lpg[β∇f(x∗)
f(x∗,˜x) + 2δpg]
= 4Lpg[βf,sf,sg(xk+1, xk) + 3βf,sf,sg(xk, x∗) + 6β∇f(x∗)
f(x∗,˜x) + 16 δpg],
where ∇f(x∗)∈∂f(x∗)is arbitrary. Denoting α:=4c1Lpg
ĎM−c2Lf, we thus obtain
Eh
N[F(˜x+)−F∗] +M+
2∥x+−x∗∥2+N−1X
k=0[βf,sf,sg(xk+1, xk) +βf,sf,sg(xk, x∗)]i
≤6αNβ∇f(x∗)
f(x∗,˜x) +M
2∥x−x∗∥2+N(c3δf+ 16αδpg) +c4E
[min{M+,ĎM} −M]+D2	
+αN−1X
k=0E[βf,sf,sg(xk+1, xk) + 3βf,sf,sg(xk, x∗)].
Requiring now ĎM≥c2Lf+ 12c1Lpg, we get α≤1
3which allows us to cancel the nonnegative
βf,sf,sg(·,·)terms on both sides. The claim now follows.
Theorem 10. LetUniSvrg (as defined by Algorithm 3) be applied to problem (1)under Assumptions 1,
2, 6 and 9. Then, for any t≥1andsc3:= max {c3,1}, we have
E[F(˜xt)]−F∗≤[(c2c4+ 1)Lf+ 48c1c4Lpg]D2
2t+ 2sc3δf+8
3δpg.
To construct ˜xt, the algorithm needs to make O(2t)queries topgandO(t)queries tosg.
Proof. The algorithm iterates (˜xt+1, xt+1, Mt+1)∼=UniSgd pGt,ψ(xt, Mt,2t+1;D)fort≥0, where
pGt= SvrgOracpg(˜xt). Applying Lemma 29 with ĎM:=c2Lf+ 48c1Lpg(for which α=1
12so that
6α2t+1= 2t) and passing to full expectations, we obtain, for any t≥0,
Eh
2t+1[F(˜xt+1)−F∗] +Mt+1
2∥xt+1−x∗∥2i
≤Eh
2tβt+Mt
2∥xt−x∗∥2+c4[min{Mt+1,ĎM} −Mt]+D2i
+ 2t+1
c3δf+4
3δpg
,
26where βt:=β∇f(x∗)
f(x∗,˜xt)and∇f(x∗)∈∂f(x∗)can be chosen arbitrarily. Rewriting Ft+1:=
F(˜xt+1)−F∗asFt+1=βt+1+ (Ft+1−βt+1)and telescoping the above inequalities (using,
Lemma 18), we get, for any t≥1,
Eh
2tβt+tX
i=12i(Fi−βi) +Mt
2∥xt−x∗∥2i
≤β0+M0
2∥x0−x∗∥2+
c3δf+4
3δpgtX
i=12i+c4E
[min{Mt,ĎM} −M0]+D2	
≤β0+ 2(2t−1)
c3δf+4
3δpg
+c4ĎMD2=:Φ0,
where the final inequality is due to the fact that M0= 0, whilePt
i=12i= 2(2t−1). According to
Lemma 30, we can choose ∇f(x∗)∈∂f(x∗)such that βi≤F(˜xi)−F∗for all i≥0. Dropping
now various nonnegative terms from the left-hand side of the above display, we conclude that
2tE[Ft]≤Φ0.
Let us estimate Φ0. Using our Assumptions 1 and 2 and Theorem 14 (inequality (14)), we can bound
β0≤Lf∥˜x0−x∗∥2+ 2δf≤LfD2+ 2δf. Therefore,
Φ0≤LfD2+ 2δf+c4ĎMD2+ 2(2t−1)(c3δf+4
3δpg)≤LD2+ 2(sc3δf+4
3δpg)·2t
where L:=Lf+c4ĎM≡(c2c4+ 1)Lf+ 48c1c4Lpgandsc3:= max {c3,1}. Thus,
E[Ft]≤Φ0
2t≤LD2
2t+ 2sc3δf+8
3δpg,
which proves the claimed convergence rate.
Let us now estimate the number of oracle queries. At each iteration t, the algorithm first queries sg
to construct the SVRG oracle pGt(by precomputing sg(˜xt)). All other queries are then done only
topGtor, equivalently, to pginside UniSgd pGt,ψwhich is run for Nt+1= 2t+1iterations and thus
requiring O(Nt+1)queries topg. Summing up, after Titerations, we obtain the total number ofPT
t=1O(Nt) =PT
t=1O(2t) =O(2T)queries topg, and Tqueries tosg.
Helper Lemmas
Lemma 30. LetF:Rd→R∪{+∞}be the function F(x):=f(x) +ψ(x), where f:Rd→Ris a
convex function, and ψ:Rd→R∪ {+∞}is a proper closed convex function. Let x∗be a minimizer
ofFand let F∗:=F(x∗). Then, there exists ∇f(x∗)∈∂f(x∗)such that, for any x∈domψ,
F(x)−F∗≥β∇f(x∗)
f(x∗, x).
Proof. Since x∗is a minimizer of F, we have 0∈∂F(x∗) =∂f(x∗) +∂ψ(x∗). In other words,
there exists ∇f(x∗)∈∂f(x∗)such that ∇ψ(x∗):=−∇f(x∗)∈∂ψ(x∗). Consequently, for any
x∈domψ,
F(x)−F∗=f(x)−f(x∗) + [ψ(x)−ψ(x∗)]≥f(x)−f(x∗) +⟨∇ψ(x∗), x−x∗⟩
=f(x)−f(x∗)− ⟨∇ f(x∗), x−x∗⟩=β∇f(x∗)
f(x∗, x).
E.2 Universal Fast SVRG
Lemma 31 (Universal Triangle SVRG Step) .Consider problem (1)under Assumptions 1, 2 and 6.
Let˜x, v∈domψbe points, M≥0andA, a > 0be coefficients, pG:= SvrgOracpg(˜x). Further, let,
forA+:=A+a,
x:=A˜x+av
A+,pGx∼=pG(x),pv+= Prox ψ(v,pGx, M/a ),px+=A˜x+apv+
A+,
pGx+∼=pG(px+),xM+=a2
A+M+A+
a2M,a2
A2
+D2, x,px+,pGx,pGx+
.
27Then, forĎM:=c2Lfa2
A++ 6c1Lpga2
A, it holds that
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2i
≤A[F(˜x)−F∗] +M
2∥v−x∗∥2+c4D2E
[min{xM+,ĎM} −M]+	
+c3A+δf+5
3Aδpg.
Proof. Sincepgis an unbiased oracle for sg, so ispG(Lemma 28). Therefore, we can apply Lemma 26
to obtain
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2+A+βf,sf,sg(px+, x)i
+Aβf,sf,sg(x,˜x)
≤A[F(˜x)−F∗] +M
2∥v−x∗∥2+c1a2
ĎM−c2Lfa2
A+E[VarpG(px+) + Var pG(x)]
+c3A+δf+c4E
[min{xM+,ĎM} −M]+D2	
,
whereĎM > c 2Lfa2
A+is an arbitrary coefficient. Using Lemmas 19 and 28 and Assumption 6, we can
further bound
VarpG(px+) + Var pG(x) = Var pg(px+,˜x) + Var pg(x,˜x)≤2 Varpg(px+, x) + 3 Var pg(x,˜x)
≤2Lpg[2βf,sf,sg(px+, x) + 3βf,sf,sg(x,˜x) + 5δpg].
Denoting α:=2c1Lpga2
ĎM−c2Lfa2
A+, we thus obtain
Eh
A+[F(px+)−F∗] +xM+
2∥pv+−x∗∥2+A+βf,sf,sg(px+, x)i
+Aβf,sf,sg(x,˜x)
≤A[F(˜x)−F∗] +M
2∥v−x∗∥2+c3A+δf+ 5αδpg+c4E
[min{xM+,ĎM} −M]+D2	
+ 2αE[βf,sf,sg(px+, x)] + 3 αβf,sf,sg(x,˜x).
Choosing now ĎM=c2Lfa2
A++ 6c1Lpga2
A, we get α=1
3A(≤1
3A+), which allows us to drop the
nonnegative βf,sf,sg(·,·)terms from both sides. The claim now follows.
Lemma 32 (Universal Triangle SVRG Epoch) .Consider problem (1)under Assumptions 1, 2 and 6.
Let˜x, v∈domψbe points, M≥0andA, a > 0be coefficients, N≥1be an integer, and let
(˜x+, v+, M+)∼=UniTriSvrgEpochpg,ψ(˜x, v, M, A, a, N ;D),
as defined by Algorithm 5. Then, for A+:=A+aandĎM:=c2Lfa2
A++ 6c1Lpga2
A, it holds that
Eh
A+N[F(˜x+)−F∗] +M+
2∥v+−x∗∥2i
≤AN[F(˜x)−F∗]+M
2∥v−x∗∥2+c4D2E
[min{M+,ĎM}−M]+	
+N
c3A+δf+5
3Aδpg
.
Proof. Each iteration kof the algorithm, when conditioned on vk, follows the construction from
Lemma 31 (with v=vk,M=Mk,A=Ak,a=ak+1,A+=Ak+1,x=xk,pGx=Gxk,
pv+=vk+1,px+=xk+1,pGx+=Gxk+1,xM+=Mk+1). Hence, we can write, after passing to full
expectations, for each k= 0, . . . , N −1,
Eh
A+[F(xk+1)−F∗] +Mk+1
2∥vk+1−x∗∥2i
≤A[F(˜x)−F∗] +EhMk
2∥vk−x∗∥2+c4[min{Mk+1,ĎM} −Mk]+D2i
+δ,
28where δ:=c3A+δf+5
3Aδpg. Telescoping the above inequalities (using Lemma 18), we get
Eh
A+NX
k=1[F(xk)−F∗] +MN
2∥vN−x∗∥2i
≤AN[F(˜x)−F∗] +M0
2∥v0−x∗∥2+c4D2E
[min{MN,ĎM} −M0]+	
+Nδ.
The claim now follows from the convexity of Fand our definitions ˜x+=sxN=1
NPN
k=1xk,
v+=vN,M+=MN,M0=M,v0=v.
Theorem 11. LetUniFastSvrg (Algorithm 4) be applied to problem (1)under Assumptions 1, 2
and 6, and let N≥9. Then, for any t≥t0:=⌈log2log3N⌉ −1 (≥0), it holds that
E[F(˜xt)]−F∗≤9[(c2c4+1
2)Lf+ 6c1c4Lpg]D2
N(t−t0+ 1)2+ (c3t+ 1)δf+5
3tδpg.
To construct ˜xt, the algorithm needs to make O(Nt)queries topgandO(t)queries tosg. Assuming
that the complexity of querying sgisntimes bigger than that of querying pgand choosing N= Θ( n),
we get the total stochastic-oracle complexity of O(nt).
Proof. By our definition, the algorithm iterates for t≥0:
(˜xt+1, vt+1, Mt+1)∼=UniTriSvrgEpochpg,sg,ψ(˜xt, vt, Mt, At, at+1, N;D),
where Atandat+1are deterministic coefficients satisfying the following equations:
At+1=At+at+1, a t+1=p
At. (17)
In particular, for any t≥0, we haveĎM′
t:=c2Lfa2
t+1
At+1+ 6c1Lpga2
t+1
At≤c2Lf+ 6c1Lpg=:ĎM, and
hence [min{Mt+1,ĎM′
t} −Mt]+≤[min{Mt+1,ĎM} −Mt]+(because, for any fixed aandb, the
function [min{a,·} −b]+is nondecreasing as the composition of two nondecreasing functions).
Applying now Lemma 32 and passing to full expectations, we therefore obtain, for any t≥0,
Eh
At+1N[F(˜xt+1)−F∗] +Mt+1
2∥vt+1−x∗∥2i
≤Eh
AtN[F(˜xt)−F∗]+Mt
2∥vt−x∗∥2+c4[min{Mt+1,ĎM}−Mt]+D2i
+N
c3At+1δf+5
3Atδpg
.
Telescoping the above inequalities (using, in particular, Lemma 18), we obtain, for any t≥1,
AtNE[F(˜xt)−F∗]≤A0N[F(˜x0)−F∗] +M0
2∥v0−x∗∥2
+c4E
[min{Mt,ĎM} −M0]+D2	
+N
c3δftX
i=1Ai+5
3δpgt−1X
i=0Ai
≤A0N[F(˜x0)−F∗] +c4ĎMD2+NSt(c3δf+5
3δpg),
where, for the last inequality, we have used the fact that M0= 0and denoted St:=Pt
i=1Ai. Thus,
for any t≥1,
E[F(˜xt)]−F∗≤1
At
A0[F(˜x0)−F∗] +c4ĎMD2
N
+St
At
c3δf+5
3δpg
.
At the same time, according to (17), At+1−At=√Atfor any t≥0. Hence, by Lemma 33 (and our
assumption on A0), we can estimate At≥1
9(t−t0+1)2for any t≥t0:=⌈log2log31
A0⌉−1 (≥0).
Further, since the sequence Atis increasing, we can estimate St≡Pt
i=1Ai≤tAt, so thatSt
At≤t.
Substituting these bounds into the above display and using our formula for A0, we obtain, for any
t≥t0,
E[F(˜xt)]−F∗≤ρt[F(˜x0)−F∗+c4ĎMD2] +t(c3δf+5
3δpg),
29where ρt:=9
N(t−t0+1)2≤1. By our choice of ˜x0, it holds that F(˜x0)−F∗≤1
2LfD2+δf(see
Lemma 34). Denoting L:=1
2Lf+c4ĎM≡(c2c4+1
2)Lf+ 6c1c4Lpg, we get
E[F(˜xt)]−F∗≤ρt(LD2+δf) +t(c3δf+5
3δpg)≤ρtLD2+ (c3t+ 1)δf+5
3tδpg,
which is exactly the claimed convergence rate bound.
Let us now estimate the number of oracle queries. At the beginning, the algorithm makes 1query
tosgto compute ˜x0. All other queries to the oracles are then done, at each iteration t, only inside the
call to UniTriSvrgEpoch (Algorithm 5). Each such a call needs only one query to sgto construct
the SVRG oracle pG(by precomputing sg(˜x)), and O(N)queries topg(which implements each query
topG). Summing up, we get, after titerations, the total number of O(Nt)queries topgandO(t)
queries tosg.
Helper Lemmas
Lemma 33 (c.f. Lemma 1.1 in [23]) .LetAtbe a positive sequence such that
At+1−At≥p
γAt
for all t≥0, where γ >0, and let A0≤1
9γ. Then, for any t≥0, we have
At≥(
γ(A0
γ)1/2t, ift < t 0,
γ
9(t−t0+ 1)2,ift≥t0,
where t0:=⌈log2log3γ
A0⌉ −1 (≥0).
Proof. By replacing AtwithA′
t=At/γ, we can assume w.l.o.g. that γ= 1.
For any t≥0, we have At+1≥√At, and hence
At≥A1/2t
0.
In particular, for t0(as defined in the statement), we get t0≥log2log31
A0−1, so2t0≥1
2log31
A0,
and hence
At0≥A2/log3(1/A0)
0 = 
3−log3(1/A0)2/log3(1/A0)= 3−2=1
9
(recall that A0≤1
9≤1).
On the other hand, for any t≥t0, we have
p
At+1−p
At≥q
At+p
At−p
At=√Atp
At+√At+√At
=1q
1 +1√At+ 1≥1√1 + 3 + 1=1
3,
where we have used the fact that At≥At0≥1
9since Atis monotonically increasing. Telescoping
these inequalities and rearranging, we get, for any t≥t0,
At≥1
3(t−t0) +p
At02
≥1
3(t−t0) +1
32
=1
9(t−t0+ 1)2.
Lemma 34. Consider problem (1)under Assumptions 1 and 2. Let x∈domψ, and let x+:=
Prox ψ(x,sg(x),0). Then, F(x+)−F∗≤1
2LfD2+δf.
Proof. From the first-order optimality condition for the point x+(see Lemma 17), it follows that
⟨sg(x), x∗−x+⟩+ψ(x∗)≥ψ(x+).
30Combining the above inequality first with f(x+)≤sf(x) +⟨sg(x), x+−x⟩+Lf
2∥x+−x∥2+δf
and then with sf(x) +⟨sg(x), x∗−x⟩ ≤f(x∗)(which are both due to our Assumption 1), we obtain
F(x+) =f(x+) +ψ(x+)≤f(x+) +⟨sg(x), x∗−x+⟩+ψ(x∗)
≤sf(x) +⟨sg(x), x∗−x⟩+ψ(x∗) +Lf
2∥x+−x∥2+δf
≤F∗+Lf
2∥x+−x∥2+δf.
It remains to bound ∥x+−x∥ ≤D.
F Omitted Proofs for Section 7
We start with the observation that for our specific example all our main assumptions are satisfied.
Remark 35.Under the setting from Example 12, Assumptions 1, 6 and 9 are satisfied with sf=f,
sg(x) =∇f(x):=Eξ[∇fξ(x)], anyδf, δpg>0and
Lf=1−ν
2(1 + ν)δf1−ν
1+ν
[Hf(ν)]2
1+ν, L pg=1
b1−ν
2(1 + ν)δpg1−ν
1+ν
[Hmax(ν)]2
1+ν.
Further, the oracle pgbsatisfies Assumption 3 with σ2
b:= supx∈domψVarpgb(x) =1
bσ2, and σ2
∗,b:=
Varpgb(x∗) =1
bσ2
∗.
Proof. Forb= 1, this follows from Theorem 13 and Lemma 16 and our definitions of σ2andσ∗.
The general case b≥1follows from the fact that the standard mini-batching of size breduces each of
the variances Varpg1(·)andVarpg1(·,·)inbtimes.
The following auxiliary result will be useful throughout this section:
Lemma 36. Leta, b, p > 0be real. Then,
min
t>0na
tp+bto
= (p+ 1)a1
p+1b
pp
p+1
.
Proof. The expression inside the min is a convex function in t >0. Differentiating and setting its
derivative to zero, we see that the minimum is attained at t∗= (ap
b)1
p+1. Hence,
min
t>0na
tp+bto
=ab
app
p+1
+bap
b1
p+1
= (p+ 1)a1
p+1b
pp
p+1
.
F.1 Uniformly Bounded Variance
Corollary 37. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
Let Algorithm 1 be applied to this problem with the oracle pg=pgband initial coefficient M0= 0.
Then, for the point sxNgenerated by the algorithm, we have
E[F(sxN)]−F∗≤(2c2c4)1+ν
2c1−ν
2
3
1 +νHf(ν)D1+ν
N1+ν
2+ 2σDr
2c1c4
bN.
To reach E[F(sxN)]−F∗≤ϵfor any ϵ >0, it suffices to make O 
[Hf(ν)
ϵ]2
1+νD2+σ2D2
bϵ2
queries
topgb.
Proof. Denote for brevity Hf:=Hf(ν). Taking into account Remark 35 and applying Theorem 4,
we get, for any δf>0,
FN:=E[F(sxN)]−F∗≤c2c4H2
1+ν
fD2
N1−ν
2(1 + ν)δf1−ν
1+ν
+c3δf+σN,
31where σN:= 2σbDq
2c1c4
N= 2σDq
2c1c4
bN. Minimizing the right-hand side in δf(using Lemma 36
withp=1−ν
1+νfor which p+ 1 =2
1+ν), we obtain
FN≤2
1 +νc2c4H2
1+ν
fD2
N1−ν
2(1 + ν)1−ν
1+ν1+ν
21 +ν
1−νc31−ν
2
+σN
=(2c2c4)1+ν
2c1−ν
2
3
1 +νHfD1+ν
N1+ν
2+σN.
This proves the claimed convergence rate, and the oracle complexity bound easily follows since each
iteration of the algorithm requires only 1query topgb.
Corollary 38. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
Let Algorithm 2 be applied to this problem with the oracle pg=pgb. Then, for any k≥1, we have
E[F(xk)]−F∗≤22+ν(c2c4)1+ν
2(c3
3)1−ν
2
1 +νHf(ν)D1+ν
k1+3ν
2+ 4σDr
2c1c4
3bk.
To reach E[F(xk)]−F∗≤ϵfor any ϵ >0, it suffices to make O 
[Hf(ν)D1+ν
ϵ]2
1+3ν+σ2D2
bϵ2
queries
topgb.
Proof. Letk≥1be arbitrary and denote for brevity Hf:=Hf(ν). Taking into account Remark 35
and applying Theorem 5, we get, for any δf>0,
Fk:=E[F(xk)]−F∗≤4c2c4H2
1+ν
fD2
k(k+ 1)1−ν
2(1 + ν)δf1−ν
1+ν
+c3
3(k+ 2)δf+σk,
where σk:= 4σbDq
2c1c4
3k= 4σDq
2c1c4
3bk. Minimizing the right-hand side in δf(using Lemma 36)
and estimating k+ 2≤2(k+ 1) , we obtain
Fk≤2
1 +ν4c2c4H2
1+ν
fD2
k(k+ 1)1−ν
2(1 + ν)1−ν
1+ν1+ν
21 +ν
1−ν2c3(k+ 1)
31−ν
2
+σk
=2(4c2c4)1+ν
2(c3
3)1−ν
2
1 +νHfD1+ν
k1+ν
2(k+ 1)ν+σk.
This proves the claimed convergence rate, and the oracle complexity bound easily follows since each
iteration of the algorithm requires only O(1)queries topgb.
Remark 39.The efficiency guarantees given by Corollaries 37 and 38 are exactly the same as those
from [49], up to absolute constants.
F.2 Implicit Variance Reduction
Corollary 40. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
Let Algorithm 1 be applied to this problem with the oracle pg=pgband initial coefficient M0= 0.
Then, for the point sxNgenerated by the algorithm, we have
E[F(sxN)]−F∗≤cf(ν)Hf(ν)D1+ν
N1+ν
2+cpg(ν)Hmax(ν)D1+ν
(bN)1+ν
2+ 2σ∗Dr
6c1c4
bN,
where cf(ν):=(2c2c4)1+ν
2c1−ν
2
3
1+ν=O(1)andcpg(ν):=(24c4)1+ν
2(4
3)1−ν
2
1+ν=O(1). To reach
E[F(sxN)]−F∗≤ϵfor any ϵ >0, it suffices to make O 
[Hf(ν)
ϵ]2
1+νD2+1
b[Hpg(ν)
ϵ]2
1+νD2+σ2
∗D2
bϵ2
queries topgb.
32Proof. Denote for brevity FN:=E[F(sxN)]−F∗,Hf:=Hf(ν)andHmax:=Hmax(ν). Taking
into account Remark 35 and applying Theorem 7, we get, for any δf, δpg>0,
FN≤c2c4H2
1+ν
fD2
N1−ν
2(1 + ν)δf1−ν
1+ν
+12c4H2
1+νmaxD2
bN1−ν
2(1 + ν)δpg1−ν
1+ν
+c3δf+4
3δpg+σN,
where σN:= 2σ∗,bDq
6c1c4
N= 2σ∗Dq
6c1c4
bN. Minimizing the right-hand side in δfandδpg(using
Lemma 36 twice), we get
FN≤2
1 +νc2c4H2
1+ν
fD2
N1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)c3
1−ν1−ν
2
+2
1 +ν12c4H2
1+νmaxD2
bN1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)4
3
1−ν1−ν
2
+σN
=(2c2c4)1+ν
2c1−ν
2
3
1 +νHfD1+ν
N1+ν
2+(24c4)1+ν
2(4
3)1−ν
2
1 +νHmaxD1+ν
(bN)1+ν
2+σN.
This proves the claimed convergence rate, and the oracle complexity bound easily follows since each
iteration of the algorithm requires only 1query topgb.
Corollary 41. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
Let Algorithm 2 be applied to this problem with the oracle pg=pgb. Then, for any k≥1, we have
E[F(xk)]−F∗≤cf(ν)Hf(ν)D1+ν
k1+3ν
2+cpg(ν)Hmax(ν)D1+ν
(bk)1+ν
2+ 4σ∗Dr
2c1c4
bk,
where cf(ν):=(8c2c4)1+ν
2(2
3c3)1−ν
2
1+ν=O(1)andcpg(ν):=(48c1c4)1+ν
2(4
3)1−ν
2
1+ν=O(1). To reach
E[F(xk)]−F∗≤ϵfor any ϵ >0, it suffices to make O 
[Hf(ν)D1+ν
ϵ]2
1+3ν+1
b[Hmax(ν)
ϵ]2
1+νD2+
σ2
∗D2
bϵ2
queries topgb.
Proof. Letk≥1be arbitrary and denote for brevity Fk:=E[F(xk)]−F∗,Hf:=Hf(ν)and
Hmax:=Hmax(ν). Taking into account Remark 35 and applying Theorem 8, we get, for any
δf, δpg>0,
Fk≤4c2c4H2
1+ν
fD2
k(k+ 1)1−ν
2(1 + ν)δf1−ν
1+ν
+24c1c4H2
1+νmaxD2
bk1−ν
2(1 + ν)δpg1−ν
1+ν
+c3
3(k+ 2)δf+4
3δpg+σk,
where σk:= 4σ∗,bDq
2c1c4
k= 4σ∗Dq
2c1c4
bk. Minimizing the right-hand side in δfandδpg(using
Lemma 36 twice) and estimating1
3(k+ 2)≤2
3(k+ 1) , we obtain
Fk≤2
1 +ν4c2c4H2
1+ν
fD2
k(k+ 1)1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)2c3
3(k+ 1)
1−ν1−ν
2
+2
1 +ν24c1c4H2
1+νmaxD2
bk1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)4
3
1−ν1−ν
2
+σk
=(8c2c4)1+ν
2(2
3c3)1−ν
2
1 +νHfD1+ν
k1+ν
2(k+ 1)ν+(48c1c4)1+ν
2(4
3)1−ν
2
1 +νHmaxD1+ν
(bk)1+ν
2+σk.
This proves the claimed convergence rate, and the oracle complexity bound easily follows since each
iteration of the algorithm requires only O(1)queries topgb.
Remark 42.In the proof of Corollary 41, it was important that δfandδpgwere allowed to be two
separate constants. If we were not paying attention to such a separation and simply used the same δ
everywhere, we would end up with the much weaker rate of O(Hmax(ν)D1+ν
b1+ν
2kν)for the second term.
33F.3 Explicit Variance Reduction with SVRG
Corollary 43. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
LetUniSvrg (as defined by Algorithm 3) be applied to this problem with the stochastic oracle pg=pgb
and the full-gradient oracle sg=∇f. Then, for any t≥1,
E[F(˜xt)]−F∗≤cf(ν)Hf(ν)D1+ν
(2t)1+ν
2+cpg(ν)Hmax(ν)D1+ν
(b2t)1+ν
2,
where cf(ν):=[2(c2c4+1)]1+ν
2(2sc3)1−ν
2
1+ν=O(1),cpg(ν):=(96c1c4)1+ν
2(8
3)1−ν
2
1+ν=O(1),sc3:=
max{c3,1}. To get E[F(˜xt)]−F∗≤ϵ, it suffices to make O(Nν(ϵ))queries topgbandO(log+Nν(ϵ))
queries to ∇f, where Nν(ϵ):= [Hf(ν)
ϵ]2
1+νD2+1
b[Hmax(ν)
ϵ]2
1+νD2. Assuming that the complexity of
queryingsgbisnbtimes bigger than that of querying ∇f, we get the total stochastic-oracle complexity
ofO(Nν(ϵ) +nblog+Nν(ϵ)).
Proof. Lett≥1be arbitrary and denote for brevity Ft:=E[F(˜xt)]−F∗,Hf:=Hf(ν)and
Hmax:=Hmax(ν). Taking into account Remark 35 and applying Theorem 10, we get, for any
δf, δpg>0,
Ft≤(c2c4+ 1)H2
1+ν
fD2
2t1−ν
2(1 + ν)δf1−ν
1+ν
+48c1c4H2
1+νmaxD2
b2t1−ν
2(1 + ν)δpg1−ν
1+ν
+ 2sc3δf+8
3δpg.
Minimizing the right-hand side in δf, δpg(using Lemma 36 twice), we obtain
Ft≤2
1 +ν(c2c4+ 1)H2
1+ν
fD2
2t1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)2sc3
1−ν1−ν
2
+2
1 +ν48c1c4H2
1+νmaxD2
b2t1−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)8
3
1−ν1−ν
2
=cfHfD1+ν
(2t)1+ν
2+cpgHmaxD1+ν
(b2t)1+ν
2,
where cf:=[2(c2c4+1)]1+ν
2(2sc3)1−ν
2
1+νandcpg:=(96c1c4)1+ν
2(8
3)1−ν
2
1+ν. This proves the claimed conver-
gence rate.
Let us now estimate the oracle complexity. From the already proved convergence rate bound, we
see that Ft≤ϵonce 2t≥O(1)N(ϵ), where N(ϵ):= [Hf
ϵ]2
1+νD2+1
b[Hmax
ϵ]2
1+νD2. At the same
time, according to Theorem 10, to generate the corresponding ˜xt, the algorithm needs to make O(2t)
queries topgbandO(t)queries to ∇f. Combining these two facts together, we get the claimed
O(N(ϵ))queries topgbandO(log2N(ϵ) + 1) = O(log+N(ϵ))queries to ∇f.
Corollary 44. Consider problem (1)under the setting from Example 12 and also under Assumption 2.
LetUniFastSvrg (Algorithm 4) be applied to this problem with the stochastic oracle pg=pgb,
the full-gradient oracle sg=∇f, and the epoch length N≥9. Then, for any t≥2t0, where
t0:=⌈log2log3N⌉ −1 (≥0), it holds that
E[F(˜xt)]−F∗≤cf(ν)Hf(ν)D1+ν
N1+ν
2(t+ 1)1+3ν
2+cpg(ν)Hmax(ν)D1+ν
(bN)1+ν
2(t+ 1)1+3ν
2,
where cf(ν):=[72(c2c4+1
2)]1+ν
2sc1−ν
2
3
1+ν=O(1),cpg(ν):=(432c1c4)1+ν
2(5
3)1−ν
2
1+ν=O(1),sc3:=
max{c3,1}. To get E[F(˜xt)]−F∗≤ϵ, it suffices to make O(NTν(ϵ))queries topgbandO(Tν(ϵ))
queries to ∇f, where Tν(ϵ):= [Hf(ν)D1+ν
N1+ν
2ϵ]2
1+3ν+[Hmax(ν)D1+ν
(bN)1+ν
2ϵ]2
1+3ν+log2log3N. Assuming that
the complexity of querying sgbisnbtimes bigger than that of querying ∇fand choosing N= Θ( nb),
we get the total stochastic-oracle complexity of O 
[nν
bHf(ν)D1+ν
ϵ]2
1+3ν+ [nν
bHmax(ν)D1+ν
b(1+ν)/2ϵ]2
1+3ν+
nblog log nb
34Proof. Lett≥2t0be arbitrary, Ft:=E[F(˜xt)]−F∗,Hf:=Hf(ν),Hmax:=Hmax(ν). Taking
into account Remark 35 and applying Theorem 11, we get, for any δf, δpg>0,
Ft≤9(c2c4+1
2)H2
1+ν
fD2
N(t−t0+ 1)21−ν
2(1 + ν)δf1−ν
1+ν
+54c1c4H2
1+νmaxD2
bN(t−t0+ 1)21−ν
2(1 + ν)δpg1−ν
1+ν
+ (c3t+ 1)δf+5
3tδpg.
Since t≥2t0, we can estimate t−t0+ 1 =1
2t+1
2t−t0+ 1≥1
2(t+ 1) , which gives us
Ft≤36(c2c4+1
2)H2
1+ν
fD2
N(t+ 1)21−ν
2(1 + ν)δf1−ν
1+ν
+216c1c4H2
1+νmaxD2
bN(t+ 1)21−ν
2(1 + ν)δpg1−ν
1+ν
+sc3(t+ 1)δf+5
3(t+ 1)δpg.
Minimizing the right-hand side in δf, δpg(using Lemma 36 twice), we obtain
Ft≤2
1 +ν36(c2c4+1
2)H2
1+ν
fD2
N(t+ 1)21−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)sc3(t+ 1)
1−ν1−ν
2
+2
1 +ν216c1c4H2
1+νmaxD2
bN(t+ 1)21−ν
2(1 + ν)1−ν
1+ν1+ν
2(1 +ν)5
3(t+ 1)
1−ν1−ν
2
=cfHfD1+ν
N1+ν
2(t+ 1)1+3ν
2+cpgHmaxD1+ν
(bN)1+ν
2(t+ 1)1+3ν
2,
where cf:=[72(c2c4+1
2)]1+ν
2sc1−ν
2
3
1+νandcpg:=(432c1c4)1+ν
2(5
3)1−ν
2
1+ν. This proves the claimed conver-
gence rate.
Let us now estimate the number of oracle queries. In view of the above convergence rate bound,
we have Ft≤ϵonce t≥T(ϵ):=T1(ϵ) + 2 t0=O 
T1(ϵ) + log log N
, where T1(ϵ):=
[HfD1+ν
N(1+ν)/2ϵ]2
1+3ν+ [HmaxD1+ν
(bN)(1+ν)/2ϵ]2
1+3ν=T2(ϵ)
N1+ν
1+3ν, where T2(ϵ):= [HfD1+ν
ϵ]2
1+3ν+ [HmaxD1+ν
b(1+ν)/2ϵ]2
1+3ν
does not depend on N. Combining this with Theorem 11 saying that, to generate the correspond-
ing˜xt, the algorithm needs to make O(Nt)queries topgbandO(t)queries to ∇f, we get the claimed
O(NT(ϵ))queries topgbandO(T(ϵ))queries to ∇f.
Assuming now that the complexity of querying ∇fisnbtimes bigger than that of querying pgb, we
get the total stochastic-oracle complexity of O 
(N+nb)T(ϵ)
=O 
(N+nb)T2(ϵ)
N(1+ν)/(1+3ν)+
log log N
. Ignoring the doubly-logarithmic term, we get the expression of the form (N+nb)1
Nq=
N1−q+nb
Nqwithq:=1+ν
1+3ν∈[0,1], whose minimal value is achieved at N= Θ( nb). Substituting
this value into our complexity bound, we get the stochastic-oracle complexity of O 
nb(T2(ϵ)
n(1+ν)/(1+3ν)
b+
log log nb)
=O 
n2ν
1+3ν
bT2(ϵ) +nblog log nb
.
G Additional Discussion of Related Work
Inexact Oracle and Approximate Smoothness. Devolder, Glineur, and Nesterov [15] introduced
the notion of the inexact first-order oracle and analyzed the behaviour of several first-order methods
for smooth convex optimization using such an oracle. Although their work was motivated by the
desire to present the general definition of an inexact oracle covering many different applications,
it was also observed that this oracle model is suitable for studying weakly smooth problems. This
insight was later used in [45] to develop universal gradient methods for Hölder smooth problems. First
stochastic gradient methods for approximately smooth functions with inexact oracle were proposed
in [13]. These algorithms however are not adaptive and require the knowledge of problem-dependent
constants. For more details on the subject, see [14].
350 20000 40000 60000
number of stochastic oracle calls 1013
1010
107
104
101
f(x)-f
mushrooms
0 5000 10000 15000 20000
number of stochastic oracle calls 1013
1010
107
104
101
f(x)-f
w8a
0 20000 40000 60000
number of stochastic oracle calls 105
104
103
102
101
100f(x)-f
leu
0 25000 50000 75000 100000
number of stochastic oracle calls 107
105
103
101
f(x)-f
colon-cancer
0 20000 40000
number of stochastic oracle calls 106
105
104
103
102
101
f(x)-f
0 100000 200000
number of stochastic oracle calls 106
105
104
103
102
101
f(x)-f
0 50000 100000 150000 200000
number of stochastic oracle calls 106
105
104
103
102
101
100f(x)-f
0 100000 200000 300000
number of stochastic oracle calls 106
104
102
100f(x)-f
UniSgd (ours) UniFastSgd (ours) AdaSVRG UniSvrg (ours) AdaVRAG AdaVRAE UniFastSvrg (ours)Figure 3: Comparison of various methods on the logistic regression problem with real-world data.
Parameter-Free Methods. Parameter-free algorithms originating from the literature on online
learning [9, 10, 26, 40, 47, 55] is another popular type of adaptive methods. They are usually endowed
with mechanisms helping achieving efficiency bounds that are almost insensitive (typically, with
logarithmic dependency) to the error of estimating certain problem parameters, such as the diameter
of the feasible set [6, 11, 25, 31, 41].
Variance Reduction. Variance reduction techniques encompass a set of strategies that enhance
the convergence speed of SGD when multiple passes are possible over the training dataset. Various
researchers simultaneously introduced methods to reduce variance around the same period [27, 38,
50, 52, 58, 60]. The consideration of mini-batching in the context of these methods is documented
in [3], while, in [20], it is shown that the convergence rate is influenced by both the average and the
maximum smoothness of individual components. For further details, see [21] and the references
therein.
Sometimes, it is even not necessary to use an explicit variance reduction mechanism. SGD may
converge fast in the so-called over-parameterized regime, or when the stochastic noise is small at the
optimal solution [8, 35, 37, 43, 44, 51]. In this work, we call this effect implicit variance reduction.
Such a situation is also considered in [19, 54] and, more recently, Woodworth and Srebro [59]
proposed an accelerated SGD algorithm for this setting, under the assumption that the smoothness
and noise constants are known.
H Additional Experiments
H.1 Logistic Regression with Real-World Data
In this section, we present experiments on the logistic regression problem :
f∗= min
∥x∥≤Rn
f(x):=1
nnX
i=1log(1 + e−bi⟨ai,x⟩)o
,
where ai∈Rdandbi∈ {− 1,1}are features and labels taken from diverse real-world datasets from
LIBSVM [7]: mushrooms ( d≪n), w8a ( d≪n), leu ( d≫n) and colon-cancer ( d≫n). The
dataset leu is quite special because it satisfies the so-called interpolation condition, meaning that the
variance at the optimum is zero. We fix R= 1and use the mini-batch size of b= 32 for the first two
datasets and b= 1for the last two.
Figure 3 shows the results of our experiments. The solid lines and the shaded area for each method
represent, respectively, the mean and the region between the minimum and the maximum values after
three independent runs of the algorithm. We see that, on the leu dataset, UniSgd andUniFastSgd
converge as fast as the best non-accelerated and accelerated SVRG methods, respectively, which
360 50000 100000 150000 200000 250000
number of stochastic oracle calls 103104105f(x)-f
q = 1
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 104105106107f(x)-f
q = 1.3
0 20000 40000 60000
number of stochastic oracle calls 105106107108109f(x)-f
q = 1.6
0 5000 10000 15000
number of stochastic oracle calls 101
1011031051071091011f(x)-f
q = 2
0 50000 100000 150000 200000 250000
number of stochastic oracle calls 104105106Step size
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 103104Step size
0 20000 40000 60000
number of stochastic oracle calls 102Step size
0 5000 10000 15000
number of stochastic oracle calls 100
4×101
6×101
2×100Step size
UniSgd-AdaGrad UniSgd-Other UniSvrg-AdaGrad UniSvrg-Other
0 50000 100000 150000 200000 250000
number of stochastic oracle calls 100101102103104105f(x)-f
q = 1
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 100101102103104105106107f(x)-f
q = 1.3
0 20000 40000 60000
number of stochastic oracle calls 102104106108f(x)-f
q = 1.6
0 5000 10000 15000
number of stochastic oracle calls 106
103
1001031061091012f(x)-f
q = 2
0 50000 100000 150000 200000 250000
number of stochastic oracle calls 101
100101102103104105106Step size
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 101
100101102103104105Step size
0 20000 40000 60000
number of stochastic oracle calls 102
101
100101102103Step size
0 5000 10000 15000
number of stochastic oracle calls 102
101
100Step size
UniFastSgd-AdaGrad UniFastSgd-Other UniFastSvrg-AdaGrad UniFastSvrg-OtherFigure 4: Comparison of our methods for different stepsize update rules on the polyhedron feasibility
problem.
confirms our theory on implicit variance reduction. Otherwise, these two SGD methods are typically
much slower than the SVRG algorithms. Our UniSvrg method performs consistently better than
AdaSVRG across all the datasets. Overall, all adaptive accelerated SVRG methods demonstrate
comparable performance for solving these smooth problems.
H.2 Comparison between Stepsize Update Rules
In this section, we compare the AdaGrad stepsize rule (3)with the other rule (4)forUniSgd
(Algorithm 1), UniFastSgd (Algorithm 2), UniSvrg (Algorithm 3), and UniFastSvrg (Algorithm 4).
We consider the polyhedron feasibility and logistic regression problems under the same setups as in
Section 8 and Appendix H.1.
The results are shown in Figs. 4 and 5, where we plot the function residual and the stepsize (inverse
ofM) against stochastic oracle calls. We see that the two stepsize rules work very similarly across
all test cases, which was not evident from the theory alone.
370 10000 20000 30000 40000 50000
number of stochastic oracle calls 1014
1012
1010
108
106
104
102
100f(x)-f
q = 1
0 20000 40000 60000 80000
number of stochastic oracle calls 1014
1012
1010
108
106
104
102
100f(x)-f
q = 1.3
0 20000 40000 60000
number of stochastic oracle calls 105
104
103
102
101
100101f(x)-f
q = 1.6
0 20000 40000 60000 80000 100000
number of stochastic oracle calls 107
106
105
104
103
102
101
100f(x)-f
q = 2
0 10000 20000 30000 40000 50000
number of stochastic oracle calls 101
100101Step size
0 20000 40000 60000 80000
number of stochastic oracle calls 101
100101Step size
0 20000 40000 60000
number of stochastic oracle calls 102
101
Step size
0 20000 40000 60000 80000 100000
number of stochastic oracle calls 102
101
Step size
UniSgd-AdaGrad UniSgd-Other UniSvrg-AdaGrad UniSvrg-Other
0 10000 20000 30000 40000 50000
number of stochastic oracle calls 106
105
104
103
102
101
f(x)-f
q = 1
0 50000 100000 150000 200000 250000
number of stochastic oracle calls 106
105
104
103
102
101
f(x)-f
q = 1.3
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 106
105
104
103
102
101
100f(x)-f
q = 1.6
050000 100000 150000 200000 250000 300000
number of stochastic oracle calls 107
106
105
104
103
102
101
100f(x)-f
q = 2
0 10000 20000 30000 40000 50000
number of stochastic oracle calls 105
104
103
102
101
100101Step size
0 50000 100000 150000 200000 250000
number of stochastic oracle calls 106
105
104
103
102
101
100101Step size
0 25000 50000 75000 100000 125000 150000
number of stochastic oracle calls 104
103
102
Step size
050000 100000 150000 200000 250000 300000
number of stochastic oracle calls 107
106
105
104
103
102
101
Step size
UniFastSgd-AdaGrad UniFastSgd-Other UniFastSvrg-AdaGrad UniFastSvrg-OtherFigure 5: Comparison of our methods for different stepsize update rules on the logistic regression
problem with real-world data.
NeurIPS Paper Checklist
1.Claims
Question: Do the main claims made in the abstract and introduction accurately reflect the
paper’s contributions and scope?
Answer: [Yes]
Justification: Each claim is justified by a theorem.
Guidelines:
•The answer NA means that the abstract and introduction do not include the claims
made in the paper.
•The abstract and/or introduction should clearly state the claims made, including the
contributions made in the paper and important assumptions and limitations. A No or
NA answer to this question will not be perceived well by the reviewers.
•The claims made should match theoretical and experimental results, and reflect how
much the results can be expected to generalize to other settings.
•It is fine to include aspirational goals as motivation as long as it is clear that these goals
are not attained by the paper.
382.Limitations
Question: Does the paper discuss the limitations of the work performed by the authors?
Answer: [Yes]
Justification: Each theorem is followed by a discussion. For the numerical experiments in
Section 8 we carefully discuss the performance of the method. Additional experiments are
presented in Appendix H.
Guidelines:
•The answer NA means that the paper has no limitation while the answer No means that
the paper has limitations, but those are not discussed in the paper.
• The authors are encouraged to create a separate “Limitations” section in their paper.
•The paper should point out any strong assumptions and how robust the results are to
violations of these assumptions (e.g., independence assumptions, noiseless settings,
model well-specification, asymptotic approximations only holding locally). The authors
should reflect on how these assumptions might be violated in practice and what the
implications would be.
•The authors should reflect on the scope of the claims made, e.g., if the approach was
only tested on a few datasets or with a few runs. In general, empirical results often
depend on implicit assumptions, which should be articulated.
•The authors should reflect on the factors that influence the performance of the approach.
For example, a facial recognition algorithm may perform poorly when image resolution
is low or images are taken in low lighting. Or a speech-to-text system might not be
used reliably to provide closed captions for online lectures because it fails to handle
technical jargon.
•The authors should discuss the computational efficiency of the proposed algorithms
and how they scale with dataset size.
•If applicable, the authors should discuss possible limitations of their approach to
address problems of privacy and fairness.
•While the authors might fear that complete honesty about limitations might be used by
reviewers as grounds for rejection, a worse outcome might be that reviewers discover
limitations that aren’t acknowledged in the paper. The authors should use their best
judgment and recognize that individual actions in favor of transparency play an impor-
tant role in developing norms that preserve the integrity of the community. Reviewers
will be specifically instructed to not penalize honesty concerning limitations.
3.Theory Assumptions and Proofs
Question: For each theoretical result, does the paper provide the full set of assumptions and
a complete (and correct) proof?
Answer: [Yes]
Justification: Yes. This is a theory paper. All proofs are provided in the appendix.
Guidelines:
• The answer NA means that the paper does not include theoretical results.
•All the theorems, formulas, and proofs in the paper should be numbered and cross-
referenced.
•All assumptions should be clearly stated or referenced in the statement of any theorems.
•The proofs can either appear in the main paper or the supplemental material, but if
they appear in the supplemental material, the authors are encouraged to provide a short
proof sketch to provide intuition.
•Inversely, any informal proof provided in the core of the paper should be complemented
by formal proofs provided in appendix or supplemental material.
• Theorems and Lemmas that the proof relies upon should be properly referenced.
4.Experimental Result Reproducibility
Question: Does the paper fully disclose all the information needed to reproduce the main ex-
perimental results of the paper to the extent that it affects the main claims and/or conclusions
of the paper (regardless of whether the code and data are provided or not)?
39Answer: [Yes]
Justification: We provide the pseudocode and the hyperparameter settings for all algorithms.
Guidelines:
• The answer NA means that the paper does not include experiments.
•If the paper includes experiments, a No answer to this question will not be perceived
well by the reviewers: Making the paper reproducible is important, regardless of
whether the code and data are provided or not.
•If the contribution is a dataset and/or model, the authors should describe the steps taken
to make their results reproducible or verifiable.
•Depending on the contribution, reproducibility can be accomplished in various ways.
For example, if the contribution is a novel architecture, describing the architecture fully
might suffice, or if the contribution is a specific model and empirical evaluation, it may
be necessary to either make it possible for others to replicate the model with the same
dataset, or provide access to the model. In general. releasing code and data is often
one good way to accomplish this, but reproducibility can also be provided via detailed
instructions for how to replicate the results, access to a hosted model (e.g., in the case
of a large language model), releasing of a model checkpoint, or other means that are
appropriate to the research performed.
•While NeurIPS does not require releasing code, the conference does require all submis-
sions to provide some reasonable avenue for reproducibility, which may depend on the
nature of the contribution. For example
(a)If the contribution is primarily a new algorithm, the paper should make it clear how
to reproduce that algorithm.
(b)If the contribution is primarily a new model architecture, the paper should describe
the architecture clearly and fully.
(c)If the contribution is a new model (e.g., a large language model), then there should
either be a way to access this model for reproducing the results or a way to reproduce
the model (e.g., with an open-source dataset or instructions for how to construct
the dataset).
(d)We recognize that reproducibility may be tricky in some cases, in which case
authors are welcome to describe the particular way they provide for reproducibility.
In the case of closed-source models, it may be that access to the model is limited in
some way (e.g., to registered users), but it should be possible for other researchers
to have some path to reproducing or verifying the results.
5.Open access to data and code
Question: Does the paper provide open access to the data and code, with sufficient instruc-
tions to faithfully reproduce the main experimental results, as described in supplemental
material?
Answer: [Yes]
Justification: We provide the GitHub link to our code.
Guidelines:
• The answer NA means that paper does not include experiments requiring code.
•Please see the NeurIPS code and data submission guidelines ( https://nips.cc/
public/guides/CodeSubmissionPolicy ) for more details.
•While we encourage the release of code and data, we understand that this might not be
possible, so “No” is an acceptable answer. Papers cannot be rejected simply for not
including code, unless this is central to the contribution (e.g., for a new open-source
benchmark).
•The instructions should contain the exact command and environment needed to run to
reproduce the results. See the NeurIPS code and data submission guidelines ( https:
//nips.cc/public/guides/CodeSubmissionPolicy ) for more details.
•The authors should provide instructions on data access and preparation, including how
to access the raw data, preprocessed data, intermediate data, and generated data, etc.
40•The authors should provide scripts to reproduce all experimental results for the new
proposed method and baselines. If only a subset of experiments are reproducible, they
should state which ones are omitted from the script and why.
•At submission time, to preserve anonymity, the authors should release anonymized
versions (if applicable).
•Providing as much information as possible in supplemental material (appended to the
paper) is recommended, but including URLs to data and code is permitted.
6.Experimental Setting/Details
Question: Does the paper specify all the training and test details (e.g., data splits, hyper-
parameters, how they were chosen, type of optimizer, etc.) necessary to understand the
results?
Answer: [Yes]
Justification: Everything is carefully described in Section 8 and Appendix H.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The experimental setting should be presented in the core of the paper to a level of detail
that is necessary to appreciate the results and make sense of them.
•The full details can be provided either with the code, in appendix, or as supplemental
material.
7.Experiment Statistical Significance
Question: Does the paper report error bars suitably and correctly defined or other appropriate
information about the statistical significance of the experiments?
Answer: [No]
Justification: Different runs of the same algorithm for the same hyperparameter settings
result in almost the same performance in our experiments. Therefore, we plot only one
curve for each method, focusing more on highlighting the (more significant) differences
between various methods.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The authors should answer "Yes" if the results are accompanied by error bars, confi-
dence intervals, or statistical significance tests, at least for the experiments that support
the main claims of the paper.
•The factors of variability that the error bars are capturing should be clearly stated (for
example, train/test split, initialization, random drawing of some parameter, or overall
run with given experimental conditions).
•The method for calculating the error bars should be explained (closed form formula,
call to a library function, bootstrap, etc.)
• The assumptions made should be given (e.g., Normally distributed errors).
•It should be clear whether the error bar is the standard deviation or the standard error
of the mean.
•It is OK to report 1-sigma error bars, but one should state it. The authors should
preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis
of Normality of errors is not verified.
•For asymmetric distributions, the authors should be careful not to show in tables or
figures symmetric error bars that would yield results that are out of range (e.g. negative
error rates).
•If error bars are reported in tables or plots, The authors should explain in the text how
they were calculated and reference the corresponding figures or tables in the text.
8.Experiments Compute Resources
Question: For each experiment, does the paper provide sufficient information on the com-
puter resources (type of compute workers, memory, time of execution) needed to reproduce
the experiments?
41Answer: [No]
Justification: This is not important for the results we present since the algorithms are
compared in terms of oracle calls and not the actual time of execution. All experiments are
run on a standard MacBook Pro laptop and do not require a lot of computational power.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The paper should indicate the type of compute workers CPU or GPU, internal cluster,
or cloud provider, including relevant memory and storage.
•The paper should provide the amount of compute required for each of the individual
experimental runs as well as estimate the total compute.
•The paper should disclose whether the full research project required more compute
than the experiments reported in the paper (e.g., preliminary or failed experiments that
didn’t make it into the paper).
9.Code Of Ethics
Question: Does the research conducted in the paper conform, in every respect, with the
NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines ?
Answer: [Yes]
Justification: This is a theory paper.
Guidelines:
•The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.
•If the authors answer No, they should explain the special circumstances that require a
deviation from the Code of Ethics.
•The authors should make sure to preserve anonymity (e.g., if there is a special consid-
eration due to laws or regulations in their jurisdiction).
10.Broader Impacts
Question: Does the paper discuss both potential positive societal impacts and negative
societal impacts of the work performed?
Answer: [No]
Justification: This is a theory paper. We do not expect immediate societal impact.
Guidelines:
• The answer NA means that there is no societal impact of the work performed.
•If the authors answer NA or No, they should explain why their work has no societal
impact or why the paper does not address societal impact.
•Examples of negative societal impacts include potential malicious or unintended uses
(e.g., disinformation, generating fake profiles, surveillance), fairness considerations
(e.g., deployment of technologies that could make decisions that unfairly impact specific
groups), privacy considerations, and security considerations.
•The conference expects that many papers will be foundational research and not tied
to particular applications, let alone deployments. However, if there is a direct path to
any negative applications, the authors should point it out. For example, it is legitimate
to point out that an improvement in the quality of generative models could be used to
generate deepfakes for disinformation. On the other hand, it is not needed to point out
that a generic algorithm for optimizing neural networks could enable people to train
models that generate Deepfakes faster.
•The authors should consider possible harms that could arise when the technology is
being used as intended and functioning correctly, harms that could arise when the
technology is being used as intended but gives incorrect results, and harms following
from (intentional or unintentional) misuse of the technology.
•If there are negative societal impacts, the authors could also discuss possible mitigation
strategies (e.g., gated release of models, providing defenses in addition to attacks,
mechanisms for monitoring misuse, mechanisms to monitor how a system learns from
feedback over time, improving the efficiency and accessibility of ML).
4211.Safeguards
Question: Does the paper describe safeguards that have been put in place for responsible
release of data or models that have a high risk for misuse (e.g., pretrained language models,
image generators, or scraped datasets)?
Answer: [NA]
Justification: Does not apply.
Guidelines:
• The answer NA means that the paper poses no such risks.
•Released models that have a high risk for misuse or dual-use should be released with
necessary safeguards to allow for controlled use of the model, for example by requiring
that users adhere to usage guidelines or restrictions to access the model or implementing
safety filters.
•Datasets that have been scraped from the Internet could pose safety risks. The authors
should describe how they avoided releasing unsafe images.
•We recognize that providing effective safeguards is challenging, and many papers do
not require this, but we encourage authors to take this into account and make a best
faith effort.
12.Licenses for existing assets
Question: Are the creators or original owners of assets (e.g., code, data, models), used in
the paper, properly credited and are the license and terms of use explicitly mentioned and
properly respected?
Answer: [Yes]
Justification: We cite the LIBSVM dataset.
Guidelines:
• The answer NA means that the paper does not use existing assets.
• The authors should cite the original paper that produced the code package or dataset.
•The authors should state which version of the asset is used and, if possible, include a
URL.
• The name of the license (e.g., CC-BY 4.0) should be included for each asset.
•For scraped data from a particular source (e.g., website), the copyright and terms of
service of that source should be provided.
•If assets are released, the license, copyright information, and terms of use in the
package should be provided. For popular datasets, paperswithcode.com/datasets
has curated licenses for some datasets. Their licensing guide can help determine the
license of a dataset.
•For existing datasets that are re-packaged, both the original license and the license of
the derived asset (if it has changed) should be provided.
•If this information is not available online, the authors are encouraged to reach out to
the asset’s creators.
13.New Assets
Question: Are new assets introduced in the paper well documented and is the documentation
provided alongside the assets?
Answer: [NA]
Justification: We do not release any new assets in this paper.
Guidelines:
• The answer NA means that the paper does not release new assets.
•Researchers should communicate the details of the dataset/code/model as part of their
submissions via structured templates. This includes details about training, license,
limitations, etc.
•The paper should discuss whether and how consent was obtained from people whose
asset is used.
43•At submission time, remember to anonymize your assets (if applicable). You can either
create an anonymized URL or include an anonymized zip file.
14.Crowdsourcing and Research with Human Subjects
Question: For crowdsourcing experiments and research with human subjects, does the paper
include the full text of instructions given to participants and screenshots, if applicable, as
well as details about compensation (if any)?
Answer: [NA]
Justification: No such experiments or research.
Guidelines:
•The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
•Including this information in the supplemental material is fine, but if the main contribu-
tion of the paper involves human subjects, then as much detail as possible should be
included in the main paper.
•According to the NeurIPS Code of Ethics, workers involved in data collection, curation,
or other labor should be paid at least the minimum wage in the country of the data
collector.
15.Institutional Review Board (IRB) Approvals or Equivalent for Research with Human
Subjects
Question: Does the paper describe potential risks incurred by study participants, whether
such risks were disclosed to the subjects, and whether Institutional Review Board (IRB)
approvals (or an equivalent approval/review based on the requirements of your country or
institution) were obtained?
Answer: [NA]
Justification: Does not apply.
Guidelines:
•The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
•Depending on the country in which research is conducted, IRB approval (or equivalent)
may be required for any human subjects research. If you obtained IRB approval, you
should clearly state this in the paper.
•We recognize that the procedures for this may vary significantly between institutions
and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the
guidelines for their institution.
•For initial submissions, do not include any information that would break anonymity (if
applicable), such as the institution conducting the review.
44