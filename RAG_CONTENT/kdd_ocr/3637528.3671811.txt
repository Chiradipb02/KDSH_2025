An Efficient Local Search Algorithm for Large GD Advertising
Inventory Allocation with Multilinear Constraints
Xiang He
hexiang@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
School of Computer Science and
Technology, University of Chinese
Academy of Sciences
Beijing, ChinaWuyang Mao
wuyang.mwy@alibaba-inc.com
Alibaba Group
Beijing, ChinaZhenghang Xu
zhenghangxu97@gmail.com
Key Laboratory of Symbolic
Computation and Knowledge
Engineering Ministry of Education,
Jilin University
Changchun, China
Yuanzhe Gu
guyuanzhe1996@gmail.com
Alibaba Group
Hangzhou, ChinaYundu Huang
yundu.hyd@alibaba-inc.com
Alibaba Group
Beijing, ChinaZhonglin Zu
zhonglin.zuzl@alibaba-inc.com
Alibaba Group
Hangzhou, China
Liang Wang
liangbo.wl@alibaba-inc.com
Alibaba Group
Beijing, ChinaMengyu Zhao
zhaomy@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
School of Computer Science and
Technology, University of Chinese
Academy of Sciences
Beijing, ChinaMengchuan Zou∗
zoumc@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
ABSTRACT
The Guaranteed Delivery (GD) advertising is a crucial component
of the online advertising industry, and the allocation of inventory
in GD advertising is an important procedure that influences di-
rectly the ability of the publisher to fulfill the requirements and
increase its revenues. Nowadays, as the requirements of advertisers
become more and more diverse and fine-grained, the focus ratio
requirement, which states that the portion of allocated impres-
sions of a designated contract on focus media among all possible
media should be greater than another contract, often appears in
∗Corresponding Author
This work is licensed under a Creative Commons Attribution-
NonCommercial International 4.0 License.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08.
https://doi.org/10.1145/3637528.3671811business scenarios. However, taking these requirements into ac-
count brings hardness for the GD advertising inventory allocation
as the focus ratio requirements involve non-convex multilinear
constraints. Existing methods which rely on the convex properties
are not suitable for processing this problem, while mathematical
programming or constraint-based heuristic solvers are unable to
produce high-quality solutions within the time limit. Therefore,
we propose a local search framework to address this challenge. It
incorporates four new operators designed for handling multilinear
constraints and a two-mode algorithmic architecture. Experimental
results demonstrate that our algorithm is able to compute high-
quality allocations with better business metrics compared to the
state-of-the-art mathematical programming or constraint based
heuristic solvers. Moreover, our algorithm is able to handle the
general multilinear constraints and we hope it could be used to
solve other problems in GD advertising with similar requirements.
CCS CONCEPTS
•Information systems →Computational advertising.
 
1040
KDD ’24, August 25–29, 2024, Barcelona, Spain Xiang He et al.
KEYWORDS
Guaranteed Delivery Advertising, Inventory Allocation, Focus Ratio
Requirements, Integer Multilinear Programming, Local Search
ACM Reference Format:
Xiang He, Wuyang Mao, Zhenghang Xu, Yuanzhe Gu, Yundu Huang, Zhonglin
Zu, Liang Wang, Mengyu Zhao, and Mengchuan Zou. 2024. An Efficient
Local Search Algorithm for Large GD Advertising Inventory Allocation
with Multilinear Constraints. In Proceedings of the 30th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining (KDD ’24), August
25–29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 10 pages. https:
//doi.org/10.1145/3637528.3671811
1 INTRODUCTION
Guaranteed delivery advertising is a crucial component of the on-
line advertising industry, which assumes a pivotal role in online
commerce marketing and promotion for brands. The allocation
of impression inventory to contracts stays as a key component of
this process. As depicted in Figure 1, in typical GD procedures, the
contract is signed months before the advertising campaign, the
advertiser places an order on the publisher’s commercial platform,
while the latter needs to return available advertising results within
a few minutes. To fulfill the agreement, publishers must possess
the ability to make plans for the inventory of ad impressions and
allocate them to different advertisers adhering to various objectives
and constraints. The core technological capabilities of the publisher
significantly influence the sales of advertising and its ability to meet
contractual obligations. The failure to fulfill these contracts or low-
quality allocations could lead to subpar marketing performance for
advertisers and a decrease in revenue for publishers.
In previous advertising inventory allocation studies, the prob-
lems only contain linear constraints, and are formulated as linear
programs [ 10]. Although mathematical programming solvers are
widely-used tools for solving general linear programs, in ad allo-
cation scenarios, the inputs are usually of large-scale and those
solvers typically cannot provide solutions within a few minutes,
which is the timeframe required for commercial needs. On the other
hand, in real applications, it is usually not necessary to achieve the
optimal solution to the problem, but obtain an approximate optimal
solution [ 35]. Consequently, inexact methods such as algorithms
leveraging duality and KKT conditions, were employed to rapidly
address the problem, including algorithms like NLS, RAP [ 26,35].
However, these algorithms rely on the linearity or convexity of the
problem’s constraints, thereby they are only able to handle linear
or convex constraints.
With the growing expansion of commercial demands, more and
more fine-grained requirements are raised, some types of them state
nonlinear relationships and are indeed non-convex constraints in
the mathematical form. Assume an advertiser has two products, a
skin essence and an earphone, and designates a beauty app as the
focus media of skin essence compared to earphone. The advertiser
intends to make the impressions of the skin essence be more focused
on the beauty app than the earphone. As in Figure 2, if the advertiser
demand 1000 impressions for the skin essence and 300 for the
earphone, and if for the skin essence we allocate 300 on the beauty
app and 700 on other media, and for the earphone we allocate 200
on the beauty app and 100 on other media. Then although the
Figure 1: The system architecture for GD advertising.
amount of allocations of skin essence is more than the earphone on
the beauty app (300 v.s. 200), the portion of the impressions of the
skin essence allocated on the beauty app is much smaller than that
of the earphone (300/1000 v.s. 200/300). This allocation is regarded
as irrational and is required to be avoided by the advertiser, as
the advertiser hope the portion of allocation on the beauty app
among all allocations of the skin essence be larger than that of
the earphone, to make his impressions be more concentratedly
allocated on suitable media.
Figure 2: An allocation plan violates advertiser’s requirement
We call this type of requirements as focus ratio requirements,
since they involve the ratio between the amount of allocated im-
pressions of a product on focus media and all possible media, which
is referred to as the focus ratio. Specifically, those requirements are
addressing to the priority relationship of focus ratio between two
contracts (products) and could be raised from the estimations on the
CTR of different products on different media [ 11]. Moreover, the sit-
uation in practical business scenarios is usually more complex than
in the above example, where there may be multiple requirements
from different advertisers and between different products, also the
focus media could be a set of media rather than a specific media. In
addition, similar requirements also have appeared on other perfor-
mance indicators. These requirements are naturally formulated as
multilinear constraints which are non-convex. We pay attention to
the focus ratio requirements, as they are highly demanded and con-
firmed requirements in our business scenarios. We hope to study it
as a starting point for similar multilinear requirements.
As the efficiency or capability of existing solvers and methods are
not enough to handle these constraints in business scenarios. This
 
1041An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD ’24, August 25–29, 2024, Barcelona, Spain
necessitates the exploration of novel technologies and algorithms
to solve these problems effectively. In this paper, we employ a
lightweight local search algorithm technique to efficiently address
GD advertising inventory allocation problems that involve non-
convex multilinear constraints.
1.1 Related works
The guaranteed delivery advertising represents a challenging prob-
lem in the advertising industry and has inspired many research
developments. In general, the guaranteed delivery advertising con-
tains selling and serving phases. The selling phase decides the
allocation of inventory to advertisers (offline allocation) and the
serving phase executes the allocation plan to users in real-time
(online allocation).
In recent years, research on contract advertising mainly focus
on the serving phase (implemented by a serving system, as in Fig-
ure 1), which serves ads in real-time when an actual user request
arrives by determining which of the thousands of eligible contracts
should be displayed for each opportunity in split-second latency.
An important class of algorithms of serving process are online
algorithms, such as algorithms based on stochastic arrival mod-
els [3,16,25,27]. A collection of algorithms is proposed based on
impressions [2, 5, 12, 15, 20], some of which leverage duality such
as HWM, SHALE [ 6,10] to rapidly finished advertising allocation.
In comparison to the serving phase, there has been relatively
little research on the inventory allocation problem in the selling
phase (by a selling system, as in Figure 1). Recently, a Lagrangian
dual algorithm has been introduced for the selling stage, facilitating
the rapid resolution of large-scale inventory allocation problems
with linear constraints [ 35]. Some works considered fairness in ad
allocations and the quality of advertisements [ 11,14] but didn’t take
into account the specific contract requirements from the advertisers
which contain multilinear constraints, as focus ratio requirement.
Meanwhile, there is limited research on problems with non-convex
constraints and mathematical programming or constraint-based
heuristic solvers such as Gurobi [19], SCIP [1] and Yuck [8], often
have relatively slow convergence speeds and in general cannot
meet the demands of commercial advertising problems.
Local search algorithms play an important role in solving NP-
hard combinatorial problems [ 17,18,21,22,24,29–32,34]. These
algorithms apply modifications to the current solution iteratively
to quickly find high-quality solutions to large-scale problems. How-
ever, rare works study the local search for combinatorial problems
with multilinear constraints, the only work we found is the local
search for SMT on Multilinear Real Arithmetic [ 23], which is a
verification problem without an optimization objective. To the best
of our knowledge, there hasn’t been any local search algorithm
dedicated to solving integer multilinear optimization problem.
1.2 Our Contributions
In this work, we propose a novel approach to address the GD ad-
vertising inventory allocation problem, including the following:
(1) We introduce the inventory allocation problem with the focus
ratio requirement for the very first time and we build its mathe-
matical formulation as an integer programming problem involving
multilinear constraints.(2) We design a lightweight local search solver, LS-IMP, to solve
the problem. We propose four new neighborhood operators to
handle the multilinear constraints and two switching modes to
quickly find approximately optimal solutions to the problem. Our
solver can easily handle general multilinear constraints in business
scenarios, including but not limited to the focus ratio constraint.
(3) We perform experiments on GD inventory allocation with our
solver, on the real online advertising application data. Experimental
results demonstrate that our solver computes allocations that fulfill
the requirements on more instances and with better quality on
business metrics, outperforming mathematical programming or
constraint-based heuristic solvers.
2 PROBLEM MODELING
2.1 GD Advertising Inventory Allocation with
Focus Ratio Requirements
The GD advertising inventory allocation problem is to compute the
maximum possible impression for the new contract while ensuring
the impression amounts satisfy the constraints imposed by the
publisher, and the demand of advertisers.
Figure 3: Bipartite graph model of GD advertising allocation
The problem can be described using the bipartite graph as shown
in Figure 3. On the left side, supply nodes set 𝐴correspond to
impressions of basic dimensions (city ×media×operating system).
On the right side, demand nodes set 𝐵correspond to the contracts
in the selling system. Where demand node 0represents the new
contract while the other demand nodes 𝑏∈𝐵,𝑏≥1represent
existing contracts. Decision variables 𝑥𝑎𝑏represent the amount of
impression allocated from supply 𝑎to demand𝑏. The problem aims
to decide𝑥𝑎𝑏to maximize the impression allocated for the new
contract and satisfy three types of constraints:
(1) Supply constraint: the total allocation amount for each supply
node should not exceed its supply capacity;
(2) Demand constraints: the amount of impressions allocated to
a demand node should not be less than its demand;
(3) Focus ratio constraints: the focus ratio of a contract must
be not less than another contract on focus media. This constraint
 
1042KDD ’24, August 25–29, 2024, Barcelona, Spain Xiang He et al.
involves pairs of two contracts 𝑟and𝑠of the same advertiser and
a selection of a specified media set 𝐾𝑟𝑠, representing the focus
media of𝑟compared to 𝑠. Then the focus ratio of contracts 𝑟and
𝑠on the supply set 𝐾𝑟𝑠are required to fit the advertiser’s priority
requirement: the focus ratio of contract 𝑟on𝐾𝑟𝑠should be greater
than that of contract 𝑠.
We use an adjacency matrix 𝑴=[𝑀𝑎𝑏]𝑎∈𝐴,𝑏∈𝐵,𝑀𝑎𝑏∈{0,1}
to denote connections between supply nodes and demand nodes,
𝑀𝑎𝑏=1if there exists a connection between supply node 𝑎and
demand node 𝑏.
The multilinear programming formulation of our problem could
be described as the following:
max∑︁
𝑎∈𝐴𝑀𝑎0𝑥𝑎0 (1)
s.t.∑︁
𝑏∈𝐵𝑀𝑎𝑏𝑥𝑎𝑏≤capacity(𝑎),∀𝑎∈𝐴 (2)
∑︁
𝑎∈𝐴𝑀𝑎𝑏𝑥𝑎𝑏≥demand(𝑏),∀𝑏∈𝐵,𝑏≠0 (3)
Í
𝑘∈𝐾𝑟𝑠𝑀𝑘𝑟𝑥𝑘𝑟Í
𝑎∈𝐴𝑀𝑎𝑟𝑥𝑎𝑟≥Í
𝑘∈𝐾𝑟𝑠𝑀𝑘𝑠𝑥𝑘𝑠Í
𝑎∈𝐴𝑀𝑎𝑠𝑥𝑎𝑠,∀𝑟,𝑠∈𝐵 (4)
𝑥𝑎𝑏∈N,∀𝑎∈𝐴,𝑏∈𝐵 (5)
Here the objective function is the allocated impressions for the
new contract, and the Supply constraints, Demand constraints and
Focus ratio constraints are formulated as Formula (2) to (4). We
then show that our problem fits the general IMP form.
2.2 Integer Multilinear Programming
The general form of an integer multilinear programming (IMP)
problem is as follows:
𝑀𝑖𝑛𝑖𝑚𝑖𝑧𝑒 𝒄𝑇𝒙
𝑠𝑢𝑏𝑗𝑒𝑐𝑡𝑡𝑜 𝐹(𝒙)≤𝒃
𝒙𝑙≤𝒙≤𝒙𝑢
𝒙∈Z𝑛(6)
where 𝒃∈R𝑚,𝒄∈R𝑛,𝒙𝑙∈(Z∪−∞)𝑛,𝒙𝑢∈(Z∪+∞)𝑛are
inputs and 𝒙the decision variable. 𝐹(𝒙)is multilinear meaning the
highest exponent of any variable is 1[13].
We denote the 𝑖-th constraint in the constraint system 𝐹(𝒙)≤𝒃
by𝑐𝑜𝑛𝑖:𝐹𝑖(𝒙)≤𝑏𝑖. The variables’ bounds are denoted as 𝒙𝑙≤
𝒙≤𝒙𝑢and we denote 𝑏𝑑(𝑥𝑡)=[𝑥𝑙
𝑡,𝑥𝑢
𝑡]. Note that in our problem,
𝑥𝑙=0and𝑥𝑢is the capacity for its corresponding supply node.
Given a variable 𝑥𝑡, every constraint could be written as:
𝑐𝑜𝑛𝑖=𝐻(𝑖,𝑥𝑡)·𝑥𝑡+𝐼(𝑖,𝑥𝑡)≤𝑏𝑖 (7)
where𝐻(𝑖,𝑥𝑡)is the coefficient polynomial of 𝑥𝑡in𝑐𝑜𝑛𝑖, and𝐼(𝑖,𝑥𝑡)
is the intercept polynomial of 𝑥𝑡in𝑐𝑜𝑛𝑖. Intuitively, if we regard
only𝑥𝑡as a variable, then 𝐻(𝑖,𝑥𝑡)is the coefficient of 𝑥𝑡and the
𝐼(𝑖,𝑥𝑡)are monomials that do not contain 𝑥𝑡.
It is easy to see our problem in Formula (1) to (5) could be
transformed into the general IMP form since linear constraints
are multilinear and the focus ratio constraints are equivalent toÍ
𝑘∈𝐾𝑟𝑠𝑀𝑘𝑟𝑥𝑘𝑟·Í
𝑎∈𝐴𝑀𝑎𝑠𝑥𝑎𝑠−Í
𝑎∈𝐴𝑀𝑎𝑟𝑥𝑎𝑟·Í
𝑘∈𝐾𝑟𝑠𝑀𝑘𝑠𝑥𝑘𝑠≥0
that is multilinear.In the following, we consider our problem in the form of For-
mula (6). A complete assignment (referred to as “assignment" for
short)𝛼for an IMP instance 𝑄is a mapping that assigns to each
variable an integer, and 𝛼(𝑥𝑟)denotes the value of 𝑥𝑟under𝛼. An
assignment 𝛼satisfies the constraint 𝑐𝑜𝑛𝑖if𝑐𝑜𝑛𝑖(𝛼)≤𝑏𝑖, other-
wise the constraint is violated. An assignment 𝛼is feasible if and
only if it satisfies all constraints in 𝑄. The value of the objective
function of𝛼is denoted as 𝑜𝑏𝑗(𝛼). Also, we denote 𝛼(𝐻(𝑖,𝑥𝑡))the
value of coefficient polynomial of 𝑥𝑡in𝑐𝑜𝑛𝑖with assignment 𝛼, and
𝛼(𝐼(𝑖,𝑥𝑡))for the intercept polynomial respectively.
3 LS-IMP: OUR LOCAL SEARCH ALGORITHM
We introduce each component and the routine of our algorithm. The
key innovations enabling our algorithm to address GD advertising
inventory allocation with multilinear constraints, consisting of four
new operators in the local search process. Moreover, we design a
two-mode architecture of our algorithm to help the algorithm find
high-quality solutions.
3.1 Operators Treating Multilinear Constraints
In the local search algorithm, an operator defines how to modify
variables to generate new assignments, when an operator is in-
stantiated with a variable, we obtain an operation. A local search
algorithm progressively takes operations to generate new assign-
ments and tracks the best assignment obtained.
We present four new operators for general integer multilinear
programs, including three single-variable operators and one pair-
variable operator. They are designed to handle unsatisfied con-
straints or optimize the objective function which will be used in
different modes in our algorithm.
3.1.1 Multilinear Critical Move. Our multilinear critical move oper-
ator considers modifying variables in violated constraints towards
making them satisfied. The multilinear critical move modifies the
variable’s value to the boundary value that makes the literal true.
We define the multilinear critical move operator:
Definition 3.1. The multilinear critical move operator 𝑚𝑐(𝑥𝑘,𝑐𝑜𝑛𝑖
,𝛼), takes an assignment 𝛼and assigns an integer variable 𝑥𝑘to the
threshold value 𝑣𝑘making violated constraint 𝑐𝑜𝑛𝑖satisfied and
keeping the global bound of 𝑣𝑘satisfied, where 𝑐𝑜𝑛𝑖is a violated
constraint containing 𝑥𝑘.
The multilinear critical move could be constructed in the follow-
ing way: given a violated multilinear constraint 𝑐𝑜𝑛𝑖, variable𝑥𝑡∈
𝑐𝑜𝑛𝑖, we know𝑐𝑜𝑛𝑖=𝐻(𝑖,𝑥𝑡)·𝑥𝑡+𝐼(𝑖,𝑥𝑡)≤𝑏𝑖by Formula (7). Un-
der an assignment 𝛼, we denote Δ=𝛼(𝐼(𝑖,𝑥𝑡))+𝛼(𝐻(𝑖,𝑥𝑡))·𝛼(𝑥𝑡)−𝑏𝑖
𝛼(𝐻(𝑖,𝑥𝑡)),
a𝑚𝑐(𝑥𝑡,𝑐𝑜𝑛𝑖,𝛼)operator for 𝑥𝑡is:
•if𝛼(𝐻(𝑖,𝑥𝑡))<0and𝛼(𝑥𝑡)+|⌊Δ⌋|∈𝑏𝑑(𝑥𝑡):𝑚𝑐(𝑥𝑡,𝑐𝑜𝑛𝑖,𝛼)
increases𝛼(𝑥𝑡)by|⌊Δ⌋|.
•if𝛼(𝐻(𝑖,𝑥𝑡))>0and𝛼(𝑥𝑖)−|⌈Δ⌉|∈𝑏𝑑(𝑥𝑡):𝑚𝑐(𝑥𝑡,𝑐𝑜𝑛𝑖,𝛼)
decreases𝛼(𝑥𝑡)by|⌈Δ⌉|.
•otherwise:𝛼stay unchanged.
Example 3.2. Given two violated constraints: 𝑐𝑜𝑛1=(𝑥1−𝑥2≤
−2),𝑐𝑜𝑛 2=(𝑥1𝑥2−𝑥3𝑥4≤−2). All variables have a lower bound of
0 and the current assignment is 𝛼={𝑥1=0,𝑥2=0,𝑥3=1,𝑥4=1}.
There exist three multilinear critical move operations: 𝑚𝑐(𝑥2,𝑥1−
 
1043An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD ’24, August 25–29, 2024, Barcelona, Spain
𝑥2≤−2,𝛼),𝑚𝑐(𝑥3,𝑥1𝑥2−𝑥3𝑥4≤−2,𝛼)and𝑚𝑐(𝑥4,𝑥1𝑥2−𝑥3𝑥4≤
−2,𝛼), referring to assigning 𝑥2to2,𝑥3to2, and𝑥4to2respectively.
3.1.2 Bound Move Operator. The bound move operator considers
optimizing the objective function when all constraints are satisfied.
The basic idea of reducing the value of the objective function is
to change the values of the variables within it. Let 𝐽be the set of
variables that appear in the objective function, i.e. 𝐽={𝑥𝑡|𝑐𝑡≠
0,∀𝑡}, where𝑐𝑡is the coefficient of 𝑥𝑡in𝒄𝑇𝒙. The idea of the bound
move operator is to move the variable towards its upper bound or
lower bound according to its coefficient in the objective function,
which will result in the most rapid decrease in the objective function.
We design the bound move operator denoted as 𝑏𝑚(𝑥,𝛼)as follows:
•if𝑐𝑡<0, then𝑏𝑚(𝑥𝑡,𝛼)assign𝑥𝑡to its upper bound.
•if𝑐𝑡>0, then𝑏𝑚(𝑥𝑡,𝛼)assign𝑥𝑡to its lower bound.
3.1.3 Reduce Move Operator. Similar to the role of bound move,
reduce move also aims to optimize the objective function. In some
cases, setting a variable to its global bound may lead to more con-
straints being violated. For variables within the objective function,
bound move pays attention to their bounds, while reduce move fo-
cuses on the constraints they are subject to. For a variable 𝑥𝑡∈𝐽and
a satisfied constraint 𝑐𝑜𝑛𝑖that contains 𝑥𝑡, we design reduce move
operator to both maintain the satisfied state of 𝑐𝑜𝑛𝑖and achieve
the reduction in the value of the objective function.
Definition 3.3. The reduce move operator, represented as 𝑟𝑑(𝑥𝑡,
𝑐𝑜𝑛𝑖,𝛼), assigns an integer variable 𝑥∈𝐽to a threshold value which
both make the constraint 𝑐𝑜𝑛𝑖remains satisfied while achieving
the maximum reduction in the value of objective function without
violating𝑥𝑡’s upper or lower bounds.
Given a variable 𝑥𝑡∈𝐽and its associated satisfied constraint
𝑐𝑜𝑛𝑖,𝑐𝑜𝑛𝑖=𝐻(𝑖,𝑥𝑡)·𝑥𝑡+𝐼(𝑖,𝑥𝑡)≤𝑏𝑖. Under an assignment 𝛼, we
denote Δ=𝑏𝑖−𝛼(𝐼(𝑖,𝑥𝑡))−𝛼(𝐻(𝑖,𝑥𝑡))·𝛼(𝑥𝑡)
𝛼(𝐻(𝑖,𝑥𝑡)), a𝑟𝑑(𝑥𝑡,𝑐𝑜𝑛𝑖,𝛼)opera-
tor for𝑥𝑖is:
•𝑐𝑡<0,𝛼(𝐻(𝑖,𝑥𝑡))>0,𝛼(𝑥𝑡)+|⌊Δ⌋|∈𝑏𝑑(𝑥𝑡): increase
𝛼(𝑥𝑡)by|⌈Δ⌉|, which leads to the most significant decrease
in the value of the objective function.
•𝑐𝑡>0,𝛼(𝐻(𝑖,𝑥𝑡))<0,𝛼(𝑥𝑡)−|⌈Δ⌉|∈𝑏𝑑(𝑥𝑡): decrease
𝛼(𝑥𝑡)by|⌈Δ⌉|, which leads to the most significant decrease
in the value of the objective function.
•otherwise:𝛼stay unchanged.
Example 3.4. Consider an instance 𝑚𝑖𝑛 :−𝑥1−𝑥2, s.t.𝑐𝑜𝑛1=
(𝑥2+𝑥4≤2),𝑐𝑜𝑛 2=(𝑥1𝑥3−𝑥3𝑥4≤2). Given the current assign-
ment is𝛼={𝑥1=1,𝑥2=1,𝑥3=1,𝑥4=0}. There exist three reduce
move operations: 𝑟𝑑(𝑥1,𝑥1𝑥2−𝑥3𝑥4≤2,𝛼),𝑟𝑑(𝑥2,𝑥2+𝑥4≤2,𝛼)
referring to assigning 𝑥1to2and𝑥2to2respectively.
3.1.4 Propel Move Operator. Regardless of whether it’s a bound
move or reduce move, the operator is linked to variables in the
objective function. However, certain variables might not directly
influence the objective function if they don’t appear in it. Yet, if
these variables share constraints with those within the objective
function, they can impact the variable range by altering their values,
subsequently affecting the objective function.
Example 3.5. Consider an instance 𝑚𝑖𝑛 :−𝑥1−𝑥5, s.t.𝑐𝑜𝑛1=
(𝑥2+𝑥4≤2),𝑐𝑜𝑛 2=(𝑥1𝑥2−𝑥3𝑥4≤2),𝑐𝑜𝑛3=(𝑥3+𝑥5≤2).Given the current assignment 𝛼={𝑥1=1,𝑥2=1,𝑥3=1,𝑥4=
1,𝑥5=0}, for𝑥1in𝑐𝑜𝑛2, to maintain the satisfiability of constraint
𝑐𝑜𝑛2, the range of values for 𝑥1is the interval[−∞,2+𝑥3·𝑥4
𝑥2]. If
other variables are held constant while only changing the value of
𝑥1, then the range of values for 𝑥1is[−∞,3]. However, if 𝑥3is also
simultaneously moved from 1 to 2, constraint 𝑐𝑜𝑛3which contains
𝑥3is still satisfied, while the range of values for 𝑥1will be[−∞,4]
to satisfy𝑐𝑜𝑛2, thereby increasing the magnitude of the ascent in
𝑥1and decrease the objective.
Next, we intend to formally define and search for a pair of vari-
ables, similar to 𝑥1and𝑥3in the example above, along with the
corresponding operator.
Definition 3.6. Valid auxiliary constraint. Given an assignment
𝛼and a variable 𝑥𝑡, we say constraint 𝑐𝑜𝑛𝑖is a valid auxiliary
constraint for 𝑥𝑡if𝛼(𝐻(𝑖,𝑥𝑡))·𝑐𝑡<0.
The𝛼(𝐻(𝑖,𝑥𝑡))·𝑐𝑡<0indicates that the auxiliary constraint
limits𝑥𝑡to move in the direction of decreasing the objective. We
define the valid range of𝑥𝑡in constraint 𝑐𝑜𝑛𝑖the range that 𝑥𝑡
can move and keeps 𝑐𝑜𝑛𝑖satisfied. For multilinear constraints, this
range is an interval. Now we are to identify the variables that will
make it possible to change the valid range of 𝑥𝑡in the auxiliary
constraint.
Definition 3.7. Valid auxiliary variable. Given an assignment 𝛼,
for any𝑥𝑡∈𝐽, a variable𝑥𝑢,𝑢≠𝑡is a valid auxiliary variable for
𝑥𝑡, if𝑥𝑢satisfy following conditions: (1) 𝑥𝑢∉𝐽(2)∃𝑐𝑜𝑛𝑖that𝑐𝑜𝑛𝑖
is a valid auxiliary constraint for 𝑥𝑡, both𝑥𝑡and𝑥𝑢appear in𝑐𝑜𝑛𝑖.
Intuitively, since 𝑥𝑢and𝑥𝑡are within the same constraint, the
value of𝑥𝑢might affect the valid range of 𝑥𝑡in𝑐𝑜𝑛𝑖. Now we try to
find the value of 𝑥𝑢that enlarges the valid range of 𝑥𝑡in𝑐𝑜𝑛𝑖. Since
the valid range of 𝑥𝑡is an interval, its endpoints are monotone with
the change of value of 𝑥𝑢. Therefore, we desire the alteration of 𝑥𝑢
to be as large as possible. For this reason, we define the value by
which𝑥𝑢should change as follows:
Definition 3.8. Auxiliary value. Given an assignment 𝛼, for any
𝑥𝑢and its associated 𝑐𝑜𝑛𝑗s.t.𝑥𝑢∈𝑐𝑜𝑛𝑗, we define the auxiliary
value of𝑥𝑢given𝑐𝑜𝑛𝑗, denote as𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢), to be the value that
making𝑐𝑜𝑛𝑗satisfied and as tight as possible: Precisely, let Δ=
𝑏𝑗−𝛼(𝐼(𝑗,𝑥𝑢))−𝛼(𝐻(𝑗,𝑥𝑢))·𝛼(𝑥𝑢)
𝛼(𝐻(𝑗,𝑥𝑢)), then𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)is computed as
follows:
•if𝛼(𝐻(𝑗,𝑥𝑢))>0:𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)=𝛼(𝑥𝑢)+|⌊Δ⌋|.
•if𝛼(𝐻(𝑗,𝑥𝑢))<0:𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)=𝛼(𝑥𝑢)−|⌈Δ⌉|.
The way we define the auxiliary value is from the fact that
tightening the constraints 𝑐𝑜𝑛𝑗can maximize the range of change
of𝑥𝑢. Now, we will proceed to calculate whether altering 𝑥𝑢can
result in a broader range of movement for 𝑥𝑡that decreases the
objective function.
Definition 3.9. Valid propel pair. Given an assignment 𝛼, an or-
dered pair of variables (𝑥𝑡,𝑥𝑢),𝑡≠𝑢is a valid propel pair if
(1)∃𝑐𝑜𝑛𝑖s.t.𝑥𝑡,𝑥𝑢∈𝑐𝑜𝑛𝑖,𝛼(𝐻(𝑖,𝑥𝑡))·𝑐𝑡<0.
(2)∃𝑐𝑜𝑛𝑗s.t.𝑥𝑡∉𝑐𝑜𝑛𝑗,𝑥𝑢∈𝑐𝑜𝑛𝑗,𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)∈𝑏𝑑(𝑥𝑢)and
fixing𝑥𝑢to𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)will not change the sign of 𝐻𝛼(𝑖,𝑥𝑡).
(3)𝑜𝑏𝑗(𝑟𝑑(𝑐𝑜𝑛𝑖,𝑥𝑡,𝛼𝑎𝑢𝑥))<𝑜𝑏𝑗(𝑟𝑑(𝑐𝑜𝑛𝑖,𝑥𝑡,𝛼)), where𝛼𝑎𝑢𝑥is
updated by fixing 𝑥𝑢to𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢)
 
1044KDD ’24, August 25–29, 2024, Barcelona, Spain Xiang He et al.
Based on the above ideas, the propel move operator is defined
as follows:
Definition 3.10. Propel move operator. Given an assignment 𝛼, a
propel move operator 𝑝𝑚(𝑐𝑜𝑛𝑖,𝑐𝑜𝑛𝑗,𝑥𝑡,𝑥𝑢,𝛼)takes a valid propel
pair(𝑥𝑡,𝑥𝑢)with the associated constraint 𝑐𝑜𝑛𝑖,𝑐𝑜𝑛𝑗as in the
definition of valid propel pair, the propel move operator fixing the
values of𝑥𝑡,𝑥𝑢as following:
(1) fix the value of 𝑥𝑢to𝑡𝑣𝛼(𝑐𝑜𝑛𝑗,𝑥𝑢), and get a new auxiliary
assignment 𝛼𝑎𝑢𝑥.
(2) fix the value of 𝑥𝑡by taking a𝑟𝑑(𝑐𝑜𝑛𝑖,𝑥𝑡,𝛼𝑎𝑢𝑥)operation.
Recall the Example 3.5, there is a propel move operator which
is calculated as: compute 𝑡𝑣𝛼(𝑐𝑜𝑛3,𝑥3), which leads to 𝑥3change
from 1 to 2 and get a new auxiliary assignment 𝛼𝑎𝑢𝑥; compute
𝑟𝑑(𝑐𝑜𝑛2,𝑥1,𝛼𝑎𝑢𝑥)which leads to 𝑥1change from 1 to 4.
3.2 Weighting Scheme and Score Function
3.2.1 Weighting Scheme. Weighting scheme can guide the search
in a promising direction. It associates an additional property called
weight (which is an integer number) to constraints and objective
function dynamically adjusts them during the search. The weight
of constraints and the objective function are dynamically adjusted
during the search and are used to compute the score functions.
We denote𝑤(𝑐𝑜𝑛𝑖)for weight of constraint 𝑖and𝑤(𝑜𝑏𝑗)for the
weight of objective function. 𝑤(𝑐𝑜𝑛𝑖)and𝑤(𝑜𝑏𝑗)are initialized
with a weight of 1 and are dynamically updated as follows:
•for violated constraint 𝑐𝑜𝑛𝑖,𝑤(𝑐𝑜𝑛𝑖):=𝑤(𝑐𝑜𝑛𝑖)+1;
•if𝑜𝑏𝑗(𝛼)>𝑜𝑏𝑗∗and𝑤(𝑜𝑏𝑗)<𝜁, then𝑤(𝑜𝑏𝑗):=𝑤(𝑜𝑏𝑗)+1,
where𝑜𝑏𝑗∗is objective value under best found solution, 𝜁
limits the maximum value that objective function weight
can get.
3.2.2 Scoring Function. The scoring function is also an important
component of local search algorithms. During the process of local
search, scoring function is employed to compare various operations.
Given the weights of constraints and the objective function, we
design the scoring function as follows:
for the constraint score, consider an operation 𝑜𝑝changing an
assignment 𝛼to𝛼′, if this operation makes a constraint 𝑐𝑜𝑛𝑖from
satisfied to violated, it incurs a score of −𝑤(𝑐𝑜𝑛𝑖). Conversely, if it
makes𝑐𝑜𝑛𝑖from violated to satisfied, it yields a score of 𝑤(𝑐𝑜𝑛𝑖).
Definition 3.11. The constraint score of an operator 𝑜𝑝, denoted
by𝑐𝑠𝑐𝑜𝑟𝑒(𝑜𝑝)is the sum of scores of all constraints caused by
applying𝑜𝑝.
For the objective score, if an operation reduces the value of the
objective function, it will be rewarded with 𝑤(𝑜𝑏𝑗). Otherwise, it
will incur a penalty of 𝑤(𝑜𝑏𝑗).
Definition 3.12. The objective score of an operator is denoted
by𝑜𝑠𝑐𝑜𝑟𝑒(𝑜𝑝).𝑜𝑠𝑐𝑜𝑟𝑒(𝑜𝑝)=𝑤(𝑜𝑏𝑗)(or−𝑤(𝑜𝑏𝑗)), if op make the
value of objective function decrease(or increase),
For this problem, we consider that satisfying the constraints and
reducing the objective function are equally important. Therefore,
the score function is defined as follows:
𝑠𝑐𝑜𝑟𝑒(𝑜𝑝)=𝑐𝑠𝑐𝑜𝑟𝑒(𝑜𝑝)+𝑜𝑠𝑐𝑜𝑟𝑒(𝑜𝑝) (8)
Figure 4: Two-modes switching algorithm
Algorithm 1: Infeasible Mode
1while∃violated constraints do
2 if∃decreasing multilinear critical move in violated
constraints then
3𝑜𝑝=a decreasing multilinear critical move with the
greatest score via BMS;
4 else
5 update weights by Weighting Scheme;
6𝑐𝑜𝑛=a random violated constraint;
7𝑜𝑝=a decreasing multilinear critical move with the
greatest score in 𝑐𝑜𝑛via BMS;
8 perform op to modify 𝛼;
An operation is decreasing if its score is greater than 0. It implies
that performing this operation will lead the search in a promising
direction. If there is no decreasing operation, it indicates that the
algorithm is stuck in a local optimum, and the weighting scheme is
required to be activated.
3.3 Two-Mode Local Search Algorithm
Our algorithm primarily consists of two aims: 1.satisfy all violated
constraints 2. optimize the objective function. Therefore, we design
an algorithm with a two-mode structure: the Infeasible mode and the
Feasible mode, each mode associates with its appropriate operators.
In the Infeasible mode, the algorithm focuses on making violated
constraints satisfied, while in the Feasible mode, the algorithm
emphasizes minimizing the objective function.
The routine of our algorithm is described in Algorithm 3. First,
the best assignment 𝛼∗and current assignment 𝛼are initialized
(Line 1). All variables are initialized to their lower bound of 0. Then,
the algorithm iteratively modifies 𝛼by performing operations on
integer variables. Once variable values change, the satisfaction
status of all constraints might change. As depicted in Figure 4, the
algorithm dynamically switches between two modes as iterations
advance, guided by the satisfaction status of the constraints. At the
end of the time limit, if no feasible solution is found, output NA;
otherwise, output the best solution found.
If there exist violated constraints, then our algorithm enters
Infeasible mode. As described in Algorithm 1, the algorithm first
tries to find decreasing multilinear critical move operation with the
greatest score via BMS heuristic [ 9] (Line 2–3). Specifically, the BMS
heuristic samples 𝑡operations ( 𝑡is a parameter), and selects the
decreasing one with the greatest score. If no decreasing operation
 
1045An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD ’24, August 25–29, 2024, Barcelona, Spain
Algorithm 2: Feasible Mode
1while∀constraints is satisfied do
2 if∃decreasing bound move then
3𝑜𝑝:=a decreasing bound move with the greatest
score picked by BMS;
4 else if∃decreasing reduce move then
5𝑜𝑝:=a decreasing reduce move with the greatest
score picked by BMS;
6 else if∃decreasing propel move then
7𝑜𝑝:=a decreasing propel move with the greatest
score picked by BMS;
8 else
9 update weights by Weighting Scheme;
10𝑜𝑝=a random simple move;
11 perform op to modify 𝛼;
Algorithm 3: Local Search Algorithm
Input: GD advertising instance 𝐹, cutoff time cutoff
Output: A feasible assignment 𝛼∗of𝐹and𝑜𝑏𝑗(𝛼∗)or NA
1𝛼∗:=∅,𝛼:=an initial complete assignment;
2while time not exceeds 𝑐𝑢𝑡𝑡𝑜𝑓𝑓 do
3 if𝛼is feasible and 𝑜𝑏𝑗(𝛼)<𝑜𝑏𝑗∗then
4𝛼∗:=𝛼, 𝑜𝑏𝑗∗:=𝑜𝑏𝑗(𝛼);
5 if∃violated constraints then
6 Enter Infeasible Mode and perform corresponding
operation;
7 else
8 Enter Feasible Mode and perform corresponding
operations;
9if𝛼∗is feasible then return (𝑜𝑏𝑗∗, 𝛼∗);
10else return NA;
is found, it indicates that the algorithm may reach a local optimum.
The algorithm further escapes from the local optimum in the same
way as WalkSAT-family SAT solvers [ 4,7,30], that is: 1. updates
the weights of the constraints based on the weighting scheme. 2.
randomly selects one of the violated constraints and chooses a
multilinear critical move operation with the greatest score via BMS.
Otherwise, our algorithm enters Feasible mode. The algorithm
in Feasible mode is described in Algorithm 2. In each iteration, the
algorithm first tries to find a decreasing bound move operation
with the greatest score via BMS heuristic (Line 2–3). If there exists
no such operation, then we consider the decreasing reduce move
operations and select the one with the greatest score via BMS (Line
4–5). If it fails to find any decreasing reduce move, then it continues
to search the neighbourhood of propel move operation (Line 6-7).
If there still exists no decreasing operation. the algorithm further
escapes from the local optimum by updating the weights (Line 9)
and selects a random variable 𝑥𝑡∈𝐽performing a simple move: if
𝑐𝑡<0, then increase 𝑥𝑡by1, otherwise decrease 𝑥𝑡by1(Line 10).4 EXPERIMENTS
In this section, we evaluate our solver LS-IMP with real GD inven-
tory allocation of a company (temporally anonymous for double-
blind review). Experimental results indicate that our algorithm is
efficient and effective on inventory contract allocation problem.
Implementation and Setup: LS-IMP is programmed in C++,
compiled by g++ with ’-O3’ option. There are 2 parameters in the
solver:𝑡the number of samples for the BMS heuristic, 𝜁for the
Upper Limit of objective function weight. The parameters are tuned
according to our preliminary experiments and suggestions from
the literature and are set as follows: 𝑡=100.𝜁=100.
All experiments are conducted on a server with Intel Xeon Plat-
inum 8153 2.00GHz and 2048G RAM under the system CentOS
7.7.1908. The source code and the detailed results of the experiment
are in the repository1.
Competitors: We compare our solver to two mathematical pro-
gramming solvers, Gurobi 10.0.0 (2022) and SCIP 8.0.1 (2021), that
are the best commercial and best open-source solver in the well-
known mathematical solver rankings [ 28]. In addition to mathemat-
ical programming solvers, we also compare the constraint-based
heuristic solver Yuck, which is the champion of the local search
track in the 2022 and 2023 MiniZinc challenge, a representative
competition of constraint programming solvers [ 33]. We use both
the exact and heuristic versions of Gurobi denoted as Exact and
Heur. SCIP and Yuck is employed with the default parameters.
Datasets: The datasets for experiments come from real GD ad-
vertising inventory allocation of Alibaba company. 5 datasets are
generated by sampling and aggregating real online request data
covering different time periods including regular days and holidays
to encompass a comprehensive range of business scenarios. We
take uniformly random samplings among all populations.
The datasets are shown in Table 1. The table shows the instance
count (#ins), supply node range (Supply), demand node range (De-
mand), and newly introduced multilinear constraint range (ML
Constraint) for each dataset. The datasets used are in the reposi-
tory2.
Table 1: Datasets description
Dataset #ins Supply Demand ML Constraint
D1 200 50∼100 40∼50 1000∼1500
D2 200 50∼100 20∼30 1000∼1500
D3 200 150∼200 100∼150 1000∼1500
D4 200 200∼250 300∼400 1000∼1500
D5 200 700∼800 40∼50 1000∼1500
4.1 Evaluation Metrics
There are 5 metrics in this subsection to be compared:
Inventory utilization rate: denoted as #UR. We denote the total
inventory level at all supply nodes as 𝑆all, and the total demand
quantity from all orders is denoted as 𝐷all. #UR is calculated as:Í|𝐴|
𝑎=1𝑀𝑎0𝑥𝑎0/(𝑆all−𝐷all). A higher #UR leads to a greater number
of advertisements sold and subsequently results in better revenue.
1https://github.com/LS-IMP/-ls-imp
2https://mega.nz/file/sOlk0byD#ahjRxeZJJjKF6IKK0q-r0nqlT8R7ylg8-k24xitSX2k
 
1046KDD ’24, August 25–29, 2024, Barcelona, Spain Xiang He et al.
Ideal inventory fulfilment rate: denoted as #FR. The ideal allo-
cation quantity is denoted as 𝑂𝑏𝑗𝐼𝑑𝑒𝑎𝑙 , which equals to the value of
the objective function setting all variables in the objective function
to their upper bounds. #FR is calculated as : (Í|𝐴|
𝑎=1𝑀𝑎0𝑥𝑎0)/𝑂𝑏𝑗𝐼𝑑𝑒𝑎𝑙 .
#FR represents a narrower gap between inventory and optimal in-
ventory, which means selling as many ads as feasible while still
meeting contractual obligations. #FR is desired to be as close to
100% as possible in order to fulfil customer contracts.
Winning solution: denoted as #win, the number of instances
where a solver finds the best solution among all solutions output
by tested solvers. This measures the ability of the algorithm to find
a high-quality allocation in terms of the objective value.
Feasible solution: denoted as #feas, the number of instances
where a solver can find a feasible solution within this time limit.
This measures the number of instances in which a solver finds an
allocation plan that fulfills all requirements.
Solving time: the runtime comparison between LS-IMP and
competitor solvers if both solvers can find a solution with the same
value of the objective function.
4.2 Result Analysis
#UR and #FR analysis: We compared the average #UR and #FR
for each set of instances. The result is shown in Table 2. A selling
instance of GD advertising inventory allocation typically requires a
solving time within 60 seconds in a business scenario. The effective-
ness of SCIP and Yuck in addressing this problem is comparatively
lower, as seen by the lower #UR and #FR metrics observed in the
business solution time.
We have included a comparison between both the heuristic and
exact versions of Gurobi and LS-IMP in Figure 5. Gurobi lags behind
LS-IMP in terms of both the #UR and #FR within the 60-second
business-solving time 60s. To validate and compare the capabilities
of our solver, experiments are also conducted with a solving time
extended to 300 and 1000 seconds, surpassing the business-defined
limit. The experiments reveal that even though Gurobi shows an
increase in the #UR and #FR, LS-IMP is still the most competitive
algorithm. Moreover, the results from the 300-second and 1000-
second solving time show no obvious improvement in either #UR
and #FR compared to the 60-second results with LS-IMP. It sug-
gests that LS-IMP has essentially converged within the 60-second
timeframe, demonstrating the effectiveness of our algorithm.
/uni00000019/uni00000013/uni00000056 /uni00000016/uni00000013/uni00000013/uni00000056 /uni00000014/uni00000013/uni00000013/uni00000013/uni00000056
/uni0000002c/uni00000051/uni00000059/uni00000048/uni00000051/uni00000057/uni00000052/uni00000055/uni0000005c/uni00000003/uni00000058/uni00000057/uni0000004c/uni0000004f/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000055/uni00000044/uni00000057/uni00000048/uni00000013/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000015/uni00000013/uni00000015/uni00000018/uni00000016/uni00000013/uni00000033/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni00000003/uni0000000b/uni00000008/uni0000000c
/uni00000013/uni00000011/uni00000017/uni00000019/uni00000011/uni00000013/uni00000014/uni00000016/uni00000011/uni00000019
/uni00000014/uni00000011/uni00000017/uni00000015/uni00000011/uni0000001a/uni00000019/uni00000011/uni00000015/uni00000014/uni00000019/uni00000011/uni00000017/uni00000014/uni0000001a/uni00000011/uni00000018 /uni00000014/uni0000001a/uni00000011/uni00000018/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033
(a) #UR
/uni00000019/uni00000013/uni00000056 /uni00000016/uni00000013/uni00000013/uni00000056 /uni00000014/uni00000013/uni00000013/uni00000013/uni00000056
/uni0000002c/uni00000051/uni00000059/uni00000048/uni00000051/uni00000057/uni00000052/uni00000055/uni0000005c/uni00000003/uni00000049/uni00000058/uni0000004f/uni00000049/uni0000004c/uni0000004f/uni0000004f/uni00000050/uni00000048/uni00000051/uni00000057/uni00000003/uni00000055/uni00000044/uni00000057/uni00000048/uni00000013/uni00000014/uni00000013/uni00000015/uni00000013/uni00000016/uni00000013/uni00000017/uni00000013/uni00000018/uni00000013/uni00000019/uni00000013/uni0000001a/uni00000013/uni0000001b/uni00000013/uni0000001c/uni00000013/uni00000014/uni00000013/uni00000013/uni00000033/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni00000003/uni0000000b/uni00000008/uni0000000c
/uni00000014/uni00000011/uni0000001c/uni00000016/uni00000013/uni00000011/uni00000016/uni00000018/uni00000018/uni00000011/uni0000001a
/uni00000017/uni00000011/uni0000001c/uni00000014/uni00000014/uni00000011/uni0000001a/uni00000015/uni00000017/uni00000011/uni0000001a/uni00000019/uni00000015/uni00000011/uni0000001b/uni00000019/uni00000017/uni00000011/uni0000001b/uni00000019/uni00000018/uni00000011/uni00000013/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 (b) #FR
Figure 5: Inventory metrics between Gurobi and LS-IMPTable 2: #UR and #FR results between different solvers.
DatasetSCIPGurobiYuck LS-IMP
Exact Heur
#UR #FR #UR #FR #UR #FR #UR #FR #UR #FR
cutoff = 60s
D10.1% 0.6% 1.7% 5.8% 1.7% 5.8% 0.06% 0.2% 15.5% 64.7%
D20.1% 0.6% 0.6% 1.9% 1.7% 5.7% 0 0 16.4% 60.7%
D3 0 0 0 0 2.3% 9.0% 0 0 16.7% 62.0%
D4 0 0 0 0 1.2% 5.0% 0 0 16.3% 61.6%
D5 0 0 0 0 1.8% 4.8% 0 0 17.0% 65.0%
Avg. 0.06% 0.2% 0.4% 1.9% 1.4% 4.9% 0.01% 0.04% 16.4% 62.8%
cutoff = 300s
D10.2% 1.2% 7.7% 39.6% 1.8% 7.0% 0.08% 0.3% 17.7% 68.8%
D20.2% 1.2% 6.0% 35.5% 2.6% 13.9% 0.05% 0.2% 17.7% 62.8%
D3 0 0 5.1% 22.8% 4.3% 14.7% 0 0 18.1% 64.3%
D4 0 0 5.9% 28.8% 2.4% 11.7% 0 0 16.6% 62.5%
D5 0 0 5.3% 24.7% 3.4% 11.2% 0 0 17.3% 65.7%
Avg. 0.1% 0.5% 6.0% 30.3% 2.7% 11.7% 0.02% 0.08% 17.5% 64.8%
cutoff = 1000s
D10.3% 1.8% 15.3% 62.3% 6.6% 24.1% 0.08% 0.03% 17.7% 68.9%
D20.3% 1.8% 14.7% 61.3% 6.3% 28.4% 0.05% 0.2% 17.7% 62.9%
D3 0 0 11.4% 46.8% 7.0% 25.2% 0 0 18.1% 64.4%
D4 0 0 12.1% 52.6% 4.2% 22.2% 0 0 16.6% 62.6%
D5 0 0 14.6% 55.6% 6.8% 23.8% 0 0 17.4% 66.0%
Avg. 0.1% 0.7% 13.6% 55.7% 6.2% 24.7% 0.02% 0.08% 17.5% 65.0%
#win and #feas analysis: It can be observed that within 60
seconds, LS-IMP holds a significant advantage in both the count of
feasible solutions and the count of winning solutions. It is apparent
that SCIP and Yuck, when applied to the available dataset, is not
able to provide a feasible solution for most of the instances. As
a commercial solver, Gurobi falls significantly short of LS-IMP in
terms of both the quantity of feasible solutions and the quality
of solutions found in the 60s time frame. Even with longer time
(300s,1000s), these two metrics still do not surpass LS-IMP.
Solving time analysis: Due to the performance of SCIP and
Yuck at all times and Gurobi in 60s being not so competent as in
Table 3, we only conduct a comparison of the solving time of the LS-
IMP and Gurobi solvers, specifically examining their running times
at 300 seconds and 1000 seconds to validate the convergence speed
of our algorithm. In this analysis, we do a comparison between
the heuristic and exact versions of the Gurobi. The solving time
result is shown in Table Figure 6. It can be observed that, whether
within a 300-second or a 1000-second timeframe, for instances
where the same solution is found, LS-IMP steadily obtains solutions
in a shorter period of time. This demonstrates the rapid convergence
speed of our solver.
Statistical significance analysis: We conducted two experi-
ments. 1. Repetitive running our algorithm for 20 times; 2. A sensi-
tivity analysis experiments on the parameters. The results are in
Table 1 and Table 2 in the appendix3. The two experiments show
3https://github.com/LS-IMP/appendix/blob/main/appendix.pdf
 
1047An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD ’24, August 25–29, 2024, Barcelona, Spain
that our algorithm is stable with randomness and fluctuations in
the parameters.
Table 3: #win and #feas results between solvers.
DatasetSCIPGurobiYuck LS-IMP
Exact Heur
#win #feas #win #feas #win #feas #win #feas #win #feas
cutoff = 60s
D1 1 1 12 12 12 12 0 1 179 179
D2 1 1 4 4 11 26 0 0 164 166
D3 0 0 0 0 16 43 0 0 172 178
D4 0 0 0 0 5 29 0 0 170 171
D5 0 0 0 0 10 41 0 0 175 176
Total 2 2 16 16 54 151 0 1 860 870
cutoff = 300s
D1 2 2 69 96 13 17 0 2 146 180
D2 2 2 61 82 24 44 0 1 141 167
D3 0 0 42 66 17 56 0 0 159 179
D4 0 0 47 74 17 43 0 0 153 172
D5 0 0 42 67 21 53 0 0 165 176
Total 4 4 261 385 92 213 0 3 764 874
cutoff = 1000s
D1 3 3 115 150 34 81 0 2 117 180
D2 3 3 109 151 40 91 0 2 112 167
D3 0 0 87 124 30 87 0 0 131 179
D4 0 0 92 132 35 71 0 0 124 172
D5 0 0 105 141 33 90 0 0 130 176
Total 6 6 508 698 172 420 0 4 614 874
/uni00000014/uni00000013 /uni00000014/uni00000013/uni00000013 /uni00000014/uni00000013/uni00000013/uni00000013
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 /uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000014/uni00000013/uni00000014/uni00000013/uni00000013/uni00000014/uni00000013/uni00000013/uni00000013/uni0000002a/uni00000058/uni00000055/uni00000052/uni00000045/uni0000004c/uni00000003/uni00000032/uni00000053/uni00000057/uni0000004c/uni00000050/uni0000004c/uni0000005d/uni00000048/uni00000055/uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
(a) cutoff: 300s
/uni00000014/uni00000013 /uni00000014/uni00000013/uni00000013 /uni00000014/uni00000013/uni00000013/uni00000013
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 /uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000014/uni00000013/uni00000014/uni00000013/uni00000013/uni00000014/uni00000013/uni00000013/uni00000013/uni0000002a/uni00000058/uni00000055/uni00000052/uni00000045/uni0000004c/uni00000003/uni00000032/uni00000053/uni00000057/uni0000004c/uni00000050/uni0000004c/uni0000005d/uni00000048/uni00000055/uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046 (b) cutoff: 1000s
Figure 6: Run time comparison for Gurobi and LS-IMP
4.3 Effectiveness of Proposed Strategies
To analyze the effectiveness of our proposed strategies, four modi-
fied versions of LS-IMP are proposed as follows. Our ablation exper-
iments are conducted with a time setting aligned to business-related
solving: 60 seconds.
•To analyze the effectiveness of bound move, we modify LS-
IMP by only using the reduce move and the propel move
operators, named the version 𝑣𝑛𝑜_𝑏𝑜𝑢𝑛𝑑 .•To analyze the effectiveness of reduce move, we modify LS-
IMP by only using the bound move and the propel move
operators, named the version 𝑣𝑛𝑜_𝑟𝑒𝑑𝑢𝑐𝑒 .
•To analyze the effectiveness of propel move, we modify LS-
IMP by only using the bound move and the reduce move
operators, named the version 𝑣𝑛𝑜_𝑝𝑟𝑜𝑝𝑒𝑙 .
•To analyze the effectiveness of all operation in Feasible Mode,
we modify LS-IMP by only using simple move, named the
version𝑣𝑛𝑜_𝑎𝑙𝑙.
Table 4: Comparing LS-IMP with its modified versions. The
number of instances where LS-IMP achieves better and worse
performance, denoted as #better and #worse.
𝑣𝑛𝑜_𝑏𝑜𝑢𝑛𝑑𝑣𝑛𝑜_𝑟𝑒𝑑𝑢𝑐𝑒𝑣𝑛𝑜_𝑝𝑟𝑜𝑝𝑒𝑙𝑣𝑛𝑜_𝑎𝑙𝑙
#better 220 305 34 426
#worse 177 279 3 248
The results of the ablation experiment are presented in Table 4
and confirm the effectiveness of the proposed strategies.
5 CONCLUSION AND FUTURE WORK
In this paper, we focus on the local search algorithm for the GD
advertising inventory allocation problem. We model the GD ad-
vertising inventory allocation with focus ratio requirements as an
integer multilinear programming problem and propose an efficient
two-mode local search algorithm to solve it. Experiments demon-
strate that our algorithm produces a higher quality allocation plan
compared to the state-of-the-art solvers for this problem.
Our algorithm is able to handle the general multilinear con-
straints and could be applied to other scenarios of contract alloca-
tions. In the future, we also consider extending our algorithm to
solve problems with requirements involving ratios of other business
metrics. Local search algorithm is new for computational advertisng
and we think is a promising domain to explore. We hope our new
local search algorithm could provide inspiration for future research.
6 ACKNOWLEDGMENTS
This research is supported by National Key R&D Program of China
(2023YFA1009500).
REFERENCES
[1]Tobias Achterberg. Scip: solving constraint integer programs. Mathematical
Programming Computation, 1:1–41, 2009.
[2]Shipra Agrawal and Nikhil R Devanur. Fast algorithms for online stochastic
convex programming. In Proceedings of the twenty-sixth annual ACM-SIAM
symposium on Discrete algorithms, pages 1405–1424. SIAM, 2014.
[3]Shipra Agrawal, Zizhuo Wang, and Yinyu Ye. A dynamic near-optimal algorithm
for online linear programming. Operations Research, 62(4):876–890, 2014.
[4]Adrian Balint and Uwe Schöning. Choosing probability distributions for stochas-
tic local search and the role of make versus break. In Proc. of SAT 2012, pages
16–29, 2012.
[5]Anand Bhalgat, Jon Feldman, and Vahab Mirrokni. Online allocation of display
ads with smooth delivery. In Proceedings of the 18th ACM SIGKDD international
conference on Knowledge discovery and data mining, pages 1213–1221, 2012.
[6]Vijay Bharadwaj, Peiji Chen, Wenjing Ma, Chandrashekhar Nagarajan, John
Tomlin, Sergei Vassilvitskii, Erik Vee, and Jian Yang. Shale: an efficient algorithm
for allocation of guaranteed display advertising. In Proceedings of the 18th ACM
 
1048KDD ’24, August 25–29, 2024, Barcelona, Spain Xiang He et al.
SIGKDD international conference on Knowledge discovery and data mining, pages
1195–1203, 2012.
[7]Armin Biere. Splatz, Lingeling, Plingeling, Treengeling, YalSAT entering the SAT
competition 2016. Proc. of SAT Competition 2016, pages 44–45, 2016.
[8]Gustav Björdal, Jean-Noël Monette, Pierre Flener, and Justin Pearson. A
constraint-based local search backend for minizinc. Constraints, 20:325–345,
2015.
[9]Shaowei Cai. Balance between complexity and quality: Local search for minimum
vertex cover in massive graphs. In Twenty-Fourth International Joint Conference
on Artificial Intelligence, pages 747–753, 2015.
[10] Peiji Chen, Wenjing Ma, Srinath Mandalapu, Chandrashekhar Nagarjan, Jayavel
Shanmugasundaram, Sergei Vassilvitskii, Erik Vee, Manfai Yu, and Jason Zien.
Ad serving using a compact allocation plan. In Proceedings of the 13th ACM
Conference on Electronic Commerce, pages 319–336, 2012.
[11] Liang Dai, Zhonglin Zu, Hao Wu, Liang Wang, and Bo Zheng. Fairness-aware
guaranteed display advertising allocation under traffic cost constraint. In Pro-
ceedings of the ACM Web Conference 2023, pages 3572–3580, 2023.
[12] Nikhil R Devanur, Kamal Jain, Balasubramanian Sivan, and Christopher A
Wilkens. Near optimal online algorithms and fast approximation algorithms
for resource allocation problems. In Proceedings of the 12th ACM conference on
Electronic commerce, pages 29–38, 2011.
[13] RF Drenick. Multilinear programming: Duality theories. Journal of optimization
theory and applications, 72:459–486, 1992.
[14] Zhen Fang, Yang Li, Chuanren Liu, Wenxiang Zhu, Yu Zheng, and Wenjun Zhou.
Large-scale personalized delivery for guaranteed display advertising with real-
time pacing. In 2019 IEEE International Conference on Data Mining (ICDM), pages
190–199. IEEE, 2019.
[15] Jon Feldman, Monika Henzinger, Nitish Korula, Vahab S Mirrokni, and Cliff
Stein. Online stochastic packing applied to display ad allocation. In European
Symposium on Algorithms, pages 182–194. Springer, 2010.
[16] Jon Feldman, Aranyak Mehta, Vahab Mirrokni, and Shan Muthukrishnan. Online
stochastic matching: Beating 1-1/e. In 2009 50th Annual IEEE Symposium on
Foundations of Computer Science, pages 117–126. IEEE, 2009.
[17] Paul W Goldberg. Bounds for the convergence rate of randomized local search
in a multiplayer load-balancing game. In Proceedings of the twenty-third annual
ACM symposium on principles of distributed computing, pages 131–140, 2004.
[18] Jun Gu. Efficient local search for very large-scale satisfiability problems. ACM
SIGART Bulletin, 3(1):8–12, 1992.
[19] LLC Gurobi Optimization. Gurobi optimizer reference manual (gurobi optimiza-
tion, llc). 2022.
[20] Bernhard Haeupler, Vahab S Mirrokni, and Morteza Zadimoghaddam. Online sto-
chastic weighted matching: Improved approximation algorithms. In Internet and
Network Economics: 7th International Workshop, WINE 2011, Singapore, December
11-14, 2011. Proceedings 7, pages 170–181. Springer, 2011.[21] Larry W Jacobs and Michael J Brusco. Note: A local-search heuristic for large
set-covering problems. Naval Research Logistics (NRL), 42(7):1129–1140, 1995.
[22] Alejandro Lara-Caballero and Diego González-Moreno. A population-based local
search algorithm for the identifying code problem. Mathematics, 11(20):4361,
2023.
[23] Bohan Li and Shaowei Cai. Local search for smt on linear and multilinear real
arithmetic. arXiv preprint arXiv:2303.06676, 2023.
[24] Desmond S Lun, Graham Rockwell, Nicholas J Guido, Michael Baym, Jonathan A
Kelner, Bonnie Berger, James E Galagan, and George M Church. Large-scale
identification of genetic design strategies using local search. molecular systems
biology, 5(1):296, 2009.
[25] Vahideh H Manshadi, Shayan Oveis Gharan, and Amin Saberi. Online stochastic
matching: Online actions based on offline statistics. Mathematics of Operations
Research, 37(4):559–573, 2012.
[26] Wuyang Mao, Chuanren Liu, Yundu Huang, Zhonglin Zu, M Harshvardhan, Liang
Wang, and Bo Zheng. End-to-end inventory prediction and contract allocation
for guaranteed delivery advertising. In Proceedings of the 29th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining, pages 1677–1686, 2023.
[27] Vahab S Mirrokni, Shayan Oveis Gharan, and Morteza Zadimoghaddam. Simulta-
neous approximations for adversarial and stochastic online budgeted allocation.
InProceedings of the twenty-third annual ACM-SIAM symposium on Discrete
Algorithms, pages 1690–1701. SIAM, 2012.
[28] Hans Mittelmann. Visualizations of mittelmann benchmarks, 2023. URL: https:
//mattmilten.github.io/mittelmann-plots/.
[29] Baruch Schieber and Soroush Vahidi. Approximating connected maximum cuts
via local search. In 31st Annual European Symposium on Algorithms (ESA 2023).
Schloss-Dagstuhl-Leibniz Zentrum für Informatik, 2023.
[30] Bart Selman, Henry A Kautz, Bram Cohen, et al. Local search strategies for
satisfiability testing. Cliques, coloring, and satisfiability, 26:521–532, 1993.
[31] Karthik Sindhya, Kalyanmoy Deb, and Kaisa Miettinen. A local search based
evolutionary multi-objective optimization approach for fast and accurate conver-
gence. In International Conference on Parallel Problem Solving from Nature, pages
815–824. Springer, 2008.
[32] Karthik Sindhya, Kalyanmoy Deb, and Kaisa Miettinen. Improving convergence
of evolutionary multi-objective optimization with local search: a concurrent-
hybrid algorithm. Natural Computing, 10:1407–1430, 2011.
[33] Peter J Stuckey, Ralph Becket, and Julien Fischer. Philosophy of the m ini z inc
challenge. Constraints, 15:307–316, 2010.
[34] Robert Johannes Maria Vaessens, Emile Hubertus Leonardus Aarts, and Jan Karel
Lenstra. Job shop scheduling by local search. Informs Journal on computing,
8(3):302–317, 1996.
[35] Hong Zhang, Lan Zhang, Lan Xu, Xiaoyang Ma, Zhengtao Wu, Cong Tang, Wei
Xu, and Yiguo Yang. A request-level guaranteed delivery advertising planning:
Forecasting and allocation. In Proceedings of the 26th ACM SIGKDD International
Conference on Knowledge Discovery & Data Mining, pages 2980–2988, 2020.
 
1049