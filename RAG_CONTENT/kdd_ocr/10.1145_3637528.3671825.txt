Making Temporal Betweenness Computation Faster and Restless
Filippo Brunelli
European Commission — JRC
Seville, Spain
filippo.brunelli@ec.europa.euPierluigi Crescenzi
Gran Sasso Science Institute
L’Aquila, Italy
pierluigi.crescenzi@gssi.itLaurent Viennot
Inria, DI ENS
Paris, France
laurent.viennot@inria.fr
ABSTRACT
Buß et al [KDD 2020] recently proved that the problem of com-
puting the betweenness of all nodes of a temporal graph is com-
putationally hard in the case of foremost and fastest paths, while
it is solvable in time 𝑂(𝑛3𝑇2)in the case of shortest and shortest
foremost paths, where 𝑛is the number of nodes and 𝑇is the number
of distinct time steps. A new algorithm for temporal betweenness
computation is introduced in this paper. In the case of shortest and
shortest foremost paths, it requires 𝑂(𝑛+𝑀)space and runs in time
𝑂(𝑛𝑀)=𝑂(𝑛3𝑇), where𝑀is the number of temporal edges, thus
significantly improving the algorithm of Buß et al in terms of time
complexity (note that 𝑇is usually large). Experimental evidence is
provided that our algorithm performs between twice and almost
250 times better than the algorithm of Buß et al. Moreover, we were
able to compute the exact temporal betweenness values of several
large temporal graphs with over a million of temporal edges. For
such size, only approximate computation was possible by using
the algorithm of Santoro and Sarpe [WWW 2022]. Maybe more
importantly, our algorithm extends to the case of restless walks (that
is, walks with waiting constraints in each node), thus providing
a polynomial-time algorithm (with complexity 𝑂(𝑛𝑀)) for com-
puting the temporal betweenness in the case of several different
optimality criteria. Such restless computation was known only for
the shortest criterion (Rymar et al [JGAA 2023]), with complexity
𝑂(𝑛2𝑀𝑇2). We performed an extensive experimental validation by
comparing different waiting constraints and different optimisation
criteria. Moreover, as a case study, we investigate six public tran-
sit networks including Berlin, Rome, and Paris. Overall we find a
general consistency between the different variants of betweenness
centrality. However, we do measure a sensible influence of waiting
constraints, and note some cases of low correlation for certain pairs
of criteria in some networks.
CCS CONCEPTS
•Theory of computation →Shortest paths; •Networks→
Network algorithms ;•Mathematics of computing →Graph al-
gorithms.
KEYWORDS
node centrality, betweenness, temporal graphs, graph mining
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD ’24, August 25–29, 2024, Barcelona, Spain
©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671825ACM Reference Format:
Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot. 2024. Making
Temporal Betweenness Computation Faster and Restless. In Proceedings of
the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining
(KDD ’24), August 25–29, 2024, Barcelona, Spain. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3637528.3671825
1 INTRODUCTION
Social network analysis is usually considered to start with the book
of Moreno [ 32], where sociograms (that is, graphs) are used to study
the relationships between kids from kindergarten to the 8th grade.
Successively, Bavelas [ 1] used sociogram analysis (that is, graph
mining) techniques to identify the most important members of a
group. Several notions of node importance were successively in-
troduced until Freeman [ 22] proposed precise different definitions
ofnode centrality, such as the degree centrality, the closeness cen-
trality, and the betweenness centrality. This latter centrality, which
measures how often a node participates in an optimal path, has been
repeatedly applied in different research contexts, such as, for ex-
ample, the analysis of brain, collaboration, citation and, in general,
social networks. From a computational point of view, Brandes [ 7]
proposed an algorithm for computing the betweenness centrality
of all nodes in time 𝑂(𝑛𝑚), where𝑛is the number of nodes and 𝑚
is the number of edges. Due to the huge size of some real-world
networks, several approximation algorithms for computing the be-
tweenness centrality have also been proposed in the last twenty
years (such as, for example, the ABRA and KADABRA algorithms
described in [6, 35]), mostly based on sampling techniques.
More recently, the notion of betweenness centrality has been
also applied to the case of temporal graphs. Indeed, many real-world
complex networks evolve over time, in the sense that edges can
appear and disappear at specific time instants. As observed in [ 28],
this is due to the fact that interactions between nodes take place
over time, as it happens, for example, in the case of collaboration,
communication, user-product, and transport networks. Many differ-
ent modelizations of these evolving networks have been proposed
in the literature, such as the evolving graph model analysed in [ 20],
thetime-dependent graph model studied in [ 21], the time-varying
graph model [ 12], or the link stream model introduced in [ 28]. In
this paper we refer to this latter model, also known as the temporal
graph model [ 31]. Atemporal graph is a collection of temporal edges
over a fixed set of nodes. Each temporal edge is an edge (𝑢,𝑣)with
an associated availability ordeparture time𝜏and a traversal or
travel time𝜆. A temporal edge 𝑒=(𝑢,𝑣,𝜏,𝜆)can then be traversed
starting from 𝑢at time𝜏and arriving in 𝑣at time𝜏+𝜆. The no-
tion of walk (or of path, if node repetitions are not allowed) can
be easily adapted to the case of temporal graphs by imposing the
natural condition of traversing the temporal edges in ascending
time: that is, for any two consecutive temporal edges (𝑢,𝑣,𝜏 1,𝜆1)
 
163
KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
and(𝑣,𝑤,𝜏 2,𝜆2)in the walk, 𝜏2≥𝜏1+𝜆1.1However, introducing
the temporal dimension arises different notions of optimal walks
or paths, the most common used being the shortest one (with the
fewest number of temporal edges), the foremost one (with the earli-
est arrival time), and the fastest one (with the smallest total travel
time). Once a notion of optimal walk or path is adopted, the cor-
responding notion of betweenness can be analysed in terms of its
computational complexity. Indeed, this has been done in [ 11] in
the case of paths, where the authors proved that computing the
shortest betweenness of all nodes can be done in time 𝑂(𝑛3𝑇2),
where𝑛is the number of nodes and 𝑇is the number of distinct time
steps in the temporal graph, while computing the foremost and the
fastest betweenness is #P-hard, that is, most likely computationally
intractable. These cases are also studied in [ 38], where, among other
results, the authors proved that the restless shortest betweenness
(in the case of walks) can be computed in time 𝑂(𝑛2𝑀𝑇2), where
𝑀is the number of temporal edges (interestingly, the #P-hardness
result does not hold when considering walks rather than paths). A
restless walk (or path) is a walk in which we do not “wait” at the
same node more than 𝛽time units, where 𝛽is a constant: that is, for
any two consecutive temporal edges (𝑢,𝑣,𝜏 1,𝜆1)and(𝑣,𝑤,𝜏 2,𝜆2)
in the walk, 𝜏2≤𝜏1+𝜆1+𝛽in addition to 𝜏2≥𝜏1+𝜆1. Note that, in
the restless case, even deciding whether there exists a path between
two specific nodes is NP-complete [ 13]. Hence, in this case, we are
forced to consider walks instead of paths. Our main contributions
are the following.
•We propose an algorithm for computing the betweenness in
time𝑂(𝑛𝑀)=𝑂(𝑛3𝑇)in the case of shortest and shortest
foremost paths (note that, in these cases, optimal non-restless
walks are always paths). Our algorithm significantly outper-
forms the previously known algorithm (whose complexity
was𝑂(𝑛3𝑇2)) for computing the shortest and the shortest
foremost betweenness [11].
•We propose an algorithm for computing the betweenness in
time𝑂(𝑛𝑀)in the case of fastest, foremost, shortest, shortest
fastest, and shortest foremost restless walks. The only previ-
ously known polynomial-time algorithm (with complexity
𝑂(𝑛2𝑀𝑇2)) was in the case of shortest restless walks [ 38]:
our algorithm significantly improves this algorithm. As far
as we know, in all the other cases our algorithm is the first
polynomial-time one and we conjecture it is optimal. Indeed,
the algorithm is based on a new way of counting the number
of optimal walks from a given source in time 𝑂(𝑀). This
complexity is clearly optimal.
•We perform an extensive experimental evaluation of our
non-restless algorithm, based on a diverse set of real-world
networks that includes all publicly available networks from
the works of [ 2,11,39]. In particular, we compare the exe-
cution time of our algorithm and of the algorithm proposed
in [11] for computing the shortest and the shortest foremost
betweenness. It turns out that our algorithm is between twice
and almost 250 faster than the algorithm of [11].
•By using our non-restless algorithm, we are able to compute
in a reasonable amount of time the shortest betweenness
1In this paper, we assume that the traversal time is always positive, which corresponds
to the case called strict in the literature.of all nodes of three quite large temporal graphs analysed
in [39], for which only approximate values were available so
far by making use of the ONBRA approximation algorithm
proposed in that paper and based on a sampling technique.
From the results reported in [ 39], it also follows that our
algorithm is almost always significantly faster than ONBRA.
•We apply our restless algorithm for computing the fastest,
foremost, shortest, shortest foremost, and shortest fastest be-
tweenness of all nodes of the temporal graphs considered in
the first experiment. By referring to the (weighted) Kendall’s
𝜏correlation and to the intersection of the top-50 node sets,
we compare the node rankings produced by the different
betweenness measures and by different waiting constraints
and we observe that there exists a general consistency be-
tween the different variants of betweenness centrality. We
do also measure a sensible influence of waiting constraints,
and note some cases of low correlation for certain pairs of
criteria in some networks.
•As a case study, we apply our algorithm to the analysis of
several public transport networks among the ones published
in [15,26]. In particular, we compare the execution time,
the (weighted) Kendall’s 𝜏, and the size of the intersection
of the top-100 node sets for two different notions between-
ness, that is, the shortest fastest and the shortest foremost
betweenness. We observe a strong consistency between the
two different variants of betweenness centrality, and a much
lower consistency with the rankings produced by the be-
tweenness of the static underlying graph, thus suggesting
that this latter measure cannot be used as a ‘proxy’ of the
shortest fastest and the shortest foremost betweenness.
Both our algorithm and the algorithm proposed in [ 11] follow a
two phase approach (that is a path counting forward phase and a
betweenness accumulation backward phase) and are both inspired
by Brandes’ algorithm [ 7]. A first difference between our algorithm
and the algorithm of [ 11] is that the latter focuses on temporal
vertices and explore their temporal neighbors, while our algorithm
focuses on temporal edges and explore their temporal extensions.
A second (and maybe, main) difference is that we leverage on two
orderings of the temporal edges to overall consider each temporal
edge (both in the forward phase and in the backward phase) a con-
stant number of times, rather than considering a temporal neighbor
for each of its predecessors. Third, our data structure allows to store
predecessors in linear space with respect to the number of temporal
edges. Finally, we note that the approach used in [ 39] is different
as it is an approximation algorithm and it works through sampling.
However, the way the paths are counted is similar to [11].
2 RELATED WORK
The literature on centrality measures being vast (as demonstrated
by the clever periodic table of network centrality developed by
David Schoch [ 42,43]), we restrict our attention to approaches that
are closest to ours, that is, to the realm of temporal graphs. Several
introductions to temporal graphs also include surveys on temporal
centrality measures (see, e.g., [ 24,28,41]). Clearly related to our
work is the literature on the efficient computation of temporal paths
and walks, such as the seminal paper of Bui-Xuan, Ferreira, and
 
164Making Temporal Betweenness Computation Faster and Restless KDD ’24, August 25–29, 2024, Barcelona, Spain
Jarry [ 10] and the more recent paper by Wu et al [ 49] (the reader
may also refer to the quite exhaustive analysis of this literature
appeared in [ 9]). Besides the references given in the introduction,
our paper is mostly related to all work on the definition and compu-
tation of different temporal centrality measures, such as (in order
of appearance) the temporal pagerank defined in [ 37], the temporal
Katz centrality introduced in [ 4], the temporal reachability used
in [19], the𝑓-PageRank centrality defined in [ 30], the temporal
betweenness centrality defined in [ 47], the temporal closeness cen-
trality treated in [ 16,33], the temporal walk centrality introduced
in [34], and the temporal betweenness centrality analysed in [ 44],
just to mention the most recent ones. Finally, more “local” notions
of centrality in temporal graphs have also been analysed such as the
temporal version of ego betweenness introduced in Ghanem [ 23]
and the pass-through degree defined in [ 2]: these centralities are
clearly more efficient in terms of execution time, but not always
satisfying in terms of the quality of their rankings.
3 BASIC DEFINITIONS AND RESULTS
Temporal graphs. Atemporal graph is a tuple𝐺=(𝑉,𝐸,𝛽), where
𝑉is the set of nodes,𝐸is the set of temporal edges, and 𝛽∈N∪{+∞}
is the maximum waiting-time (we say that waiting is unrestricted
when𝛽=+∞). Atemporal edge 𝑒is a quadruple(𝑢,𝑣,𝜏,𝜆), where
𝑢∈𝑉is the tailof𝑒,𝑣∈𝑉is the head of𝑒,𝜏∈Nis the departure (or
availability )time of𝑒, and𝜆∈N+is the travel (ortraversal )time of
𝑒. We also define the arrival time of𝑒as𝜏+𝜆, and we let dep(𝑒)=𝜏
andarr(𝑒)=𝜏+𝜆denote the departure time and arrival time of
𝑒, respectively. We let 𝑛=|𝑉|and𝑀=|𝐸|denote the number of
nodes and temporal edges, respectively, and 𝑇denote the number
of distinct availability times. Finally, for any node 𝑣,𝐸h𝑣will denote
the set of temporal edges whose head is 𝑣.
Temporal graph representation. We use a doubly-sorted repre-
sentation of a temporal graph (𝑉,𝐸,𝛽), which consists of two lists
𝐸arrand𝐸dep, each containing|𝐸|quadruples representing the tem-
poral edges in 𝐸:𝐸arris a list sorted by non-decreasing arrival time
and𝐸depis a list sorted by non-decreasing departure time. More
precisely, we assume that 𝐸depis specified through implicit pointers
from𝐸depto𝐸arr, that link each (logical) quadruple in 𝐸depto the
(physical) quadruple in 𝐸arrrepresenting the same temporal edge.
Temporal walks. Given a temporal graph 𝐺=(𝑉,𝐸,𝛽), awalk
𝑊from (a source) 𝑠to (a target) 𝑡, or a𝑠𝑡-walk for short, is a
sequence of temporal edges 𝑒𝑖=(𝑢𝑖,𝑣𝑖,𝜏𝑖,𝜆𝑖)for𝑖∈ [𝑘], such
that𝑠=𝑢1,𝑣𝑘=𝑡, and, for each 𝑖∈ [𝑘−1],2𝑢𝑖+1=𝑣𝑖and
arr(𝑒𝑖)≤𝜏𝑖+1≤arr(𝑒𝑖)+𝛽(𝑊is also called a 𝑠𝑒𝑘-walk). A walk is
said to be a path if, for any𝑖,𝑗∈[𝑘]with𝑖≠𝑗,𝑢𝑖≠𝑢𝑗and𝑢𝑖≠𝑣𝑘.
Note that, since travel times are positive, walks are strict in the
sense that𝜏𝑖<𝜏𝑖+1, for𝑖∈[𝑘−1]. The departure time dep(𝑊)of𝑊
is defined as dep(𝑒1), while the arrival time arr(𝑊)of𝑊is defined
asarr(𝑒𝑘). The duration of𝑊is defined as arr(𝑊)−dep(𝑊). We
say that a temporal edge 𝑒=(𝑡,𝑤,𝜏,𝜆)extends𝑊ifarr(𝑊)≤𝜏≤
arr(𝑊)+𝛽. When𝑒extends𝑊, we can indeed define the 𝑠𝑤-walk
𝑊.𝑒=⟨𝑒1,...,𝑒𝑘,𝑒⟩from𝑠to𝑤. Moreover, we also say that 𝑒
extends𝑒𝑘as it indeed extends any 𝑠𝑒𝑘-walk. Finally, we say that a
temporal edge 𝑒is𝑠-reachable when there exists a 𝑠𝑒-walk.
2In the following, for any non-negative integer 𝑛,[𝑛]will denote the set{1,2,...,𝑛},
with[0]=∅.Given a temporal graph 𝐺=(𝑉,𝐸,𝛽), a𝑠𝑡-walk𝑊is ashort-
est(respectively, foremost, latest, and fastest )walk, if there is no
𝑠𝑡-walk that contains less temporal edges than 𝑊(respectively, has
an earlier arrival time, has a later departure time, and has a smaller
duration). Moreover, a shortest foremost (respectively, latest and
fastest )walk is a foremost (respectively, latest and fastest) tempo-
ral walk that is not longer than any other foremost (respectively,
latest and fastest) temporal walk. In the following we will focus
on shortest foremost ( SFo) walks, since these walks will allow us
to introduce our algorithms in an easier way, without hiding the
generality of our approach. In the appendix, we show how our al-
gorithms can be adapted to the other types of walks by introducing
the notions of cost and target cost structure.
SFobetweenness. Given a temporal graph 𝐺=(𝑉,𝐸,𝛽), two
nodes𝑠,𝑡∈𝑉with𝑠≠𝑡, and a temporal edge 𝑒∈𝐸, we let𝜎∗
𝑠,𝑒,𝑡
denote the number of SFowalks from𝑠to𝑡that contain 𝑒. We also
denote by𝜎∗
𝑠,𝑡=Í
𝑒∈𝐸h
𝑡𝜎∗
𝑠,𝑒,𝑡the number of SFowalks from 𝑠to𝑡.
We define the 𝑠-SFobetweenness of a temporal edge 𝑒as𝑏𝑠,𝑒=Í
𝑣∈𝑉:𝜒𝑠,𝑡=1𝜎∗
𝑠,𝑒,𝑡/𝜎∗
𝑠,𝑡, where𝜒𝑠,𝑡=1if𝑠≠𝑡and there exists a
𝑠𝑡-walk (and, hence, 𝜎∗
𝑠,𝑡≠0), and𝜒𝑠,𝑡=0otherwise.
Given three pairwise-distinct nodes 𝑠,𝑢, and𝑡we denote by
𝜎∗
𝑠,𝑢,𝑡=Í
𝑒∈𝐸h𝑢𝜎∗
𝑠,𝑒,𝑡the number of SFowalks from𝑠to𝑡that con-
tain𝑢. Note that a walk where 𝑢appears𝜇times is counted with
multiplicity 𝜇.3TheSFobetweenness of a vertex 𝑢is defined as 𝑏𝑢=Í
𝑠,𝑡∈𝑉\{𝑢}:𝜒𝑠,𝑡=1𝜎∗
𝑠,𝑢,𝑡/𝜎∗
𝑠,𝑡. The SFobetweenness of any vertex 𝑢
can easily be computed from the 𝑠-SFobetweenness 𝑏𝑠,𝑒of all tem-
poral edges 𝑒entering𝑢, since𝑏𝑢=Í
𝑠∈𝑉\{𝑢}Í
𝑒∈𝐸h𝑢𝑏𝑠,𝑒−𝜒𝑠,𝑢
.
Given a temporal graph 𝐺=(𝑉,𝐸,𝛽)and a temporal edge 𝑒∈𝐸,
let𝜎𝑠,𝑒(respectively, 𝜎∗𝑠,𝑒) denote the number of Sh(respectively,
SFo)𝑠𝑒-walks, where a 𝑠𝑒-walk𝑊isSFoif there is no 𝑠𝑒-walk𝑋
such that(arr(𝑋),|𝑋|)◁(arr(𝑊),|𝑊|)(in the following, for any
𝑎,𝑏,𝑐,𝑑∈N,(𝑎,𝑏)◁(𝑐,𝑑)if and only(𝑎<𝑐)∨(𝑎=𝑐∧𝑏<𝑑)).
Moreover, given two nodes 𝑠,𝑡∈𝑉with𝑠≠𝑡, letW𝑠,𝑒,𝑡denote
the set of SFo𝑠𝑡-walk containing 𝑒(hence,|W𝑠,𝑒,𝑡|=𝜎∗
𝑠,𝑒,𝑡). Each
walk𝑊∈W𝑠,𝑒,𝑡can be decomposed into a prefix 𝑊1(from𝑠to
𝑣) ending with 𝑒and a suffix 𝑊2(from𝑣to𝑡). Let𝜃𝑠,𝑒,𝑡denote the
number of distinct suffixes of walks in W𝑠,𝑒,𝑡(eventually including
the empty suffix). It is easy to prove that 𝜎∗
𝑠,𝑒,𝑡=𝜎𝑠,𝑒·𝜃𝑠,𝑒,𝑡.
Given a temporal graph 𝐺=(𝑉,𝐸,𝛽), two nodes 𝑠,𝑡∈𝑉with
𝑠≠𝑡, and a temporal edge 𝑒∈𝐸, let succ𝑠,𝑒,𝑡denote the set of
temporal edges 𝑓such that𝑒and𝑓are one after the other in a
walk𝑊∈W𝑠,𝑒,𝑡. Moreover, let succ𝑠,𝑒=Ð
𝑡∈𝑉\{𝑠}succ𝑠,𝑒,𝑡. In
the following, if 𝑓∈succ𝑠,𝑒, we say that 𝑓issuccessor of𝑒and that
𝑒is apredecessor of𝑓.
Lemma 1. Given a temporal graph 𝐺=(𝑉,𝐸,𝛽)and a temporal
edge𝑒=(𝑢,𝑣,𝜏,𝜆), the following hold:
𝑏𝑠,𝑒=𝜎𝑠,𝑒∑︁
𝑓∈succ𝑠,𝑒𝑏𝑠,𝑓
𝜎𝑠,𝑓+(𝜎∗
𝑠,𝑒
𝜎∗𝑠,𝑣if𝜎∗𝑠,𝑒>0,
0 otherwise.
The above lemma will be used in the backward phase of our
algorithms in order to compute the 𝑠-SFobetweenness of a tempo-
ral edge𝑒having already computed the 𝑠-SFobetweenness of all
successors𝑓of𝑒.
3It is quite natural to take into account how many times a node appears in a walk
when considering walks rather than paths in the betweenness definition.
 
165KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
1
1,1
3
4,1
7
2,55
4,2
9
6,32
2,24
4,1
6
5,1
8
7,1
12
9,113
10,110
6,3
11
9,1𝑣1 𝑣2𝑣3 𝑣4
𝑣5 𝑣6
𝑣7 𝑣8𝐸arr
1 :(𝑣1,𝑣2,1,1)
2 :(𝑣2,𝑣3,2,2)
3 :(𝑣1,𝑣2,4,1)
4 :(𝑣3,𝑣4,4,1)
5 :(𝑣2,𝑣5,4,2)
6 :(𝑣4,𝑣2,5,1)
7 :(𝑣1,𝑣5,2,5)
8 :(𝑣5,𝑣7,7,1)
9 :(𝑣2,𝑣5,6,3)
10 :(𝑣5,𝑣6,6,3)
11 :(𝑣5,𝑣6,9,1)
12 :(𝑣7,𝑣8,9,1)
13 :(𝑣5,𝑣8,10,1)𝐸dep
1:1
2 :2
3 :7
4 :3
5 :4
6 :5
7 :6
8 :9
9 :10
10 :8
11 :11
12 :12
13 :13𝐸dep
no
de
1:[1,7,3]
2
:[2,5,9]
3
:[4]
4
:[6]
5
:[10,8,11,13]
6
:[]
7:[12]
8
:[]𝐸arr
dep
1 : 1
2 : 1
3 : 3
4 : 1
5 : 2
6 : 1
7 : 2
8 : 2
9 : 3
10 : 1
11 : 3
12 : 1
13 : 4
Figur e1:Anexample ofatemp oral graph, wher e𝑛=8,𝑀=13,𝑇=11.The lowerpart ofthelabelofeach temp oral edge
indicates itsavailability time𝜏anditstraversal time𝜆(hence ,thearrival time ofthetemp oral edgeis𝜏+𝜆).The(overline d)
upperpart ofthelabelofeach temp oral edgeindicates itsposition inthe𝐸arrlist.The𝐸dep,𝐸dep
node,𝐸arr
deplists also refer tothe
(overline d)indexesof𝐸arr.Theunderline dindices, instead, indicate theposition ofthecorresponding edgein𝐸arrinto thethe
list𝐸dep
nodeof its tail.
𝑣1𝑣2𝑣3𝑣4𝑣5 𝑣6 𝑣7 𝑣8
𝑣1{⟨1⟩,⟨3⟩}{⟨1,2⟩}{⟨1,2,4⟩}{⟨7⟩}{⟨3,9,11⟩}{⟨7,8⟩}{⟨7,8,12⟩,⟨3,9,13⟩}
𝑣2∅{⟨2⟩}{⟨2,4⟩}{⟨5⟩,⟨9⟩}{⟨5,10⟩,⟨9,11⟩}{⟨5,8⟩}{⟨9,13⟩}
𝑣3∅{⟨4,6⟩}{⟨4⟩}{⟨4,6,9⟩}{⟨4,6,9,11⟩}∅{⟨4,6,9,13⟩}
𝑣4∅{⟨6⟩}∅ {⟨6,9⟩}{⟨6,9,11⟩}∅{⟨6,9,13⟩}
𝑣5∅∅∅∅ {⟨10⟩,⟨11⟩}{⟨8⟩}{⟨13⟩}
𝑣6∅∅∅∅∅ ∅∅
𝑣7∅∅∅∅∅∅ {⟨12⟩}
𝑣8∅∅∅∅∅∅∅
Table 1: The set of shortest 𝑠𝑡-walks in the graph of Figure 1, for any pair of nodes 𝑠and𝑡
3.1 An example of temp oral graph
Letusconsider thetemporalgraph intheleftpart ofFigur e1.The
first listinthefigur eshows𝐸arr(that is,thelistoftemp oraledges
sorte dbynon-de creasing arrival time), while thesecond listin
thefigur eshows𝐸dep(that is,thelistoftemp oraledges sorte dby
non-de creasing departur etime), which isspecifiedbyidentifying
thetemp oraledges bytheir position inthelist𝐸arr(thethirdand
four lists areusedbyouralgorithms). Byassuming𝛽=1and
byidentifying thetemp oraledges bytheir (overline d)position in
thelist𝐸arr,wehavethat⟨1,2,4,6,9⟩isa𝑣1𝑣5-walk which can
beextende dbyeither thetemp oraledge11orthetemp oraledge
13.Onthecontrar y,⟨1,5⟩isnota𝑣1𝑣5-walk since𝜏2=4>3=
arr(𝑒1)+𝛽.Wealso havethat⟨7⟩istheonly shortest𝑣1𝑣5-walk
(with 1temp oraledge) andtheonly (shortest) foremost𝑣1𝑣5-walk
(with arrival time equal to7),and⟨3,9⟩istheonly (shortest) latest
𝑣1𝑣5-walk (with departur etime equal to4and2temp oraledges).
Finally ,both⟨7⟩and⟨3,9⟩arefastest𝑣1𝑣5-walks (with duration
equal to5),andonly⟨7⟩isalso ashortest fastest𝑣1𝑣5-walk. By
considering foremost walks, wehavethat𝜎∗
𝑣1,9,𝑣6=2,since thethe
temp oraledge(𝑣2,𝑣5,6,3)(whose indexin𝐸arris9)iscontaine d
inthetwoforemost𝑣1𝑣6-walks⟨3,9,11⟩and⟨1,2,4,6,9,11⟩.Bysetting𝛽=0andbyconsidering latest walks, instead, wehavethat
𝜎∗𝑣1,𝑣2=𝜎∗
𝑣1,1,𝑣2+𝜎∗
𝑣1,3,𝑣2+𝜎∗
𝑣1,6,𝑣2=1+0+1=2:aswecansee,
thelatest𝑣1𝑣2-walk⟨1,2,4,6⟩iscounte dwith multiplicity 2since
itpasses twice through𝑣2,once viathetemp oraledge(𝑣1,𝑣2,1,1)
(whose indexin𝐸arris1)andonce viathetemp oraledge(𝑣4,𝑣2,5,1)
(whose indexin𝐸arris6).Theshortest walk from𝑣1to𝑣6varies
inlength depending onthevalue of𝛽:with𝛽=0itis6(which
isthelength of⟨1,2,4,6,9,11⟩),with𝛽=1itis3(which isthe
length of⟨3,9,11⟩),andwith𝛽≥2itis2(which isthelength
of⟨7,11⟩).Bysetting𝛽=2andbyconsidering shortest walks,
letuscompute the𝑣1-temp oralbetweenness ofthetemp oraledge
(𝑣4,𝑣2,5,1)(whose indexin𝐸arris6).Since𝜎∗
𝑣1,6,𝑣=0forany
𝑣≠𝑣1,wehavethat𝑏𝑣1,6=0.However,ifweset𝛽=0,then
wehavethat𝜎∗
𝑣1,6,𝑣6=1(since thetemp oraledgeiscontaine din
theunique shortest𝑣1𝑣6-walk⟨1,2,4,6,9,11⟩),while𝜎∗
𝑣1,6,𝑣=0
forany𝑣∉{𝑣1,𝑣6}:hence ,inthiscase,𝑏𝑣1,6=1.If𝛽=1,we
havethat thetemp oralbetweenness vectors arepairwise distinct
depending onthechosen measur e,asshowninTable 2.Letus,for
example ,compute thetemp oralbetweenness ofnode𝑣2inthecase
ofshortest walks. Table 1shows,foranypairofnodes𝑠and𝑡,the
 
166Making Temporal Betweenness Computation Faster and Restless KDD ’24, August 25–29, 2024, Barcelona, Spain
𝑣1𝑣2𝑣3𝑣4𝑣5𝑣6𝑣7𝑣8
Shortest 0.0 9.5 2.0 4.0 10.0 0.0 0.5 0.0
Foremost 0.0 9.5 2.5 4.5 10.0 0.0 3.0 0.0
Latest 0.0 13.5 6.0 8.0 10.0 0.0 0.0 0.0
Fastest 0.0 10.5 2.0 4.0 10.0 0.0 0.0 0.0
Shortest foremost 0.0 9.0 2.0 4.0 10.0 0.0 3.0 0.0
Shortest latest 0.0 12.0 3.0 5.0 10.0 0.0 0.0 0.0
Shortest fastest 0.0 10.0 2.0 4.0 10.0 0.0 0.0 0.0
Table 2: The temporal betweenness vectors with different
types of optimal walks for the temporal graph of Figure 1.
set of shortest 𝑠𝑡-walks. Node 𝑣2is contained as an inner node in
the following walks: the 𝑣1𝑣3-walk⟨1,2⟩, the𝑣1𝑣4-walk⟨1,2,4⟩, the
𝑣1𝑣6-walk⟨3,9,11⟩, the𝑣1𝑣8-walk⟨3,9,13⟩, the𝑣3𝑣5-walk⟨4,6,9⟩,
the𝑣3𝑣6-walk⟨4,6,9,11⟩, the𝑣3𝑣8-walk⟨4,6,9,13⟩, the𝑣4𝑣5-walk
⟨6,9⟩, the𝑣4𝑣6-walk⟨6,9,11⟩, and the𝑣4𝑣8-walk⟨6,9,13⟩. All these
10walks are the only shortest paths from their corresponding
sources to their corresponding destinations, apart from the 𝑣1𝑣8-
walk⟨3,9,13⟩(there is also the 𝑣1𝑣8-walk⟨7,8,12⟩). Hence, each of
them contribute 1to the temporal betweenness of 𝑣2apart from
the𝑣1𝑣8-walk which contributes 0.5. In conclusion, the temporal
betweenness of 𝑣2is9.5(as shown in the Table 2).
4 COMPUTING THE SFOBETWEENNESS
In this section we describe an algorithm to compute the 𝑠-SFo
betweenness 𝑏𝑠,𝑒of all temporal edges 𝑒, for a given source node 𝑠,
which runs in time linear in 𝑀, that is, the number of temporal edges.
By repeating the computation for each source and by using the
fact that the SFobetweenness of any vertex can be computed from
the𝑠-SFobetweenness of the temporal edges, it is then possible to
aggregate these 𝑠-SFobetweennesses to obtain the SFobetweenness
of all nodes in time 𝑂(𝑛𝑀). The algorithm consists of three phases,
a forward, an intermediate, and a backward one. The goal of the
forward phase is to count, for each temporal edge 𝑒, the number
ofSh𝑠𝑒-walks and, at the same time, to identify the set of its
successors, that is, the set of edges 𝑓that can follow 𝑒in aSh𝑠𝑡-
walk, for some target node 𝑡. During the intermediate phase we
compute, for each node 𝑣, the number of SFo𝑠𝑣-walks and their cost
(that is, the pair including the arrival time and the number of edges
in the walk). Finally, the goal of the backward phase is to report the 𝑠-
SFobetweenness of the edges following the successor dependencies.
In the following, given a temporal graph 𝐺=(𝑉,𝐸,𝛽), we assume
that𝐺is represented through its 𝐸arrand𝐸deplists (recall that the
temporal edges in 𝐸depare identified by their position in the list
𝐸arr). We also assume that, by using these two lists, the following
two other lists have been pre-computed, where, once again, each
temporal edge is identified by its position in 𝐸arr(see also the
example in Figure 1): 𝐸dep
node, which, for every 𝑣∈𝑉, contains the list
𝐸dep
node[𝑣]of temporal edges whose tail is 𝑣, sorted in non-decreasing
order with respect to their departure time, and 𝐸arr
dep, which, for
every𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸, contains the position of 𝑒in𝐸dep
node[𝑢]
(more precisely, if 𝑒is the𝑖-th temporal edge in 𝐸arrand the𝑗-th
temporal edge in 𝐸dep
node[𝑢], then𝐸arr
dep[𝑖]=𝑗). Note that both 𝐸dep
node
and𝐸arr
depcan easily be computed in linear-time starting from 𝐸arr
and𝐸dep.4.1 The non-restless case
We first introduce the algorithm for computing the SFobetweenness
in the case𝛽=∞, that is, without waiting constraints ornon-restless
(see Algorithm 1), whose forward phase is built upon the algorithm
of [9] for computing single-source minimum-cost walks.
Algorithm 1: Compute non-restless SFo𝑏𝑠,𝑒, for all𝑒∈𝐸
input :𝐺=(𝑉,𝐸,∞)(represented by 𝐸depand𝐸arr) and𝑠∈𝑉
output :𝑠-SFo betweenness 𝑏𝑠,𝑒, for all𝑒∈𝐸
1Compute the lists 𝐸dep
nodeand𝐸arr
dep;
2foreach𝑣∈𝑉do𝑙[𝑣]:=1;𝑐[𝑣]:=∞;𝜎[𝑣]:=0;
3foreach𝑒∈𝐸do𝐿[𝑒]:=0;𝐶[𝑒]:=∞;Σ[𝑒]:=0;
4foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo
5if𝐸arr
dep[𝑒]≥𝑙[𝑢]then Finalize(𝑢,𝐸arr
dep[𝑒]);
6if𝑢=𝑠then𝐶[𝑒]:=1;Σ[𝑒]:=1;
7if𝐶[𝑒]≠∞then
8 if𝐶[𝑒]≤𝑐[𝑣]then
9𝑎=𝑙[𝑣];𝐷:=𝐸dep
node[𝑣];
10 while𝑎≤|𝐷|∧dep(𝐸arr[𝐷[𝑎]])<𝜏+𝜆do𝑎:=𝑎+1;
11 Finalize(𝑣,𝑎−1);
12 if𝐶[𝑒]<𝑐[𝑣]then𝑐[𝑣]:=𝐶[𝑒];𝜎[𝑣]:=0;
13𝜎[𝑣]:=𝜎[𝑣]+Σ[𝑒];𝐿[𝑒]:=𝑎;
14foreach𝑣∈𝑉do𝑐∗[𝑣]:=[∞,∞];𝜎∗[𝑣]:=0;𝛿[𝑣]:=0;
15foreach𝑒∈𝐸doΣ∗[𝑒]:=0;𝑏[𝑒]:=0;
16foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo
17 if𝐶[𝑒]<∞∧[ arr(𝑒),𝐶[𝑒]]◁𝑐∗[𝑣]then
18𝑐∗[𝑣]:=[arr(𝑒),𝐶[𝑒]];
19foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo
20 if[arr(𝑒),𝐶[𝑒]]=𝑐∗[𝑣]then
21 Σ∗[𝑒]:=Σ[𝑒];𝜎∗[𝑣]:=𝜎∗[𝑣]+Σ[𝑒];
22foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈reverse(𝐸arr):𝐿[𝑒]>0do
23 if𝑐∗[𝑣]◁[arr(𝑒),𝐶[𝑒]]then
24𝛿[𝑣]:=0;𝑐∗[𝑣]:=[arr(𝑒),𝐶[𝑒]];
25 for𝑓∈𝐸dep
node[𝑣][𝐿[𝑒]:𝑙[𝑣]−1]do
𝛿[𝑣]:=𝛿[𝑣]+𝑏[𝑓]/Σ[𝑓];
26𝑙[𝑣]:=𝐿[𝑒];𝑏[𝑒]:=Σ[𝑒]𝛿[𝑣];
27 ifΣ∗[𝑒]>0then𝑏[𝑒]:=𝑏[𝑒]+Σ∗[𝑒]/𝜎∗[𝑣];
28return𝑏
29Finalize(𝑢,𝑗):
30 if𝑐[𝑢]≠∞then
31 foreach𝑓∈𝐸dep
node[𝑙[𝑢],𝑗]do
𝐶[𝑓]:=𝑐[𝑢]+1;Σ[𝑓]:=𝜎[𝑢];
32𝑙[𝑢]:=𝑗+1;
Forward phase (lines 4-13). Let𝐺𝑘=(𝑉,𝐸𝑘,∞)be the temporal
graph containing only the first 𝑘temporal edges in 𝐸arr. The algo-
rithm scans the edges in 𝐸arrone after the other and after scanning
𝑘edges, for each node 𝑣∈𝑉, it updates the following three values:
the length𝑐[𝑣]of any Sh𝑠𝑣-walk in𝐺𝑘, the number 𝜎[𝑣]of these
walks in𝐺𝑘, and the position 𝑙[𝑣]in𝐸dep
node[𝑣]such that all temporal
edges in𝐸dep
node[𝑣]starting from this position can extend a Sh𝑠𝑣-
walk in𝐺𝑘. Note that𝑐[𝑣]can only decrease as 𝑘increases, while
𝑙[𝑣]can only increase. At the beginning, for each node 𝑣,𝑐[𝑣]=∞,
𝜎[𝑣]=0, and𝑙[𝑣]=1. Suppose that the first 𝑘−1temporal edges
have been scanned, and that the edge 𝑒𝑘=(𝑢,𝑣,𝜏,𝜆)has now to be
 
167KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
analysed. Let us first analyse 𝑒𝑘from the point of view of its tail,
that is,𝑢. Clearly,𝑒𝑘is included in 𝐸dep
node[𝑢]: suppose that it appears
in position𝑖. If𝑖≥𝑙[𝑢], then all temporal edges between position
𝑙[𝑢]and𝑖, which have a departure time not greater than dep(𝑒𝑘),
cannot extend any 𝑠𝑢-walk ending with a temporal edge following
𝑒𝑘in𝐸arr, since such a temporal edge has arrival time greater than
dep(𝑒𝑘). Each such edge 𝑓can then be “finalised” (lines 30-32), that
is, the length 𝐶[𝑓]of any Sh𝑠𝑓-walk (in𝐺𝑘) can be set equal to
𝑐[𝑢]+1and the number Σ[𝑓]of these walks (in 𝐺𝑘) can be set
equal to𝜎[𝑢]. We use the term “finalise” to emphasise that 𝐶[𝑓]
will be the same in 𝐺𝑘′for𝑘′≥𝑘. We can also set 𝑙[𝑢]=𝑖+1, since
all temporal edges in 𝐸dep
node[𝑢]starting from position 𝑖+1can still
extend a Sh𝑠𝑢-walk in𝐺𝑘′for𝑘′≥𝑘. Moreover, if 𝑢=𝑠, then we
can set𝐶[𝑒𝑘]equal to 1(since we are considering Shwalks from
𝑠) and the number of Shwalks ending with 𝑒𝑘is equal to 1(since
there is only one such walk, that is, ⟨𝑒𝑘⟩). Let us now analyse the
temporal edge 𝑒𝑘from the point of view of its head, that is, 𝑣, by
assuming that there exists at least one Shwalk ending with 𝑒𝑘in
𝐺𝑘. If𝐶[𝑒𝑘]is not greater than 𝑐[𝑣](that is,𝑒𝑘ends a Sh𝑠𝑣-walk),
we first compute the first position 𝑎in𝐸dep
node[𝑣]of a temporal edge
whose departure time is at least equal to 𝜏+𝜆(that is, a temporal
edge which can extend an 𝑠𝑒-walk in𝐺𝑘). All the temporal edges in
𝐸dep
node[𝑣]between the position 𝑙[𝑣]and the position 𝑎−1can now be
finalised, since they cannot be the successor of any temporal edge
of𝐸arrfollowing𝑒𝑘. We then set 𝑙[𝑣]=𝑎, since all temporal edges
in𝐸dep
node[𝑣]starting from position 𝑎can still extend a Sh𝑠𝑣-walk in
𝐺𝑘′for𝑘′≥𝑘(in particular, they extend Sh𝑠𝑒-walks). Moreover, if
adding the temporal edge 𝑒𝑘to𝐺𝑘−1reduces the length 𝑐[𝑣]of the
Sh𝑠𝑣-walks (that is, 𝐶[𝑒𝑘]<𝑐[𝑣]), then we have to update 𝑐[𝑣],
by setting it equal to 𝐶[𝑒𝑘](that is, the length of the Sh𝑠𝑒𝑘-walks),
and𝜎[𝑣]by setting it equal to the number Σ[𝑒𝑘]ofSh𝑠𝑒𝑘-walk in
𝐺𝑘. Otherwise (that is, 𝐶[𝑒𝑘]=𝑐[𝑣]and adding the temporal edge
𝑒𝑘to𝐺𝑘−1does not change the length 𝑐[𝑣]of the Sh𝑠𝑣-walks), the
number Σ[𝑒𝑘]ofSh𝑠𝑒𝑘-walk in𝐺𝑘has to be added to 𝜎[𝑣](since
allSh𝑠𝑒𝑘-walks are also Sh𝑠𝑣-walks). Finally, we store in 𝐿[𝑒𝑘]the
position𝑎in𝐸dep
node[𝑣], which is the first position of the successors
of𝑒(to be used in the backward phase).
Intermediate phase (lines 16-21). Once we have computed, for
each𝑒∈𝐸, the length 𝐶[𝑒]of any Sh𝑠𝑒-walk and the number
Σ[𝑒]of these walks, it is easy to compute, for each 𝑣∈𝑉,𝑐∗[𝑣],
where𝑐∗[𝑣]specifies both the arrival time 𝑐∗[𝑣][1]and the length
𝑐∗[𝑣][2]of any SFo𝑠𝑣-walk. Indeed, it suffices to scan the temporal
edges in𝐸arrand, for each edge 𝑒=(𝑢,𝑣,𝜏,𝜆), to verify whether
(arr(𝑒),𝐶[𝑒])◁𝑐∗[𝑣]in which case 𝑐∗[𝑣]has to be set equal to
(arr(𝑒),𝐶[𝑒])(lines 16-18). Once 𝑐∗[𝑣]has been computed for each
𝑣∈𝑉, the number 𝜎∗[𝑣]ofSFo𝑠𝑣-walks can also be computed.
Indeed, it suffices to scan again the temporal edges in 𝐸arrand, for
each edge𝑒=(𝑢,𝑣,𝜏,𝜆), to verify whether(arr(𝑒),𝐶[𝑒])=𝑐∗[𝑣]in
which case𝜎∗[𝑣]has to be increased by the value Σ[𝑒](lines 19-21).
Note that, at the same time, we can also compute the number Σ∗[𝑒]
ofSFo𝑠𝑒-walks.
Backward phase (lines 22-27). The backward phase simply ap-
plies Lemma 1 in a “reverse” way, by scanning the temporal edges
in𝐸arrfrom the last to the first one and, for each scanned edge
𝑒, by accumulating on its head 𝑣the contribution to 𝑏𝑠,𝑒of eachsuccessor of 𝑒. More precisely, we store in 𝛿[𝑣]the partial sumÍ
𝑓∈𝐸dep
node[𝑣][𝑙[𝑣]:𝑧]𝑏[𝑓]
Σ[𝑓]where𝑧denotes the last index when the
sum was zeroed. It can be updated in constant time per edge
𝑓∈𝐸dep
node[𝑣]each time we encounter an edge 𝑒with head𝑣. Note
that each such edge 𝑒has successors 𝐸dep
node[𝑣][𝐿[𝑒]:𝑟], where𝑟is
the position of the last edge 𝑓in𝐸dep
nodesuch that𝐶[𝑓]=𝐶[𝑒]+1
and the index 𝐿[𝑒]of the first successor can only decrease as we
scan edges𝑒with lower arrival times.4As we scan the 𝑘th edge𝑒
in𝐸arr, we also maintain in 𝑐∗[𝑣]the arrival time and the length of
anySFo𝑠𝑣-walk in𝐺𝑘. Whenever𝑐∗[𝑣]◁(arr(𝑒),𝐶[𝑒]), the index
𝑟for𝑒is indeed𝑙[𝑣]−1and the quantity accumulated on 𝑣has to
be zeroed while 𝑐∗[𝑣]has to be updated to (arr(𝑒),𝐶[𝑒]).
Theorem 2. For any temporal graph 𝐺=(𝑉,𝐸,∞)and for any
𝑠∈𝑉, Algorithm 1 correctly computes the 𝑠-SFo betweenness 𝑏𝑠,𝑒in
time𝑂(𝑀).
4.2 The restless case
We now briefly describe how Algorithm 1 has to be modified in
order to deal with the general case (that is, 𝛽≤∞): the new algo-
rithm manages the increased complexity of the restless constraint
through appropriate lists of interval quintuples which correspond
to windows of time with temporal edges from a node that extend
the same optimal walks. Once again, we execute a forward phase
(in order to compute, for each temporal edge 𝑒, the length 𝐶[𝑒]
of any Sh𝑠𝑒-walk and the number Σ[𝑒]of these walks), followed
by the same intermediate phase and a backward phase in which
Lemma 1 is applied. Note that in Algorithm 1, during the forward
phase, in order to correctly apply the lemma in the backward phase,
it sufficed to memorize, for each temporal edge 𝑒, the position 𝐿[𝑒]
in the list𝐸dep
node[𝑣]of the first temporal edge which could extend
aSh𝑠𝑒-walk. This was due to the fact that, in the non-restless
case, if an en edge 𝑓in𝐸dep
node[𝑣]extends a𝑠𝑒-walk, then all edges
following𝑓in𝐸dep
node[𝑣]also extend the walk. In the general case,
this is not true anymore (because of the waiting constraints) and
the forward phase of the algorithm has to maintain additional infor-
mation to be used during the backward phase. In particular, given
a temporal graph 𝐺=(𝑉,𝐸,𝛽), for each node 𝑣∈𝑉, the general
algorithm maintains a list I𝑣ofinterval quintuples 𝑄=(𝑙,𝑟,𝑐,𝑃,𝜂)
where 1≤𝑙,𝑟≤𝐸dep
node[𝑣],𝑐∈N,𝜂∈N, and𝑃⊆𝐸is a list of
predecessor edges. The semantic of an interval quintuple 𝑄is the
following.
•𝑙and𝑟are the left and right extremes of an interval 𝑄.𝐼of
edges in𝐸dep
node[𝑣](that is,𝑄.𝐼=𝐸dep
node[𝑣][𝑙:𝑟]).
•𝑐is the length of any Shwalk from the source 𝑠(in the
temporal graph induced by the edges scanned so far), such
that edges in 𝑄.𝐼extend it.
•The edges ending these walks are predecessors of edges in
𝑄.𝐼and are stored in the ordered list 𝑃(sorted by arrival
times). More precisely, for any edge 𝑓=𝑄.𝐼[𝑖], with 1≤
4As it is common in several programming languages, given a sequence 𝐴and two
positive integers 𝑙and𝑟both not greater than the length of 𝐴and such that 𝑙≤𝑟, we
denote by𝐴[𝑙:𝑟]the sub-sequence of 𝐴from position 𝑙to position𝑟, both included.
Moreover,𝐴[𝑙:]=𝐴[𝑙:|𝐴|].
 
168Making Temporal Betweenness Computation Faster and Restless KDD ’24, August 25–29, 2024, Barcelona, Spain
𝑖≤𝑟−𝑙+1, the set of edges 𝑃𝑖, that precede 𝑓in the
above mentioned Shwalks, is a subset of 𝑃. We rely on the
fact that edges with the same predecessors partition 𝑄.𝐼
into consecutive intervals. Indeed, 𝑃𝑖+1is included in 𝑃𝑖if
𝑖≤𝑟−𝑙. The ordering of 𝑃respect the inclusion ordering
𝑃1⊇𝑃2⊇··· so that each 𝑃𝑖is a suffix of 𝑃.
•𝜂is the total number of Shwalks that end with an edge in 𝑃
(they all have length 𝑐).
Note that the forward and backward phases of the algorithm for
the restless case as well as the finalisation of an edge are more
complicated than in the case of the non-restless case, in order to
deal with the list of interval quintuples (the pseudo-code of this
algorithm is very similar to the one referred to in the next section).
5 COMPUTING OTHER BETWEENNESSES
In Appendix A we introduce a general cost framework, we show
how it can encompass the fastest ( Fa), foremost ( Fo),Sh, and short-
est fastest ( SFa) optimality criteria, and we briefly describe the
algorithm for computing the (restless) betweenness centrality for
any criteria that fits in the framework (see Algorithm 2).
6 THE EXPERIMENTS
In this section we perform several experimental analysis in order
to compare the performance of our algorithms with respect to the
ones previously proposed in the literature, and in order to apply
the algorithms themselves to a specific case study in the field of
public transport networks. Our experimental study includes the
following three algorithms.
•bmnr : this is the algorithm proposed in [ 11] to compute the
exact values of the ShandSFobetweenness of all nodes.
•Onbra : this is the approximation algorithm proposed in [ 39],
which is based on a sampling technique for obtaining an
absolute approximation of the Shbetweenness values (both
in the non restless and in the restless case).
•Fast : this is the algorithm described in the previous sections,
for computing the exact values of the SFo(restless) between-
ness, and in Appendix A for computing the exact values of
the other (restless) betweenness measures.
To analyse the correlation between different centrality rankings,
we used different metrics: the Kendall’s 𝜏correlation coefficient [ 25],
a weighted version of this coefficient [ 48], and the intersection of
the top-1000 ranked nodes (note that the latter metric is directly
translatable into the Jaccard similarity of the top ranked nodes).
For the weighted Kendall’s 𝜏coefficient, we used the hyperbolic
weighting scheme, that gives weights to the positions in the rank-
ing which decay harmonically with the ranks, i.e., the weight of
rank𝑟is1/(𝑟+1). Both the Kendall’s 𝜏correlation coefficient and
its weighted version has been computed by using the Java code
available at the Laboratory for Web Algorithmics [ 5]. For the sake
of brevity, we here discuss the weighted Kendall 𝜏results only.
6.1 Comparing algorithms execution times
First, we compare the running time of bmnr , ofOnbra , and of Fast .
We present here the results concerning only the computation of
theShbetweenness: however, the results are similar in the case ofNetw
ork n M T URL tBMNR tFasttBMNR
tFast
Infectious 10972
831824 76944 [14] 3111.19 1603.53 1.94
DiggReply 30360 86203 82641 [36] 1190.41 506.53 2.35
FacebookWall 35817 198028 194904 [36] 3410.98 1317.76 2.59
SMS 44090 544607 467838 [36] 12476.04 4721.05 2.64
SlashdotReply 51083 139789 89862 [36] 4489.14 1643.77 2.73
WikiElections 7115 106985 101012 [29] 521.11 113.68 4.58
CollegeMsg 1899 59798 58911 [29] 242.81 23.20 10.47
Topology 16564 198038 32823 [27] 8704.15 792.82 10.98
Hypertext09 113 41636 5246 [14] 83.63 0.80 104.37
HighSchool11 126 57078 5609 [14] 132.33 1.18 111.86
HighSchool12 180 90094 11273 [14] 394.70 2.93 134.89
PrimarySchool 242 251546 3100 [14] 1895.45 12.92 146.67
EmailEU 986 327336 207880 [29] 11942.84 72.24 165.32
HighSchool13 327 377016 7375 [14] 7131.86 29.63 240.67
HospitalWard 75 64848 9453 [14] 204.43 0.83 247.49
Table 3: The temporal graphs used in our first experiment,
where𝑛denotes the number of nodes, 𝑀the number of tem-
poral edges, 𝑇the number of unique time steps, and tBMNR
and tFastthe execution time of BMNR andFast, respectively.
theSFobetweenness. We used the Julia implementation of bmnr
associated to [ 2] and available at [ 3].5We also implemented Fast
in Julia: our code is available at https://github.com/piluc/TWBC.
Finally, we made use of the results reported in [ 39] which, in turn,
made use of the C implementation of Onbra available at [ 40]. We
executed the experiments on a server running Ubuntu 20.04.5 LTS
112 with processors Intel(R) Xeon(R) Gold 6238R CPU @ 2.20GHz
and 112GB RAM.
Dataset. In this first experiment, we execute the algorithms on
the set of temporal graphs used in [ 2], which includes almost all
the networks of [ 11] and of [ 39]. As stated in [ 2], this set does not
include one temporal graph used in [ 11], because it does not appear
to be available anymore, and it replaces one temporal graph used
in [39] by a bigger one from a different domain to make the set of
analyzed temporal graphs more diverse. The properties of these
networks are summarized in the first five columns of Table 3.
Results. The execution times of bmnr and of Fast are shown in
the 6th and 7th columns of Table 3. As it can be seen, Fast is
between approximately two and almost 250 times faster than bmnr
(see the eighth column). It is worth observing that the execution
time of our Julia implementation of Fast is significantly lower than
the execution time (reported in [ 39]) of the C implementation of
Onbra , which was executed on an architecture not very different
from ours. Indeed, on the four temporal graphs of our dataset that
have also been used in the experimental analysis of [ 39] (that is,
College msg ,Email EU ,Facebook wall , and SMS), the execution
time of Onbra is approximately 6, 25, 2, and 3 times slower than
our algorithm (note that Onbra computed the estimates of the Sh
betweenness values, by using a sample of node pairs whose size
was less than 1%of the number of all node pairs).
6.2 Analysing three larger temporal graphs
In [39], the authors consider three other temporal graphs, whose
properties are summarised in the first five columns of Table 4. Ac-
cording to the authors, on these temporal graphs the algorithm
bmnr was not able to conclude the computation on their machine
5As stated in [ 2], the original C implementations of bmnr caused overflow (indicated
by negative centralities) and out of memory errors.
 
169KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
T
emporal graph n M T Source tbmnr tFasttbmnr
tFasttOnbra Sample
size Weighted 𝜏
MathOverflow 24759
390414 389952 [29] 46594 2117 22.01 36983 30650 0 .88
AskUbuntu 157222 726639 724715 [29] 421781 32280 13.07 35585 14831 0 .86
SuperUser 192409 1108716 1105102 [29] 972104 63553 15.30 41856 11106 0 .86
Table 4: The temporal graphs used in our second experiment, where 𝑡bmnr denotes the execution time of BMNR, tFastthe
execution time of Fast, and𝑡Onbrathe execution time of Onbra reported in [ 39]. The last two columns show the sample size
used by Onbra and the weighted Kendall 𝜏coefficient of the ranking produced by Onbra with this sample size, respectively.
since it required too much memory, while Onbra could provide
estimates of the Shbetweenness centrality values in the time in-
dicated in the eighth column of the table. The memory problems
ofbmnr have been already solved in the Julia implementation of
bmnr , by using dictionaries instead of matrices. Hence, we have
been able to execute the algorithm bmnr with input these three
temporal graphs. By using Fast , the computation of the exact Sh
betweenness values requires approximately 0.6, 9, and 17.7 hours,
thus significantly improving over bmnr (very similar results hold
in the case of the SFobetweenness). Moreover, the execution time
of our Julia implementation of Fast on the three networks is sig-
nificantly less than, comparable with, and approximately 1.5 bigger
than the reported execution time of the C implementation of Onbra
(recall that Onbra computes estimates of the betweenness values).
The second to last column of Table 4 shows the sample size used
byOnbra , which is the one reported in [ 39], while the last column
shows the weighted Kendall 𝜏coefficient between the ranking pro-
duced by Fast and the one produced by Onbra with this sample
size. As it can be seen, in order to be competitive in terms of ex-
ecution time, Onbra produces centrality values which are quite
imprecise in terms of rankings. Once we have computed the Shand
SFobetweenness exact values, we analysed the correlation between
these measures. These correlations are very high, especially if we
consider the weighted Kendall’s 𝜏coefficient or the intersection of
the top-1000 ranked nodes, whose values are 0.97,0.98, and 0.98,
and949, 960, and 962, respectively. Hence, if we look for the top
nodes in the rankings, then there is not so much difference between
using the Shand the SFobetweenness measure.
6.3 Analysing ranking correlations
Our third experiment consists of comparing the rankings of the
nodes of a temporal graph when sorted according to their between-
ness values, computed with different waiting constraints and for
different walk optimality criteria. In particular, we considered the
following values of 𝛽:300, 600, 1200, 2400, and∞. Moreover, we
computed the Fa,Fo,Sh,SFa, and SFobetweenness values (by
using the general Fast algorithm, that is, Algorithm 2 in the appen-
dix). However, we did not compute the Foand the Fabetweenness
values in the case 𝛽=∞, due to the huge number of optimal walks:
this involves using Julia number data structures which causes our
algorithm to take an excessive amount of time needed to calcu-
late the exact betweenness values. For the very same reason (for
different values of 𝛽), we excluded the Topology network from
the dataset used in this experiment, which otherwise is the same
as the one used in the first experiment. We observe that all the
betweenness measures are highly correlated, with the Shand the
Figure 2: The quartiles of the weighted Kendall 𝜏over 14
networks, for each pair of betweenness measures ( 𝛽=2400).
SFabetweenness being the two more correlated (see the box plot
of Figure 2, which show the quartiles of the correlation values for
𝛽=2400). In particular, in half of the networks in the dataset the
weighted Kendall 𝜏for this pair of betweenness measures with
𝛽=2400 is at least 0.97and the minimum weighted Kendall 𝜏
is0.84. This minimum value is reached in correspondence of the
Primary school network, for which the weighted Kendall 𝜏is the
minimum one for all the pairs of betweenness measures. Another
interesting observation is that the weighted Kendall 𝜏values seem
to depend on the waiting constraints. Indeed, we can observe that
these values tend to decrease as 𝛽increases, as shown in the left
Figure 3: The average weighted Kendall 𝜏over 14 networks,
for all pairs of betweenness measures, as a function of 𝛽.
 
170Making Temporal Betweenness Computation Faster and Restless KDD ’24, August 25–29, 2024, Barcelona, Spain
City n
M m M/m t Fast tB
Berlin 4601
1048209 12359 85 35555 8 .03
Bordeaux 3435 236595 4040 59 2336 2 .95
Kuopio 549 32117 979 33 126 0 .07
Paris 11950 1823871 16704 109 121157 33 .51
Rome 7869 1051211 10143 104 70236 18 .77
Venice 1874 118480 3464 34 439 0 .67
Table 5: The 6 cities analysed in our case study: 𝑚denotes the
number of edges in the underlying graph, while 𝑡Bdenotes
the execution time of the Brandes’ algorithm on this graph.
Figure 4: The weighted Kendall 𝜏between the SFaand the
SFobetweenness rankings (solid) and between the SFobe-
tweenness and the betweenness rankings (dashed), for each
public transport network and for 𝛽=300,600,1200,2400,∞.
part of Figure 3 where the average weighted Kendall 𝜏values over
the fourteen networks is shown as a function of the value of 𝛽. This
behaviour can be justified by the fact that when 𝛽increases the set
of optimal walks with respect to different betweenness measures
may be quite different: that is, the more stringent are the waiting
constraints the more similar are the sets of optimal walks.
6.4 Analysing public transport networks
In all the networks analysed so far the traversal time of all temporal
edges is equal to 1. In this last experiment, instead, we use a subset
of the dataset published in [ 26] and used [ 15]. This dataset includes
25 cities’ public transport networks: the list of the cities that we
used in our experiment is summarized in Table 5. In this experiment,
we focus on the SFaand the SFobetweenness values, because of
two main reasons. First, each temporal edge of the temporal graph
relates to the connection between two stations of a transport trip:
hence, counting the number of temporal edges in a walk does not
indicate the number of transfers (which instead should be more
interesting to analyse in the case of a public transport network).
For this reason, we have not analysed the Shbetweenness mea-
sure. Secondly, focusing on walks which are the shortest among the
fastest and the foremost ones allows us to analyse walks which are
the closest to being paths in the case of waiting constraints (which
are both desirable properties in the case of public transport trips).
Given a temporal graph 𝐺=(𝑉,𝐸,𝛽), the underlying graph of𝐺is
the graph whose set of nodes is 𝑉and whose set of edges containsall pairs(𝑢,𝑣)such that(𝑢,𝑣,𝜏,𝜆)∈𝐸, for some𝜏and𝜆. The main
goal of this experiment is to verify how much the SFaand the SFo
betweenness measures of a temporal graph are correlated to the
(classical) betweenness measure of the corresponding underlying
graph. In the second to last column of the table we show the average
execution time of the Fast algorithm computing the SFaand the
SFobetweenness with 𝛽=300,600,1200,2400,∞, while the last
column shows the execution time for computing the betweenness
values of the underlying graph by using the Brandes’ algorithm [ 7]
(as implemented in the Julia Graphs package [ 18]). As it can be seen,
this latter algorithm is significantly faster than the Fast algorithm.
Actually, we might expect an additional multiplicative factor close
to the ratio 𝑀/𝑚, where𝑚denotes the number of edges in the
underlying graph. In practice, this factor is between 20 and 50 times
bigger because of two main reasons: on the one hand, our code for
the general case is not as optimised as the code for the non-restless
case thus leading to a code around ten times slower, on the other
hand we are forced to use big data structures in order to deal with
the huge number of optimal walks (which is not the case with the
underlying graphs). Since computing the betweenness of the un-
derlying graph is significantly faster than our algorithm, it is worth
determining the correlation between this betweenness and the SFa
and the SFobetweenness. As it is shown in Figure 4, the weighted
Kendall𝜏between the SFaand the SFobetweenness rankings is
very high for all values of 𝛽. On the contrary, the weighted Kendall
𝜏between the SFobetweenness and the betweenness rankings is
significantly lower, especially when 𝛽=300or𝛽=600, which
correspond to five and ten minutes of waiting time, respectively
(similar results hold for the SFabetweenness). These results thus
suggest that the betweenness of the underlying graph cannot be
used as a proxy of the SFaand the SFobetweenness, whenever
waiting constraints have to be satisfied. This contrasts with what
has been shown in [ 2], where the authors found high correlations
between the Shbetweenness with 𝛽=∞(that is, when no waiting
constraint are used) and the betweenness of the underlying graph.
7 FURTHER RESEARCH
As we follow the framework of [ 9], our algorithm can support more
general waiting constraints and edge weights/costs with appro-
priate cost and target-cost structures. From a theoretical point of
view, it would be interesting to look for conditional lower bound
on the computation of the betweenness in the restless case. From
an experimental point of view, instead, it would be worth enriching
the temporal graph model and appropriately modify our algorithms
in order to take into account the number of transfers in public
transport networks, and, thus, focusing on the betweenness values
based on the walks with the minimum number of transfers. Finally,
we think it would worth comparing our algorithm with more recent
papers that propose exact [ 50] and approximate [ 17] algorithms for
computing the temporal betweenness in the non-restless case.
ACKNOWLEDGMENTS
This work is partially supported by PNRR MIUR project GAMING
“Graph Algorithms and MinINg for Green agents” (PE0000013, CUP
D13C24000430001) and by ANR project TEMPOGRAL (ANR-22-
CE48-0001).
 
171KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
REFERENCES
[1]Alex Bavelas. 1950. Communication patterns in task-oriented groups. The journal
of the acoustical society of America 22, 6 (1950), 725–730.
[2]Ruben Becker, Pierluigi Crescenzi, Antonio Cruciani, and Bojana Kodric. 2023.
Proxying Betweenness Centrality Rankings in Temporal Networks. In 21st Inter-
national Symposium on Experimental Algorithms (LIPIcs, Vol. 265). 6:1–6:22.
[3]Ruben Becker, Pierluigi Crescenzi, Antonio Cruciani, and Bojana Kodric. last
checked on October 13, 2023. TSBProxy. https://github.com/piluc/TSBProxy.
[4]Ferenc Béres, Róbert Pálovics, Anna Oláh, and András A Benczúr. 2018. Temporal
walk based centrality metric for graph streams. Applied network science 3, 1 (2018),
32:1–32:26.
[5]Paolo Boldi, Massimo Santini, and Sebastiano Vigna. last checked on December
31, 2023. Crawdad. https://law.di.unimi.it.
[6]Michele Borassi and Emanuele Natale. 2019. KADABRA is an ADaptive Algorithm
for Betweenness via Random Approximation. ACM J. Exp. Algorithmics 24, 1
(2019), 1.2:1–1.2:35.
[7]Ulrik Brandes. 2001. A faster algorithm for betweenness centrality. Journal of
mathematical sociology 25, 2 (2001), 163–177.
[8]Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot. 2021. On computing
Pareto optimal paths in weighted time-dependent networks. Inf. Process. Lett.
168 (2021), 106086.
[9]Filippo Brunelli and Laurent Viennot. 2022. Minimum-Cost Temporal Walks
under Waiting-Time Constraints in Linear Time. CoRR abs/2211.12136 (2022).
https://doi.org/10.48550/arXiv.2211.12136 arXiv:2211.12136
[10] Binh-Minh Bui-Xuan, Afonso Ferreira, and Aubin Jarry. 2003. Computing Short-
est, Fastest, and Foremost Journeys in Dynamic Networks. Int. J. Found. Comput.
Sci.14, 2 (2003), 267–285.
[11] Sebastian Buß, Hendrik Molter, Rolf Niedermeier, and Maciej Rymar. 2020. Algo-
rithmic Aspects of Temporal Betweenness. In KDD ’20: The 26th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining, Virtual Event, CA, USA,
August 23-27, 2020, Rajesh Gupta, Yan Liu, Jiliang Tang, and B. Aditya Prakash
(Eds.). ACM, 2084–2092. https://doi.org/10.1145/3394486.3403259
[12] Arnaud Casteigts, Paola Flocchini, Walter Quattrociocchi, and Nicola Santoro.
2012. Time-varying graphs and dynamic networks. IJPEDS 27, 5 (2012), 387–408.
[13] Arnaud Casteigts, Anne-Sophie Himmel, Hendrik Molter, and Philipp Zschoche.
2021. Finding Temporal Paths Under Waiting Time Constraints. Algorithmica 83,
9 (2021), 2754–2802.
[14] Ciro Cattuto and Alain Barrat. last checked on October 4, 2022. SocioPatterns.
https://www.sociopatterns.org/.
[15] Pierluigi Crescenzi, Clémence Magnien, and Andrea Marino. 2019. Approximat-
ing the Temporal Neighbourhood Function of Large Temporal Graphs. Algorithms
12, 10 (2019), 211.
[16] Pierluigi Crescenzi, Clémence Magnien, and Andrea Marino. 2020. Finding Top- 𝑘
Nodes for Temporal Closeness in Large Temporal Graphs. Algorithms 13, 9 (2020),
211.
[17] Antonio Cruciani. 2024. MANTRA: Temporal Betweenness Centrality Approxi-
mation through Sampling. arXiv:2304.08356 [cs.DS]
[18] James Fairbanks, Mathieu Besançon, Schölly Simon, Júlio Hoffiman, Nick Eubank,
and Stefan Karpinski. last checked on February 4, 2024. JuliaGraphs/Graphs.jl:
an optimized graphs package for the Julia programming language. https://github.
com/JuliaGraphs/Graphs.jl.
[19] Lucia Falzon, Eric Quintane, John Dunn, and Garry Robins. 2018. Embedding
time in positions: Temporal measures of centrality for social network analysis.
Social Networks 54 (2018), 168–178.
[20] Afonso Ferreira. 2004. Building a reference combinatorial model for MANETs.
IEEE Netw. 18, 5 (2004), 24–29.
[21] Luca Foschini, John Hershberger, and Subhash Suri. 2014. On the Complexity of
Time-Dependent Shortest Paths. Algorithmica 68, 4 (2014), 1075–1097.
[22] Linton C. Freeman. 1977. A Set of Measures of Centrality Based on Betweenness.
Sociometry 40, 1 (March 1977), 35–41. https://doi.org/10.2307/3033543
[23] Marwan Ghanem, Florent Coriat, and Lionel Tabourier. 2017. Ego-betweenness
centrality in link streams. In Proceedings of the 2017 IEEE/ACM International
Conference on Advances in Social Networks Analysis and Mining 2017, Sydney,
Australia, July 31 - August 03, 2017. ACM, 667–674.
[24] Petter Holme. 2015. Modern temporal network theory: a colloquium. The
European Physical Journal B 88 (2015), 234.
[25] Maurice G Kendall. 1938. A new measure of rank correlation. Biometrika 30, 1/2
(1938), 81–93.
[26] R. Kujala, C. Weckström, R. Darst, M. Madlenocić, and J. Saramäki. 2018. A
collection of public transport network data sets for 25 cities. Sci. Data 5 (2018),
article number: 180089.
[27] J. Kunegis. last checked on October 4, 2022. The KONECT Project. http://konect.
cc.
[28] Matthieu Latapy, Tiphaine Viard, and Clémence Magnien. 2018. Stream graphs
and link streams for the modeling of interactions over time. Soc. Netw. Anal. Min.
8, 1 (2018), 61:1–61:29.[29] Jure Leskovec and Andrej Krevl. last checked on October 4, 2022. SNAP Datasets:
Stanford Large Network Dataset Collection. http://snap.stanford.edu/data.
[30] Laishui Lv, Kun Zhang, Ting Zhang, Dalal Bardou, Jiahui Zhang, and Ying Cai.
2019. PageRank centrality for temporal networks. Physics Letters A 383, 12 (2019),
1215–1222.
[31] O. Michail. 2016. An Introduction to Temporal Graphs: An Algorithmic Perspec-
tive. Internet Mathematics 12, 4 (2016), 239–280.
[32] Jacob Moreno. 1934. Who Shall Survive? A new approach to the problem of human
interrelations. Nervous and Mental Disease Publishing Co.
[33] Lutz Oettershagen and Petra Mutzel. 2020. Efficient top-k temporal closeness
calculation in temporal networks. In 2020 IEEE International Conference on Data
Mining (ICDM). IEEE, 402–411.
[34] Lutz Oettershagen, Petra Mutzel, and Nils M. Kriege. 2022. Temporal Walk
Centrality: Ranking Nodes in Evolving Networks. In WWW ’22: The ACM Web
Conference 2022, Virtual Event, Lyon, France, April 25 - 29, 2022. ACM, 1640–1650.
[35] Matteo Riondato and Eli Upfal. 2018. ABRA: Approximating Betweenness Cen-
trality in Static and Dynamic Graphs with Rademacher Averages. ACM Trans.
Knowl. Discov. Data 12, 5 (2018), 61:1–61:38. https://doi.org/10.1145/3208351
[36] Ryan A. Rossi and Nesreen K. Ahmed. last checked on October 4, 2022. Network
Repository. https://networkrepository.com.
[37] Polina Rozenshtein and Aristides Gionis. 2016. Temporal pagerank. In Joint
European Conference on Machine Learning and Knowledge Discovery in Databases.
Springer, 674–689.
[38] Maciej Rymar, Hendrik Molter, André Nichterlein, and Rolf Niedermeier. 2023.
Towards Classifying the Polynomial-Time Solvability of Temporal Betweenness
Centrality. J. Graph Algorithms Appl. 27, 3 (2023), 173–194.
[39] Diego Santoro and Ilie Sarpe. 2022. ONBRA: Rigorous Estimation of the Temporal
Betweenness Centrality in Temporal Networks. In WWW ’22: The ACM Web
Conference 2022, Virtual Event, Lyon, France, April 25 - 29, 2022. ACM, 1579–1588.
[40] Diego Santoro and Ilie Sarpe. last checked on January 22, 2024. ONBRA: Rigorous
Estimation of the Temporal Betweenness Centrality in Temporal Networks. https:
//github.com/iliesarpe/onbra.
[41] Nicola Santoro, Walter Quattrociocchi, Paola Flocchini, Arnaud Casteigts, and
Frédéric Amblard. 2011. Time-Varying Graphs and Social Network Analysis:
Temporal Indicators and Metrics. CoRR abs/1102.0629 (2011).
[42] David Schoch. last checked on February 5, 2024. Periodic Table of Network
Centrality. http://schochastics.net/sna/periodic.html.
[43] David Schoch, Thomas W. Valente, and Ulrik Brandes. 2017. Correlations among
centrality indices and a class of uniquely ranked graphs. Soc. Networks 50 (2017),
46–54.
[44] Frédéric Simard, Clémence Magnien, and Matthieu Latapy. 2023. Computing
Betweenness Centrality in Link Streams. J. Graph Algorithms Appl. 27, 3 (2023),
195–217.
[45] João L. Sobrinho. 2005. An algebraic theory of dynamic network routing.
IEEE/ACM Trans. Netw. 13, 5 (2005), 1160–1173.
[46] João L. Sobrinho and Timothy G. Griffin. 2010. Routing in Equilibrium. In 19th
International Symposium on Mathematical Theory of Networks and System . 941–
947.
[47] Ioanna Tsalouchidou, Ricardo Baeza-Yates, Francesco Bonchi, Kewen Liao, and
Timos Sellis. 2020. Temporal betweenness centrality in dynamic graphs. Int. J.
Data Sci. Anal. 9, 3 (2020), 257–272.
[48] Sebastiano Vigna. 2015. A Weighted Correlation Index for Rankings with Ties. In
Proceedings of the 24th International Conference on World Wide Web, WWW 2015,
Florence, Italy, May 18-22, 2015, Aldo Gangemi, Stefano Leonardi, and Alessandro
Panconesi (Eds.). ACM, 1166–1176. https://doi.org/10.1145/2736277.2741088
[49] Huanhuan Wu, James Cheng, Yiping Ke, Silu Huang, Yuzhen Huang, and Hejun
Wu. 2016. Efficient Algorithms for Temporal Path Computation. IEEE Trans.
Knowl. Data Eng. 28, 11 (2016), 2927–2942.
[50] Tianming Zhang, Yunjun Gao, Jie Zhao, Lu Chen, Lu Jin, Zhengyi Yang, Bin Cao,
and Jing Fan. 2024. Efficient Exact and Approximate Betweenness Centrality
Computation for Temporal Graphs. In Proceedings of the ACM on Web Conference
2024. 2395–2406.
A THE GENERAL ALGORITHM
In this section we show how the algorithm for the restless SFo
can be generalised in order to deal with Fa,Fo,ShandSFawalks.
To this aim, we first introduce the notion of cost and target cost
structures and we extend the results of Section 3 to these structures
(all the definitions concerning the Shand the SFobetweenness can
be appropriately adapted to the any other optimality criterion case
and all the results proved for the SFobetweenness can be proved
also for the corresponding betweenness).
 
172Making Temporal Betweenness Computation Faster and Restless KDD ’24, August 25–29, 2024, Barcelona, Spain
C𝛾(𝑒) 𝑐1⊕𝑐2 𝑐1⪯𝑐2
All {0} 0 0 true
Shortest N 1 𝑐1+𝑐2 𝑐1≤𝑐2
Latest Z−dep(𝑒) 𝑐1 𝑐1≤𝑐2
Shortest latest Z×N(−dep(𝑒),1)(𝑐1[1],𝑐1[2]+𝑐2[2])𝑐1[1]<𝑐2[1]or(𝑐1[1]=𝑐2[1]and𝑐1[2]≤𝑐2[2])
Table 6: The 4 cost structures used in this paper
C𝐹𝑐1⪯𝐹𝑐2
Natural Z 𝑐1≤𝑐2
Lexicographic Z×N𝑐1[1]<𝑐2[1]or(𝑐1[1]=𝑐2[1]and𝑐1[2]≤𝑐2[2])
Table 7: The 2 target cost structures along with the TCfunctions used in this paper
Walk cost and target cost structures. We integrate a temporal
graph𝐺=(𝑉,𝐸,𝛽)with an algebraic cost structure(C,𝛾,⊕,⪯),
whereCis the set of possible cost values,𝛾is acost function 𝛾:𝐸→
C,⊕is acost combination function ⊕:C×C→C , and⪯is acost
total order with⪯⊆ C×C . For any two elements 𝑐1and𝑐2ofC, we
say that𝑐1=𝑐2if𝑐1⪯𝑐2and𝑐2⪯𝑐1both hold. We also define the
relation≺between the elements of Cas𝑐1≺𝑐2if and only if 𝑐1⪯𝑐2
and𝑐1≠𝑐2. For any walk 𝑊=⟨𝑒1,...,𝑒𝑘⟩, the cost function of𝑊
is recursively defined as follows: 𝛾(𝑊)=𝛾(⟨𝑒1,...,𝑒𝑘−1⟩)⊕𝛾(𝑒𝑘),
with𝛾(⟨𝑒1⟩)=𝛾(𝑒1)(in other words, the costs combine along
the walk according to the cost combination function). The cost
structure is supposed to satisfy the following strict right-isotonicity
property [8,45,46] (isotonicity for short): for any 𝑐1,𝑐2,𝑐∈Csuch
that𝑐1≺𝑐2, we have𝑐1⊕𝑐≺𝑐2⊕𝑐. This property implies the
following walk extension property: for any two walks 𝑊and𝑋
such that𝛾(𝑊)≺𝛾(𝑋)and for any temporal edge 𝑒which can
extend both 𝑊and𝑋, we have𝛾(𝑊.𝑒)≺𝛾(𝑋.𝑒)(that is, if several
walks are extended by a given temporal edge 𝑒, then the best cost
is obtained only by extending a walk with minimum cost). The
isotonicity property also implies a prefix property, which is similar
to the prefix-optimality property introduced in [38].
Fact 3. Let𝐺=(𝑉,𝐸,𝛽)be a temporal graph and (C,𝛾,⊕,⪯)be
a cost structure satisfying the isotonicity property. For any node 𝑠∈𝑉,
if a walk𝑊with last temporal edge 𝑓∈𝐸has minimum cost among
the𝑠𝑓-walks, and 𝑒∈𝐸is a temporal edge of 𝑊, then the prefix of
𝑊up to the temporal edge 𝑒has minimum cost among the 𝑠𝑒-walks.
In this paper, we will consider the four cost structures shown in
Table 6. It is easy to verify that all of them satisfy the isotonicity
property. For example, let us prove that the shortest latest cost
structure satisfies the isotonicity property. Suppose that 𝑐1,𝑐2∈
Z×Nsatisfy𝑐1≺𝑐2: this implies that either 𝑐1[1]>𝑐2[1]or𝑐1[1]=
𝑐2[1]∧𝑐1[2]<𝑐2[2]. For any𝑐∈Z×N,𝑐1⊕𝑐=(𝑐1[1],𝑐1[2]+𝑐[2])
and𝑐2⊕𝑐=(𝑐2[1],𝑐2[2]+𝑐[2]). If𝑐1[1]>𝑐2[1], then𝑐1⊕𝑐≺𝑐2⊕𝑐.
Otherwise (that is, 𝑐1[1]=𝑐2[1]and𝑐1[2]<𝑐2[2]),𝑐1[2]+𝑐[2]<
𝑐2[2]+𝑐[2]and, thus,𝑐1⊕𝑐≺𝑐2⊕𝑐.
Similar to the algorithms introduced in Section 4, the general
algorithm consists of three phases. Given a temporal graph 𝐺=
(𝑉,𝐸,𝛽)and a cost structure (C,𝛾,⊕,⪯)among the ones in Table 6,
in the first phase (that is, the forward phase), the algorithm counts,
for any source node 𝑠and for any temporal edge 𝑒, the number of𝑠𝑒-walks which are optimal with respect to the walk cost function 𝛾.
In the other two phases (that is, the intermediate and the backward
phase), the algorithm makes use of a target (orfinal )cost structure
(C𝐹,⪯𝐹), whereC𝐹is the set of possible target cost values and⪯𝐹
is atarget cost total order with⪯𝐹⊆ C𝐹×C𝐹. For any two elements
𝑐1and𝑐2ofC𝐹, we say that 𝑐1=𝐹𝑐2if𝑐1⪯𝐹𝑐2and𝑐2⪯𝐹𝑐1both
hold. We also define the relation ≺𝐹between the elements of C𝐹
as𝑐1≺𝐹𝑐2if and only if 𝑐1⪯𝐹𝑐2and𝑐1≠𝐹𝑐2.
Costs and target costs are related through a function TC:𝐸×C→
C𝐹that associates to a temporal edge and a cost, a corresponding
target cost. This function needs to satisfy the following increasing
property: for any 𝑐1,𝑐2∈C such that𝑐1≺𝑐2and for any 𝑒∈𝐸,
we have that TC(𝑒,𝑐1)≺𝐹TC(𝑒,𝑐2). In this paper, we will consider
the two target cost structures shown in Table 7, which together
with a combination of one of the cost structures of Table 6 and an
appropriate TCfunction will allow us to deal all optimality criteria.
For example, Fawalks can be modeled by using the latest cost
structure of Table 6 that associates to a walk the opposite of its
departure time as a cost with later time being considered as lower
cost: for that, it suffices to define the cost of a temporal edge as the
opposite of its departure time and a combination function ⊕that
returns its first argument. The duration of a walk 𝑊with cost𝑐
and ending with a temporal edge 𝑒=(𝑢,𝑣,𝜏,𝜆)is then obtained
by using the natural target cost (see Table 7) and the target cost
Optimality
criterion Cost T
arget cost TC(𝑒
,𝑐)
Shortest Shortest Natural 𝑐
For
emost All Natural arr(𝑒)
Latest Latest Natural 𝑐
Fastest Latest Natural arr(𝑒)
+𝑐
Shortest foremost Shortest Le
xicographic (arr(𝑒),
𝑐)
Shortest latest Shortest
latest Le
xicographic 𝑐
Shortest
fastest Shortest
latest Le
xicographic(arr(𝑒)
+𝑐[1],𝑐[2])
Table 8: Optimality criteria in terms of cost and target cost
structures. In the last column of the table, the semantic of
𝑐is the following: number of hops for Shand for SFo, the
opposite of the departure time for latest and for Fathe array
whose first entry is the opposite of the departure time and
whose second entry is the number of hops for shortest latest
andSFa.
 
173KDD ’24, August 25–29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
Algorithm 2: compute𝑏𝑠,𝑒of all temporal edges
input : temporal graph 𝐺=(𝑉,𝐸,𝛽)(represented by 𝐸depand𝐸arr),𝑠∈𝑉, cost structure Γ=(C,𝛾,⊕,⪯), target cost structure Θ=(C𝐹,⪯𝐹),
and target cost function TC
output :𝑠-temporal betweenness 𝑏𝑠,𝑒of each𝑒∈𝐸w.r.t.Γ,Θ, and TC
1Compute the lists 𝐸dep
nodeand𝐸arr
dep;
2foreach𝑣∈𝑉do𝑙[𝑣]:=1;𝑟[𝑣]:=0;I[𝑣]:=∅;
3foreach𝑒∈𝐸do𝐿[𝑒]:=|𝐸𝑎𝑟𝑟|+1;𝑅[𝑒]:=0;𝐶[𝑒]:=∞Γ;Σ[𝑒]:=0;
4foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo
5if𝐸arr
dep[𝑒]≥𝑙[𝑢]then Finalize(𝑢,𝐸arr
dep[𝑒]);
6if𝑢=𝑠then if𝛾(𝑒)≺𝐶[𝑒]then𝐶[𝑒]:=𝛾(𝑒);Σ[𝑒]:=1;else if𝛾(𝑒)=𝐶[𝑒]then Σ[𝑒]:=Σ[𝑒]+1;
7if𝐶[𝑒]≠∞Γthen
8𝑎:=𝑙[𝑣];while𝑎≤|𝐸dep
node[𝑣]|∧dep(𝐸arr[𝐸dep
node[𝑣][𝑎]])<𝜏+𝜆do𝑎:=𝑎+1;
9𝑏:=𝑟[𝑣];while𝑏<|𝐸dep
node[𝑣]|∧dep(𝐸arr[𝐸dep
node[𝑣][𝑏+1]])≤𝜏+𝜆+𝛽do𝑏:=𝑏+1;
10 Finalize(𝑣,𝑎−1);𝑙𝑐:=max(𝑎,𝑟[𝑣]+1);
11 while|I[𝑣]|>0∧𝐶[𝑒]≺last(I[𝑣]).𝑐do𝑄:=poplast(I[𝑣]);𝑙𝑐:=𝑄.𝑙;foreach𝑓∈𝑄.𝑃do𝑅[𝑓]:=𝑎−1;
12 if|I[𝑣]|>0∧last(I[𝑣]).𝑐=𝐶[𝑒]then𝑄:=last(I[𝑣]);𝑄.𝑟:=𝑏;𝑄.𝜂 :=𝑄.𝜂+Σ[𝑒];𝑄.𝑃 :=𝑄.𝑃∪{𝑒};𝐿[𝑒]:=𝑄.𝑙;
13 else if𝑙𝑐≤𝑏then𝐿[𝑒]:=𝑙𝑐;pushlast(I[𝑣],(𝑙𝑐,𝑏,𝐶[𝑒],{𝑒},Σ[𝑒]));
14𝑅[𝑒]:=𝑏;𝑟[𝑣]:=𝑏;
15foreach𝑣∈𝑉do𝑐∗[𝑣]=∞Θ;𝜎∗[𝑣]=0;𝛿[𝑣]:=0;
16𝑐∗[𝑠]:=0Θ;𝜎∗[𝑠]:=1;foreach𝑒∈𝐸doΣ∗[𝑒]:=0;𝑏[𝑒]:=0;
17foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo if(𝐶[𝑒]<∞∧ TC(𝑒,𝐶[𝑒])≺𝐹𝑐∗[𝑣])then𝑐∗[𝑣]:=TC(𝑒,𝐶[𝑒]);
18foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈𝐸arrdo if TC(𝑒,𝐶[𝑒])=𝐹𝑐∗[𝑣]then Σ∗[𝑒]:=Σ[𝑒];𝜎∗[𝑣]:=𝜎∗[𝑣]+Σ[𝑒];
19foreach𝑒=(𝑢,𝑣,𝜏,𝜆)∈reverse(𝐸arr)do
20 if0<𝐿[𝑒]≤𝑅[𝑒]then
21 foreach𝑓∈𝐸dep
node[𝑣][max(𝑙[𝑣],𝑅[𝑒]+1):𝑟[𝑣]]do if𝑣≠𝑠∨𝐶[𝑓]=𝐶[𝑒]⊕𝛾(𝑓)then𝛿[𝑣]:=𝛿[𝑣]−𝑏[𝑓]/Σ[𝑓];
22𝑟[𝑣]:=𝑅[𝑒];foreach𝑓∈𝐸dep
node[𝑣][𝐿[𝑒]: min(𝑅[𝑒],𝑙[𝑣]−1)]do if𝑣≠𝑠∨𝐶[𝑓]=𝐶[𝑒]⊕𝛾(𝑓)then𝛿[𝑣]:=𝛿[𝑣]+𝑏[𝑓]/Σ[𝑓];
23𝑙[𝑣]:=𝐿[𝑒];𝑏[𝑒]:=Σ[𝑒]𝛿[𝑣];
24 ifΣ∗[𝑒]>0then𝑏[𝑒]:=𝑏[𝑒]+Σ∗[𝑒]/𝜎∗[𝑣];
25return𝑏
26Finalize(𝑣,𝑗):
27 while|I[𝑣]|>0∧first(I[𝑣]).𝑙≤𝑗do
28𝑄:=first(I[𝑣]);𝑞𝑙:=𝑄.𝑙;𝑞𝜂:=𝑄.𝜂;
29 while|𝑄.𝑃|>0∧𝑅[first(𝑄.𝑃)]≤𝑗do
30𝑒:=popfirst(𝑄.𝑃);foreach𝑓∈𝐸dep
node[𝑣][𝑞𝑙:𝑅[𝑒]]do𝐶[𝑓]:=𝑄.𝑐⊕𝛾(𝑓);Σ[𝑓]:=𝑞𝜂;
31𝑞𝜂:=𝑄.𝜂−Σ[𝑒];𝑞𝑙:=𝑅[𝑒]+1;foreach𝑓∈𝐸dep
node[𝑣][𝑞𝑙: min(𝑗,𝑄.𝑟)]do𝐶[𝑓]:=𝑄.𝑐⊕𝛾(𝑓);Σ[𝑓]:=𝑞𝜂;
32 if𝑗≥𝑄.𝑟then popfirst(I[𝑣]);else𝑄.𝑙:=𝑗+1;𝑄.𝜂 :=𝑞𝜂;break;
33𝑙[𝑣]:=𝑗+1;
function TC(𝑒,𝑐)=arr(𝑒)+𝑐, since arr(𝑒)=𝜏+𝜆equals arr(𝑊)
and𝑐=−dep(𝑊). As shown in Table 8, any of the walk optimality
criteria defined in Section 3 can be modelled by an appropriate
combination of the introduced cost structures, target cost structures,
and target functions.
Given a cost structure Γ=(C,𝛾,⊕,⪯)and a target cost structure
Θ=(C𝐹,⪯𝐹)along with a target cost function TC, we say that a
temporal𝑠𝑡-walk𝑊isΘ-optimal if, for any𝑠𝑡-walk𝑋, we have
TC(𝑒,𝛾(𝑊))⪯𝐹TC(𝑓,𝛾(𝑋)), where𝑒and𝑓are the last temporal
edge of𝑊and𝑋, respectively. We also say that a temporal 𝑠𝑒-walk
𝑊isΓ-optimal if, for any 𝑠𝑒-walk𝑋, we have𝛾(𝑊)⪯𝛾(𝑋). Note
that a Γ-optimal𝑠𝑒-walk𝑋not necessarily is a Θ-optimal𝑠𝑡-walk
where𝑡is the head of 𝑒. The opposite, instead, is true. Indeed, given
a temporal graph 𝐺=(𝑉,𝐸,𝛽), a cost structure(C,𝛾,⊕,⪯), a targetcost structure(C𝐹,⪯𝐹), and a TCfunction, if𝑊is aΘ-optimal𝑠𝑡-
walk (for some 𝑠,𝑡∈𝑉) and𝑒is the last temporal edge of 𝑊, then
𝑊is aΓ-optimal𝑠𝑒-walk.
The general algorithm. The pseudo-code of the general algorithm
for any of optimality criteria which fits in our framework is shown
in Algorithm 2. The pseudo-code uses the symbol ∞Γand∞Θ
to denote the natural infinite value of a cost structure Γand a
target cost structure Θ. It also uses the symbol 0Θto denote the
natural minimum value of a target cost structure Θ. Moreover, it
has to be observed that the actual code includes, in the backward
phase, a control structure which allows us to deal with numerical
approximation problems. This structure is not needed if big integer
and big rational data structures are used, which, on the other hand,
may slower the execution of the algorithm by a factor between two
and four.
 
174