Reinforcement Learning with LTL and ω-Regular
Objectives via Optimality-Preserving Translation to
Average Rewards
Xuan-Bach Le1∗Dominik Wagner1∗
Leon Witzman1Alexander Rabinovich2Luke Ong1
1NTU Singapore2Tel Aviv University
{bach.le,dominik.wagner,luke.ong}@ntu.edu.sg
witz0001@e.ntu.edu.sg rabinoa@tauex.tau.ac.il
Abstract
Linear temporal logic (LTL) and, more generally, ω-regular objectives are alterna-
tives to the traditional discount sum and average reward objectives in reinforcement
learning (RL), offering the advantage of greater comprehensibility and hence ex-
plainability. In this work, we study the relationship between these objectives. Our
main result is that each RL problem for ω-regular objectives can be reduced to
a limit-average reward problem in an optimality-preserving fashion, via (finite-
memory) reward machines. Furthermore, we demonstrate the efficacy of this
approach by showing that optimal policies for limit-average problems can be found
asymptotically by solving a sequence of discount-sum problems approximately.
Consequently, we resolve an open problem: optimal policies for LTL and ω-regular
objectives can be learned asymptotically.
1 Introduction
Reinforcement learning (RL) is a machine learning paradigm whereby an agent aims to accomplish
a task in a generally unknown environment [ 37]. Traditionally, tasks are specified via a scalar
reward signal obtained continuously through interactions with the environment. These rewards are
aggregated over entire trajectories either through averaging or by summing the exponentially decayed
rewards. However, in many applications, there are no reward signals that can naturally be extracted
from the environment. Moreover, reward signals that are supplied by the user are prone to error in
that the chosen low-level rewards often fail to accurately capture high-level objectives. Generally,
policies derived from local rewards-based specifications are hard to understand because it is difficult
to express or explain their global intent.
As a remedy, it has been proposed to specify tasks using formulas in Linear Temporal Logic (LTL)
[41,30,9,38,15,34,14] orω-regular languages more generally [ 30]. In this framework, the aim is
to maximise the probability of satisfying a logical specification. LTL can precisely express a wide
range of high-level behavioural properties such as liveness (infinitely often P), safety (always P),
stability (eventually always P), and priority ( PthenQthenT).
Motivated by this, a growing body of literature study learning algorithms for RL with LTL and
ω-regular objectives (e.g. [ 41,15,30,7,32,20,21,16]). However, to the best of our knowledge, all
of these approaches may fail to learn provably optimal policies without prior knowledge of a generally
unknown parameter such as the optimal ϵ-return mixing time [ 15] or the ϵ-recurrence time [ 30],
*These authors contributed equally to this work.
38th Conference on Neural Information Processing Systems (NeurIPS 2024).which depend on the (unavailable) transition probabilities of the MDP. Moreover, it is known that
neither LTL nor (limit) average reward objectives are PAC (probably approximately correct) learnable
[2]. Consequently, approximately optimal policies can only possibly be found asymptotically but not
in bounded time.1
In this work, we pursue a different strategy: rather than solving the RL problem directly, we study
optimality-preserving translations [ 2] from ω-regular objectives to more traditional rewards, in
particular, limit-average rewards. This method offers a significant advantage: it enables the learning
of optimal policies for ω-regular objectives by solving a single more standard problem, for which we
can leverage existing off-the-shelf algorithms (e.g. [ 26,15,30]). In this way, all future advances—in
both theory and practice—for these much more widely studied problems carry over directly, whilst
still enjoying significantly more explainable and comprehensible specifications. It is well-known
that such a translation from LTL to discounted rewards is impossible [2]. Intuitively, this is because
the latter cannot capture infinite horizon tasks such as reachability or safety [ 2,42,19]. Hence, we
instead investigate translations to limit-average rewards in this paper.
Contributions
We study reinforcement learning of ω-regular and LTL objectives in Markov decision processes
(MDPs) with unknown probability transitions, translations to limit-average reward objectives and
learning algorithms for the latter. In detail:
1.We prove a negative result (Proposition 4): in general it is not possible to translate ω-regular
objectives to limit average objectives in an optimality-preserving manner if rewards are
memoryless (i.e., independent of previously performed actions, sometimes called history-
free or Markovian).
2.On the other hand, our main result (Theorem 12) resolves Open Problem 1 in [ 2]: such an
optimality-preserving translation is possible if the reward assignment may use finite memory
as formalised by reward machines [23, 24].
3. To underpin the efficacy of our reduction approach, we provide the first convergence proof
(Theorem 16) of an RL algorithm (Algorithm 1) for average rewards. To the best of our
knowledge (and as indicated by [ 13]), this is the first proof without assumptions on the
induced Markov chains . In particular, the result applies to multichain MDPs, which our
translation generally produces, with unknown probability transitions. Consequently, we also
resolve Open Problem 4 of [ 2]: RL for ω-regular and LTL objectives can be learned in the
limit (Theorem 18).
Outline. We start by reviewing the problem setup in Section 2. Motivated by the impossibility
result for simple reward functions, we define reward machines (Section 3). In Section 4 we build
intuition for the proof of our main result in Section 5. Thereafter, we demonstrate that RL with
limit-average, ω-regular and LTL objectives can be learned asymptotically (Section 6). Finally, we
review related work and conclude in Section 7.
2 Background
Recall that a Markov Decision Process (MDP) is a tuple M= (S, A, s 0, P)where Sis a finite
set of states, s0∈Sis the initial state, Ais the finite set of actions and P:S×A×S→[0,1]
is the probability transition function such thatP
s′∈SP(s, a, s′) = 1 for every s∈Sanda∈A.
MDPs may be graphically represented; see e.g. Fig. 1a. We let Runs fi(S, A) =S×(A×S)∗and
Runs( S, A) = (S×A)ωdenote the set of finite runs and the set of infinite runs in Mrespectively.
Apolicy π: Runs fi(S, A)→ D(A)maps finite runs to distributions over actions. We let Π(S, A)
denote the set of all such policies. A policy πismemoryless ifπ(s0a0. . . s n) =π(s′
0a′
0. . . s′
m)for
all finite runs s0a0. . . s nands′
0a′
0. . . s′
msuch that sn=s′
m. For each MDP Mand policy π, there
is a natural induced probability measure DM
πon its runs.
The desirability of policies for a given MDP Mcan be expressed as a function J: Π(S, A)→R.
Much of the RL literature focuses on discounted-sum JM
Rγand limit-average reward objectives JM
Ravg,
1Formally, for some ϵ, δ > 0it is impossible to learn ϵ-approximately optimal policies with probability 1−δ
in finite time.
2s0 start s1a
b
b
(a) An MDP where all transitions occur with
probability 1,λ(s0, b, s 1) ={p}and the rest
are labeled with ∅.q0 start q1 q2∅
{p}∅
{p}∗
(b) A DRA, where F:={({q1},∅)}, for the objective
to visit the petrol station pexactly once.
Figure 1: Examples of an MDP and DRA.
which lift a reward function R:S×A×S→Rfor single transitions to runs ρ=s0a0s1a1. . .as
follows:
JM
Rγ(π) :=Eρ∼DMπ"∞X
i=0γi·ri#
JM
Ravg(π) := lim inf
t→∞Eρ∼DMπ"
1
t·t−1X
i=0ri#
where ri=R(si, ai, si+1)andγ∈(0,1)is the discount factor .
ω-Regular Objectives. ω-regular objectives (which subsume LTL objectives) are an alternative to
these traditional objectives. Henceforth, we fix an alphabet APand a label function λ:S×A×S→
2APfor transitions, where 2Xis the power set of a set X. Each run ρ=s0a0s1a1s2. . .induces a
sequence of labels λ(ρ) =λ(s0, a0, s1)λ(s1, a1, s2). . .. Thus, for a set L⊆(2AP)ωof “desirable”
label sequences we can consider the probability of a run’s labels being in that set: Pρ∼DMπ[λ(ρ)∈L].
Example 1. For instance, an autonomous car may want to “visit a petrol station exactly once” to
conserve resources (e.g. time or petrol). Consider the MDP in Fig. 1a where the state s1represents a
petrol station. We let AP={p}(pfor petrol), λ(s0, b, s 1) ={p}, and the rest are labeled with ∅.
The desirable label sequences are L={λ1λ2··· | for exactly one i∈N, λi={p}}.
In this work, we focus on Lwhich are ω-regular languages. It is well known that ω-regular languages
are precisely the languages recognised by Deterministic Rabin Automata (DRA) [27, 29]:
Definition 2. A DRA is a tuple A= (Q,2AP, q0, δ, F)where Qis a finite state set, 2APis the
alphabet, q0∈Qis the initial state, δ:Q×2AP→Qis the transition function, and F=
{(A1, R1), . . . , (An, Rn)}, where Ai, Ri⊆Q, is the accepting condition. Let ρ∈(2AP)ωbe an
infinite run and InfS(ρ)the set of states visited infinitely often by ρ. We say ρis accepted by Aif
there exists some (Ai, Ri)∈Fsuch that ρvisits some state in Aiinfinitely often whilst visiting
every state in Rifinitely often, i.e. InfS(ρ)∩Ai̸=∅andInfS(ρ)∩Ri=∅.
For example, the objective in Example 1 may be represented by the DRA in Fig. 1b.
Thus, the desirability of πis the probability of πgenerating an accepting sequence in the DRA A:
JM
A(π) :=Pρ∼DMπ[λ(ρ)is accepted by the automaton A] (1)
Remarks. The class of ω-regular languages subsumes languages expressed by Linear Temporal
Logic (LTL, see e.g. [ 4, Ch. 5]), a logical framework in which e.g. reachability (eventually P,♢P),
safety (always P,□P) and reach-avoid (eventually Pwhilst avoiding Q,(¬Q)UP) properties can
be expressed concisely and intuitively. The specification of our running Example 1 to visit the petrol
station exactly once can be expressed as the LTL formula (¬p)U(p∧□¬p), where Qdenotes
“Qholds at the next step”. Furthermore, our label function λ, which maps transitions to labels, is
more general than other definitions (e.g. [ 41,15,30]) instead mapping states to labels. As a result,
we are able to articulate properties that involve actions, such as “to reach the state swhile avoiding
taking the action a”.
Optimality-Preserving Specification Translations. Rather than solving the problem of synthe-
sising optimal policies for Eq. (1) directly, we are interested in reducing it to more traditional RL
3problems and applying off-the-shelf RL algorithms to find optimal policies. To achieve this, the
reduction needs to be optimality preserving2:
Definition 3 ([2]).Anoptimality-preserving specification translation from ω-regular objectives to
limit-average rewards is a computable function mapping each tuple (S, A, λ, A)toR(S,A,λ, A)s.t.
policies maximising JM
Ravgalso maximise JM
A, where R:=R(S,A,λ, A)
for every MDP M= (S, A, s 0, P), label function λ:S×A×S→2APand DRA A.
We stress that since the probability transition function Pis generally not known, the specification
translation may not depend on it.
3 Negative Result and Reward Machines
Reward functions emit rewards purely based on the transition being taken without being able to take
the past into account. On the other hand, DRAs have finite memory. Therefore, there cannot generally
be optimality-preserving translations from ω-regular objectives to limit average rewards provided by
reward functions:
Proposition 4. There is an MDP Mand an ω-regular language Lfor which it is impossible to find
a reward function R:S×A×S→Rsuch that every JM
Ravg-optimal policy of Malso maximises
the probability of membership in L.
Remarkably, this rules out optimality-preserving specification translations even if transition probabili-
ties are fully known3.
Proof. Consider the deterministic MDP in Fig. 1a and the objective of Example 1 “to visit s1exactly
once” expressed by the DRA Ain Fig. 1b. Assume towards contradiction there exists a reward
function R:S×A×S→Rsuch that optimal policies w.r.t. JM
Ravgmaximise acceptance by A. Note
that every policy π∗maximising acceptance by the DRA induces the run s0(as0)nbs1bs0(as0)ω
for some n∈N, andJM
A(π∗) = 1 . Thus, its limit-average reward is JM
Ravg(π∗) =R(s0, a, s 0).
Now, consider the policy πalways selecting action awith probability 1. As the run induced by π
iss0(as0)ω, we deduce that JM
A(π) = 0 andJM
Ravg(π) =R(s0, a, s 0) =JM
Ravg(π∗), which is a
contradiction since πis notJM
A-optimal.
Since simple reward functions lack the expressiveness to capture ω-regular objectives, we employ a
generalisation, reward machines [23, 24], whereby rewards may also depend on an internal state:
Definition 5. Areward machine (RM) is a tuple R= (U, u 0, δu, δr)where Uis a finite set of
states, u0∈Uis the initial state, δr:U×(S×A×S)→Ris the reward function, and
δu:U×(S×A×S)→Uis the update function.
Intuitively, a RM Rutilises the current transition to update its states through δuand assigns the
rewards through δr. For example, Fig. 2a depicts a reward machine for the MDP of Fig. 1a, where
the states count the number of visits to s1(0 times, once, more than once).
Letρ=s0a0s1···be an infinite run. Since δuis deterministic, it induces a sequence u0u1. . .of
states in R, where ei= (si, ai, si+1)andui+1=δu(ui, ei). The limit-average reward of a policy π
is defined as:
JM
Ravg(π) := lim inf
t→∞Eρ∼DMπ"
1
tt−1X
i=0δr(ui, ei)#
It is seen that limit-average optimal policies π∗for the MDP in Fig. 1a and the RM in Fig. 2a
eventually select action bexactly once in state s0to achieve JM
Ravg(π∗) = 1 .
In the following two sections, we present a general translation from ω-regular languages to limit-
average reward machines, and we show that our translation is optimality-preserving (Theorem 12).
2This definition makes sense both for the case of reward functions R(S,A,λ, A):S×A×S→Rand reward
machines (introduced in the subsequent section).
3In Appendix A we show another negative result (Proposition 19): even for a strict subset of ω-regular
specifications such translations are impossible.
4u0 start u1 u2(s0, a, s 0)/0
(s1, b, s 0)/0(s0, b, s 1)/0(s0, a, s 0)/1
(s1, b, s 0)/0(s0, b, s 1)/0∗/0
(a) A reward machine for the objective of visiting the petrol
station exactly once. (The rewards are given following “/”.)(s0, q0) start (s0, q1) (s0, q2)
(s1, q0) (s1, q1) (s1, q2)ba
bba
bba, b
(b) Product MDP for Fig. 1, where all
transitions have probability 1andFM:=
{({(s0, q1),(s1, q1)},∅)}.
Figure 2: A reward machine and the product MDP for the running Example 1.
Remarks. Our definition of RM is more general than the one presented in [ 23,24], where δ′
u:
U→[S×A×S→R]andδ′
r:U×2AP→U. Note that (δ′
u, δ′
r)can be reduced to (δu, δr)
by expanding the state space of the RM to include the previous state and utilising the inverse label
function λ−1. It is worth pointing out that Theorem 12 does not contradict a negative result in [ 2]
regarding the non-existence of an optimality-preserving translation from LTL constraints to abstract
limit-average reward machines (where only the label of transitions is provided to δuandδr).
4 Warm-Up: Transitions with Positive Probability are Known
To help the reader gain intuition about our construction, we first explore the situation where the support
{(s, a, s′)∈S×A×S|P(s, a, s′)>0}of the MDP’s transition function is known. Crucially,
we do not assume that the magnitude of these (non-zero) probabilities are known. Subsequently, in
Section 5, we fully eliminate this assumption.
This assumption allows us to draw connections between our problem and a familiar scenario in
probabilistic model checking [ 4, Ch. 10], where the acceptance problem for ω-regular objectives can
be transformed into a reachability problem. Intuitively, our reward machine monitors the state of the
DRA and provides reward 1if the MDP and the DRA are in certain “good” states ( 0otherwise).
For the rest of this section, we fix an MDP without transition function (S, A, s 0), a set of possible
transitions E⊆S×A×S, a label function λ:S×A×S→2APand a DRA A= (Q,2AP, q0, δ, F).
Our aim is to find a reward machine Rsuch that for every transition function Pcompatible with E
(formally: E={(s, a, s′)|P(s, a, s′)>0}), optimal policies for limit-average rewards are also
optimal for the acceptance probability of the DRA A.
4.1 Product MDP and End Components
First, we form the product MDP M ⊗ A (e.g. [ 41,15]), which synchronises the dynamics of the
MDPMwith the DRA A. Formally, M ⊗ A = (V, A, v 0,∆, FM)where V=S×Qis the set of
states, Ais the set of actions, v0= (s0, q0)is the initial state. The transition probability function
∆ :V×A×V→[0,1]satisfies ∆(v, a, v′) =P(s, a, s′)given that v= (s, q),v′= (s′, q′),
andδ(q, λ(s, a, s′)) = q′. The accepting condition is FM={(A′
1, R′
1),(A′
2, R′
2), . . .}where
A′
i=S×Ai,R′
i=S×Ri, and (Ai, Ri)∈F. A run ρ= (s0, q0)a0···is accepted by M ⊗ A if
there exists some (A′
i, R′
i)∈FMsuch that InfV( ρ)∩A′
i̸=∅andInfV( ρ)∩R′
i=∅, where InfV is
the set of states (s, v)in the product MDP visited infinitely often by ρ.
Note that product MDPs have characteristics of both MDPs and DRAs which neither possesses in
isolation: transitions are generally probabilistic and there is a notation of acceptance of runs. For
example, the product MDP for Fig. 1 is shown in Fig. 2b. Due to the deterministic nature of the DRA
A, every run ρinMgives rise to a unique run ρ⊗inM ⊗ A . Crucially, for every policy π,
Pρ∼DMπ[ρis accepted by A] =Pρ∼DMπ[ρ⊗is accepted by M ⊗ A ] (2)
We make use of well-known almost-sure characterisation of accepting runs via the notion of accepting
end components:
5Definition 6. Anend component (EC) of M ⊗ A = (V, A, v 0,∆, FM)is a pair (T,Act) where
T⊆VandAct : T→2Asatisfies the following conditions
1. For every v∈Tanda∈Act(v), we haveP
v′∈T∆(v, a, v′) = 1 , and
2.The graph (T,→Act)is strongly connected, where v→Actv′iff∆(v, a, v′)>0for some
a∈Act(v).
(T,Act) is an accepting EC (AEC) ifT∩A′
i̸=∅andT∩R′
i=∅for some (A′
i, R′
i)∈FM.
Intuitively, an EC is a strongly connected sub-MDP. For instance, for the product MDP in
Fig. 2b there are five end components, ({(s0, q0)},(s0, q0)7→ {a}),({(s0, q1)},(s0, q1)7→ {a}),
({(s0, q2)},(s0, q2)7→ {a}),({(s0, q2)},(s0, q2)7→ {b})and({(s0, q2)},(s0, q2)7→ {a, b}).
({(s0, q1)},(s0, q1)7→ {a})is its only accepting end component.
It turns out that, almost surely, a run is accepted iff it enters an accepting end component and never
leaves it [ 1]. Therefore, a natural idea for a reward machine is to use its state to keep track of the
stateq∈Qthe DRA is in and give reward 1 to transitions (s, a, s′)if(s, q)is in some AEC (and
0otherwise). Unfortunately, this approach falls short since the AEC may contain non-accepting
ECs, thus assigning maximal reward to sub-optimal policies.4As a remedy, we introduce a notion
of minimal AEC, and ensure that only runs eventually committing to one such minimal AEC get a
limit-average reward of 1.
Definition 7. An AEC (T,Act) is an accepting simple EC (ASEC) if|Act(v)|= 1for every v∈T.
LetC1= (T1,Act1), . . . ,Cn= (Tn,Actn)be a collection of ASECs covering all states in ASECs,
i.e. if (s, q)is in some ASEC then (s, q)∈T1∪ ··· ∪ Tn. In particular, n≤ |S×Q|is sufficient.
We can prove that every AEC contains an ASEC (see Lemma 20 in Appendix B). Consequently,
Lemma 8. Almost surely, if ρis accepted by Athenρ⊗reaches a state in some ASEC CiofM ⊗ A .
4.2 Reward Machine and Correctness
Next, to ensure that runs eventually commit to one such ASEC we introduce the following notational
shorthand: for (s, q)∈T1∪ ··· ∪ Tn, letC(s,q)= (T(s,q),Act(s,q))be the Ciwith minimal i
containing (s, q), i.e.C(s,q):=Cmin{1≤i≤n|(s,q)∈Ti}.
Intuitively, we give a reward of 1 if (s, q)is in one of the C1, . . . ,Cn. However, once an action is
performed which deviates from Act(s,q)no rewards are given thereafter, thus resulting in a limit
average reward of 0.
A state in the reward machine has the form q∈Q, keeping track of the state in the DRA, or ⊥, which
is a sink state signifying that in a state in C1, . . . ,Cnwe have previously deviated from Act(s,q).
Finally, we are ready to formally define the reward machine R=R(S,A,λ, A)exhibiting our specifi-
cation translation as (Q∪ {⊥} , q0, δu, δr), where
δu(u,(s, a, s′)) :=

⊥ ifu=⊥or 
(s, u)∈T1∪ ··· ∪ Tnanda̸∈Act(s,u)(s, u)
δ(u, λ(s, a, s′))otherwise
δr(u,(s, a, s′)) :=1ifu̸=⊥and(s, u)∈T1∪ ··· ∪ Tn
0otherwise
For our running example, this construction essentially yields the reward machine in Fig. 2a (with
some inconsequential modifications cf. Fig. 4 in Appendix B).
Theorem 9. For all transition probability functions Pwith support E, policies maximising the
limit-average reward w.r.t. Ralso maximise the acceptance probability of the DRA A.
This result follows immediately from the following (the full proof is presented in Appendix B):
4To illustrate this point, consider the product MDP ({s0, s1},{a, b}, s0, P, F )where P(s0, b, s 0) =
P(s0, a, s 1) =P(s1, a, s 0) = 1 andF={({s1},∅)}, i.e. the objective is to visit s1infinitely often.
6Lemma 10. LetPbe a probability transition function with support EandM:= (S, A, s 0, P).
1. For every policy π,JM
Ravg(π)≤ JM
A(π).
2. For every policy π, there exists some policy π′satisfying JM
A(π)≤ JM
Ravg(π′).
Proof sketch. 1. By construction, every run receiving a limit-average reward of 1, must have entered
some ASEC Ciand never left it. Furthermore, almost surely all states are visited infinitely often and
the run is accepted by definition of accepting ECs.
2. By Lemma 8, almost surely, a run is only accepted if it enters some Ci. We set π′to be the
policy agreeing with πuntil reaching one of the C1, . . . ,Cnand henceforth following the action
Act(st,qt)(st, qt), where qtis the state of the DRA at step t, yielding a guaranteed limit-average
reward of 1for the run by construction.
Remark 11. Our construction considers a collection of ASECs covering all states in ASECs. Whilst
it does not necessarily require listing all possible ASECs but only (up to) one ASEC per state, it is
unclear whether this can be obtained in polynomial time. In Appendix B.1, we present an alternative
(yet more complicated) construction which has polynomial time complexity.
5 Main Result
In this section, we generalise the approach of the preceding section to prove our main result:
Theorem 12. There exists an optimality-preserving translation from ω-regular languages to limit-
average reward machines.
Again, we fix an MDP without transition function (S, A, s 0), a label function λ:S×A×S→2AP
and a DRA A= (Q,2AP, q0, δ, F). Note that the ASECs of a product MDP are uniquely determined
by the non-zero probability transitions. Thus, for each set of transitions E⊆(S×Q)×A×(S×Q),
we let CE
1= (T1,Act1), . . . ,CE
n= (Tn,Actn)denote a collection of ASECs covering all states in
ASECs w.r.t. the MDPs in which Eis the set of non-zero probability transitions.5Then, for each set
Eand state (s, q)∈TE
1∪ ··· ∪ TE
n, we let CE
(s,q)= (TE
(s,q),ActE
(s,q))be the ASEC CE
ithat contains
(s, q)in which the index iis minimal.
Our reward machine R=R(S,A,λ, A)extends the ideas from the preceding section. Importantly,
we keep track of the set of transitions Etaken so far and assign rewards according to our current
knowledge about the graph of the product MDP. Therefore, we propose employing states of the
form (q, f, E ), where q∈Qkeeps track of the state of the DRA, f∈ {⊤ ,⊥}is astatus flag and
E⊆(S×Q)×A×(S×Q)memorises the transitions in the product MDP encountered thus far.
Intuitively, we set the flag to ⊥if we are in MDP state s,(s, q)is in one of the CE
1, . . . ,CE
nand the
chosen action deviates from ActE
(s,q)(s, q). We can recover from ⊥by discovering new transitions.
Besides, we give reward 1iff=⊤and(s, q)is in one of the CE
1, . . . ,CE
n(and0otherwise).
The status flag is required since discovering new transitions will change the structure of (accepting
simple) end components. Hence, differently from the preceding section, it is not sufficient to have a
single sink state.
The initial state of our reward machine is u0:= (q0,⊤,∅)and we formally define the update and
reward functions as follows:
δu((q, f, E ),(s, a, s′)) :=

(q′,⊥, E) iff=⊥ande∈E
(q′,⊥, E) iff=⊤, e∈E,(s, q)∈TE
1∪ ··· ∪ TE
nand
a̸∈ActE
(s,q)(s, q)
(q′,⊤, E∪ {e})otherwise
δr((q, f, E ),(s, a, s′)) :=1iff=⊤,(s, q)∈TE
1∪ ··· ∪ TE
n
0otherwise
where q′:=δ(q, λ(s, a, s′))ande:= ((q, s), a,(q′, s′)).
5To achieve the same number nof ASECs we can add duplicates. If there are no ASECs we can set Ti:=∅.
7Example 13. For our running example (see Example 1 and Fig. 1) initially no transitions are
known (hence no ASECs). Therefore, all transitions receive reward 0. Once action ahas been
performed in state s0in the MDP Mand(q1, f, E )in the reward machine R, we have discovered the
ASEC ({(s0, q1)},(s0, q1)7→ {a})and a reward of 1is given henceforth unless action bis selected
eventually. In that case, we leave the ASEC and we will not discover further ASECs since there is
only one. From here, it is not possible to return to state q1in the DRA and henceforth only reward 0
will be obtained.
Theorem 12 is proven by demonstrating an extension of Lemma 10 (see Appendix C):
Lemma 14. Suppose M= (S, A, s 0, P)is an arbitrary MDP .
1. For every policy π,JM
Ravg(π)≤ JM
A(π).
2. For every policy π, there exists some policy π′satisfying JM
A(π)≤ JM
Ravg(π′).
Note that Lemma 14 immediately proves that the reduction is not only optimality preserving (Theo-
rem 12) but also robust: every ϵ-approximately limit-average optimal policy is also ϵ-approximately
optimal w.r.t. JM
A. This observation is important because exactly optimal policies for the limit
average problem may be hard to find.
Intuitively, to see part 1 of Lemma 14 we note: If an average reward of 1is obtained for a run, the
reward machine believes, based on the partial observation of the product MDP, that the run ends
up in an ASEC. Almost surely, we eventually discover all possible transitions involving the same
state-action pairs as this ASEC and therefore this must also be an ASEC w.r.t. the true, unknown
product MDP. For part 2, we modify the policy πsimilarly as in Lemma 10 by selecting actions
Act(st, qt)once having entered an ASEC C= (T,Act) w.r.t. the true, unknown product MDP.6
6 Convergence for Limit Average, ω-Regular and LTL Objectives
Thanks to the described translation, advances (in both theory and practice) in the study of RL with
average rewards carry over to RL with ω-regular and LTL objectives. In this section, we show that it
is possible to learn optimal policies for limit average rewards in the limit. Hence, we resolve an open
problem [2]: also RL with ω-regular and LTL objectives can also be learned in the limit.
We start with the case of simple reward functions R:S×A×S→R. Recently, [ 18, Theorem
4.2] have shown that discount optimal policies for sufficiently high discount factor γ∈[0,1)are
also limit average optimal.7This result alone is not enough to demonstrate Theorem 16 since γis
generally not known and in finite time we might only obtain approximately limit average optimal
policies.
Our approach is to reduce RL with average rewards to a sequence of discount sum problems with
increasingly high discount factor, which are solved with increasingly high accuracy. Our crucial
insight is that eventually the approximately optimal solutions to the discounted problems will also be
limit average optimal (see Appendix D for a proof):
Lemma 15. Suppose γk↗1,ϵk↘0and suppose each πkis a memoryless policy. Then there exists
k0such that for all K∋k≥k0,πkis limit average optimal, where Kis the set of k∈Nsatisfying
JM
Rγk(πk)≥ JM
Rγk(π)−ϵkfor all memoryless policies π.
Our proof harnesses yet another notion of optimality: a policy πisBlackwell optimal (cf. [ 6] and
[22, Sec. 8.1]) if there exists γ∈(0,1)such that πisγ-discount optimal for all γ≤γ <1. It
is well-known that memoryless Blackwell optimal policies always exist [ 6,18] and they are also
limit-average optimal [22, 18].
Thanks to the PAC (probably approximately correct) learnability of RL with discounted rewards
[26,36], there exists an algorithm Discounted which receives as inputs a simulator for M,Ras
well as γ, ϵandδ, and with probability 1−δreturns an ϵ-optimal memoryless policy for discount
factor γ. In view of Lemma 15, our approach is to run the PAC algorithm for discount-sum RL for
increasingly large discount factors γand increasingly low δandϵ(Algorithm 1).
6NB The modified policy depends on the true, unknown support of the probability transition function; we
only claim the existence of such a policy.
7Recall (see e.g. [22, Sec. 8.1]) that for any policy π∈Π,limγ↗1(1−γ)· JM
Rγ(π) =JM
Ravg(π).
8Algorithm 1 RL for limit average rewards
Require: simulator for M,R
fork∈Ndo
πk←Discounted (M,R,1−1/k|{z}
γk,1/k|{z}
ϵk,1/k2
|{z}
δk)
end for
Theorem 16. RL with average reward functions can be learned in the limit by Algorithm 1: almost
surely there exists k0∈Nsuch that πkis limit-average optimal for k≥k0.
Proof. Using the definition for Kof Lemma 15 of iterations where the PAC-MDP algorithm succeeds,
E[#(N\K)]≤X
k∈NP[PAC-MDP fails in iteration k]≤X
k∈Nδk=X
k∈N1
k2<∞
The claim follows immediately with Lemma 15.
Next, we turn to the more general case of reward machines . [23,24] observe that optimal policies for
reward machines can be learned by learning optimal policies for the modified MDP which additionally
tracks the state the reward machine is in and assigns rewards accordingly. We conclude at once:
Corollary 17. RL with average reward machines can be learned in the limit.
Finally, harnessing Theorem 12 we resolve Open Problem 4 of [2]:
Theorem 18. RL with ω-regular and LTL objectives can be learned in the limit.
Discussion. Algorithm 1 makes independent calls to black box algorithms for discount sum rewards.
Many such algorithms with PAC guarantees are model based (e.g. [ 26,36]) and sample from the
MDP to obtain suitable approximations of the transition probabilities. Thus, Algorithm 1 can be
improved in practice by re-using approximations obtained in earlier iterations and refining them.
7 Related Work and Conclusion
The connection between acceptance of ω-regular languages in the product MDP and AECs is well-
known in the field of probabilistic model checking [ 4,12]. As an alternative to DRAs [ 41,14,32],
Limit Deterministic Büchi Automata [ 35] have been employed to express ω-regular languages for RL
[38, 7, 10, 20, 21].
A pioneering work on RL for ω-regular rewards is [ 41], which expresses ω-regular objectives using
Deterministic Rabin Automata. Similar RL approaches for ω-regular objectives can also be found
in [14,38,10,15]. The authors of [ 15,30] approach RL for ω-regular objectives directly by studying
the reachability of AECs in the product MDP and developing variants of the R-MAX algorithm [ 8] to
find optimal policies. However, these approaches require prior knowledge of the MDP, such as the
structure of the MDP, the optimal ϵ-return mixing time [15], or the ϵ-recurrence time [30].
Various studies have explored reductions of ω-regular objectives to discounted rewards, and sub-
sequently applied Q-learning and its variants for learning optimal policies [ 7,32,20,21,16]. In a
similar spirit, [ 39] present a translation from LTL objectives to eventual discounted rewards, where
only strictly positive rewards are discounted. These translations are generally not optimality preserv-
ing unless the discount factor is selected in a suitable way. Again, this is impossible without prior
knowledge of the exact probability transition functions in the MDP.
[25] propose a translation to limit-average rewards for ω-regular specifications which are also absolute
liveness properties. (In particular, optimal policies satisfy such specifications with either probability
0or1.) Their translation is optimality-preserving provided the MDP is communicating and the
magnitute of penalty rewards in their construction are chosen sufficiently large (which requires
knowledge of the MDP).
9Furthermore, whilst there are numerous convergent RL algorithms for average rewards for unichain
orcommunicating8MDPs (e.g. [ 8,43,17,33,3,40]), it is unknown whether such an algorithm
exists for general multichain MDPs with a guaranteed convergence property. In fact, a negative result
in [2,5] shows that there is no PAC (probably approximately correct) algorithm for LTL objectives
and limit-average rewards when the MDP transition probabilities are unknown.
[8] have proposed an algorithm with PAC guarantees provided ϵ-return mixing times are known.
They informally argue that for fixed sub-optimality tolerance ϵ, this assumption can be lifted by
guessing increasingly large candidates for the ϵ-return mixing time. This yields ϵ-approximately
optimal policies in the limit. However, it is not clear how to asymptotically obtain exactly optimal
policies as this would require simultaneously decreasing ϵand increasing guesses for the ϵ-return
mixing time (which depends on ϵ).
Conclusion. We have presented an optimality-preserving translation from ω-regular objectives to
limit-average rewards furnished by reward machines. As a consequence, off-the-shelf RL algorithms
for average rewards can be employed in conjunction with our translation to learn policies for ω-regular
objectives. Furthermore, we have developed an algorithm asymptotically learning provably optimal
policies for limit-average rewards. Hence, also optimal policies for ω-regular and LTL objectives can
be learned in the limit. Our results provide affirmative answers to two open problems in [2].
Limitations. We focus on MDPs with finite state and action sets and assume states are fully
observable. The assumption of Section 4 that the support of the MDP’s probability transition function
is known is eliminated in Section 5. Whilst the size of our general translation—the first optimality-
preserving translation—is exponential, the additional knowledge in Section 4 enables a construction
of the reward machine of the same size as the DRA expressing the objective. Hence, we conjecture
that this size is minimal relative to the DRA specification. Since RL with average rewards is not PAC
learnable, we cannot possibly provide finite-time complexity guarantees of our Algorithm 1.
Acknowledgments and Disclosure of Funding
This research is supported by the National Research Foundation, Singapore, under its RSS Scheme
(NRFRSS2022-009).
References
[1]Luca Alfaro. Formal Verification of Probabilistic Systems . Phd thesis, Stanford University,
Stanford, CA, USA, 1998.
[2]Rajeev Alur, Suguman Bansal, Osbert Bastani, and Kishor Jothimurugan. A framework
for transforming specifications in reinforcement learning. In Jean-François Raskin, Krishnendu
Chatterjee, Laurent Doyen, and Rupak Majumdar, editors, Principles of Systems Design: Essays
Dedicated to Thomas A. Henzinger on the Occasion of His 60th Birthday , pages 604–624,
Cham, 2022. Springer Nature Switzerland.
[3]Peter Auer, Thomas Jaksch, and Ronald Ortner. Near-optimal regret bounds for reinforcement
learning. In D. Koller, D. Schuurmans, Y . Bengio, and L. Bottou, editors, Advances in Neural
Information Processing Systems , volume 21. Curran Associates, Inc., 2008.
[4] Christel Baier and Joost-Pieter Katoen. Principles of Model Checking . The MIT Press, 2008.
[5]Hugo Bazille, Blaise Genest, Cyrille Jégourel, and Jun Sun. Global PAC bounds for learning
discrete time Markov chains. In Shuvendu K. Lahiri and Chao Wang, editors, Computer Aided
Verification - 32nd International Conference, CAV 2020, Los Angeles, CA, USA, July 21-24,
2020, Proceedings, Part II , volume 12225 of Lecture Notes in Computer Science , pages 304–326.
Springer, 2020.
[6]David Blackwell. Discrete Dynamic Programming. The Annals of Mathematical Statistics ,
33(2):719 – 726, 1962.
8These assumptions generally fail for our setting, where in view of Corollary 17, MDP states also track the
states of the reward machine. For instance, in the reward machine in Fig. 2a it is impossible to reach u1fromu2.
10[7]Alper Kamil Bozkurt, Yu Wang, Michael M. Zavlanos, and Miroslav Pajic. Control synthesis
from Linear Temporal Logic specifications using model-free reinforcement learning. 2020
IEEE International Conference on Robotics and Automation (ICRA) , pages 10349–10355, 2019.
[8]Ronen I. Brafman and Moshe Tennenholtz. R-max - A general polynomial time algorithm for
near-optimal reinforcement learning. J. Mach. Learn. Res. , 3(null):213–231, mar 2003.
[9]Tomáš Brázdil, Krishnendu Chatterjee, Martin Chmelik, V ojt ˇech Forejt, Jan K ˇretínsk `y, Marta
Kwiatkowska, David Parker, and Mateusz Ujma. Verification of Markov Decision Processes
using learning algorithms. In Automated Technology for Verification and Analysis: 12th Inter-
national Symposium, ATVA 2014, Sydney, NSW, Australia, November 3-7, 2014, Proceedings
12, pages 98–114. Springer, 2014.
[10] Mingyu Cai, Shaoping Xiao, Zhijun Li, and Zhen Kan. Optimal probabilistic motion planning
with potential infeasible LTL constraints. IEEE Transactions on Automatic Control , 68(1):301–
316, 2023.
[11] Krishnendu Chatterjee and Monika Henzinger. Faster and dynamic algorithms for maximal
end-component decomposition and related graph problems in probabilistic verification. In
Dana Randall, editor, Proceedings of the Twenty-Second Annual ACM-SIAM Symposium on
Discrete Algorithms, SODA 2011, San Francisco, California, USA, January 23-25, 2011 , pages
1318–1336. SIAM, 2011.
[12] Luca de Alfaro. Computing minimum and maximum reachability times in probabilistic systems.
In Jos C. M. Baeten and Sjouke Mauw, editors, CONCUR’99 Concurrency Theory , pages 66–81,
Berlin, Heidelberg, 1999. Springer Berlin Heidelberg.
[13] Vektor Dewanto, George Dunn, Ali Eshragh, Marcus Gallagher, and Fred Roosta. Average-
reward model-free reinforcement learning: A systematic review and literature mapping, 2021.
[14] Xuchu Ding, Stephen L. Smith, Calin Belta, and Daniela Rus. Optimal control of Markov
Decision Processes with Linear Temporal Logic constraints. IEEE Transactions on Automatic
Control , 59(5):1244–1257, 2014.
[15] Jie Fu and Ufuk Topcu. Probably approximately correct MDP learning and control with
Temporal Logic constraints. In Dieter Fox, Lydia E. Kavraki, and Hanna Kurniawati, editors,
Robotics: Science and Systems X, University of California, Berkeley, USA, July 12-16, 2014 ,
2014.
[16] Qitong Gao, Davood Hajinezhad, Yan Zhang, Yiannis Kantaros, and Michael M. Zavlanos. Re-
duced variance deep reinforcement learning with Temporal Logic specifications. In Proceedings
of the 10th ACM/IEEE International Conference on Cyber-Physical Systems , ICCPS ’19, page
237–248, New York, NY , USA, 2019. Association for Computing Machinery.
[17] Abhijit Gosavi. Reinforcement learning for long-run average cost. European Journal of
Operational Research , 155(3):654–674, 2004. Traffic and Transportation Systems Analysis.
[18] Julien Grand-Clément and Marek Petrik. Reducing Blackwell and average optimality to
discounted MDPs via the Blackwell discount factor. In Alice Oh, Tristan Naumann, Amir
Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, Advances in Neural Infor-
mation Processing Systems 36: Annual Conference on Neural Information Processing Systems
2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023 , 2023.
[19] Ernst Moritz Hahn, Mateo Perez, Sven Schewe, Fabio Somenzi, Ashutosh Trivedi, and Dominik
Wojtczak. Omega-regular objectives in model-free reinforcement learning. In Tomáš V ojnar
and Lijun Zhang, editors, Tools and Algorithms for the Construction and Analysis of Systems ,
pages 395–412, Cham, 2019. Springer International Publishing.
[20] Hosein Hasanbeig, Daniel Kroening, and Alessandro Abate. Certified reinforcement learning
with logic guidance. Artificial Intelligence , 322:103949, 2023.
[21] Mohammadhosein Hasanbeig, Daniel Kroening, and Alessandro Abate. Deep reinforcement
learning with Temporal Logics. In Nathalie Bertrand and Nils Jansen, editors, Formal Modeling
and Analysis of Timed Systems , pages 1–22, Cham, 2020. Springer International Publishing.
11[22] Arie Hordijk and Alexander A. Yushkevich. Blackwell Optimality , pages 231–267. Springer
US, Boston, MA, 2002.
[23] Rodrigo Toro Icarte. Reward Machines . Phd thesis, University of Toronto, 03 2022.
[24] Rodrigo Toro Icarte, Toryn Klassen, Richard Valenzano, and Sheila McIlraith. Using reward
machines for high-level task specification and decomposition in reinforcement learning. In
Jennifer Dy and Andreas Krause, editors, Proceedings of the 35th International Conference on
Machine Learning , volume 80 of Proceedings of Machine Learning Research , pages 2107–2116.
PMLR, 10–15 Jul 2018.
[25] Milad Kazemi, Mateo Perez, Fabio Somenzi, Sadegh Soudjani, Ashutosh Trivedi, and Al-
varo Velasquez. Translating omega-regular specifications to average objectives for model-free
reinforcement learning. In Piotr Faliszewski, Viviana Mascardi, Catherine Pelachaud, and
Matthew E. Taylor, editors, 21st International Conference on Autonomous Agents and Mul-
tiagent Systems, AAMAS 2022, Auckland, New Zealand, May 9-13, 2022 , pages 732–741.
International Foundation for Autonomous Agents and Multiagent Systems (IFAAMAS), 2022.
[26] Michael Kearns and Satinder Singh. Near-optimal reinforcement learning in polynomial time.
Machine Learning , 49:209–232, 2002.
[27] Bakhadyr Khoussainov and Anil Nerode. Automata Theory and its Applications . Birkhäuser
Boston, Boston, MA, 2001.
[28] Achim Klenke. Probability Theory: A Comprehensive Course . Universitext. Springer London,
2014.
[29] Dexter Kozen. Theory of Computation . Springer, London, 2006.
[30] Mateo Perez, Fabio Somenzi, and Ashutosh Trivedi. A PAC learning algorithm for LTL
and omega-regular objectives in MDPs. Proceedings of the AAAI Conference on Artificial
Intelligence , 38(19):21510–21517, 2024.
[31] Martin L. Puterman. Markov Decision Processes: Discrete Stochastic Dynamic Programming .
John Wiley & Sons, Inc., USA, 1st edition, 1994.
[32] Dorsa Sadigh, Eric S. Kim, Samuel Coogan, S. Shankar Sastry, and Sanjit A. Seshia. A learning
based approach to control synthesis of Markov Decision Processes for Linear Temporal Logic
specifications. In 53rd IEEE Conference on Decision and Control , pages 1091–1096, 2014.
[33] Anton Schwartz. A reinforcement learning method for maximizing undiscounted rewards. In
International Conference on Machine Learning , 1993.
[34] Daqian Shao and Marta Kwiatkowska. Sample efficient model-free reinforcement learning
from LTL specifications with optimality guarantees. IJCAI International Joint Conference on
Artificial Intelligence , 2023-Augus:4180–4189, 2023.
[35] Salomon Sickert, Javier Esparza, Stefan Jaax, and Jan K ˇretínský. Limit-deterministic Büchi au-
tomata for Linear Temporal Logic. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer
Aided Verification , pages 312–332, Cham, 2016. Springer International Publishing.
[36] Alexander L. Strehl, Lihong Li, and Michael L. Littman. Reinforcement learning in finite
MDPs: PAC analysis. J. Mach. Learn. Res. , 10:2413–2444, 2009.
[37] Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction . A Bradford
Book, Cambridge, MA, USA, 2018.
[38] Cameron V oloshin, Hoang Le, Swarat Chaudhuri, and Yisong Yue. Policy optimization with
Linear Temporal Logic constraints. Advances in Neural Information Processing Systems ,
35:17690–17702, 2022.
[39] Cameron V oloshin, Abhinav Verma, and Yisong Yue. Eventual discounting Temporal Logic
counterfactual experience replay. In Andreas Krause, Emma Brunskill, Kyunghyun Cho,
Barbara Engelhardt, Sivan Sabato, and Jonathan Scarlett, editors, International Conference
on Machine Learning, ICML 2023, 23-29 July 2023, Honolulu, Hawaii, USA , volume 202 of
Proceedings of Machine Learning Research , pages 35137–35150. PMLR, 2023.
12[40] Yi Wan, Abhishek Naik, and Richard S. Sutton. Learning and planning in average-reward
Markov Decision Processes. In Marina Meila and Tong Zhang, editors, Proceedings of the 38th
International Conference on Machine Learning, ICML 2021, 18-24 July 2021, Virtual Event ,
volume 139 of Proceedings of Machine Learning Research , pages 10653–10662. PMLR, 2021.
[41] Eric M. Wolff, Ufuk Topcu, and Richard M. Murray. Robust control of uncertain Markov
Decision Processes with Temporal Logic specifications. In 2012 IEEE 51st IEEE Conference
on Decision and Control (CDC) , pages 3372–3379, 2012.
[42] Cambridge Yang, Michael L. Littman, and Michael Carbin. On the (in)tractability of rein-
forcement learning for LTL objectives. IJCAI International Joint Conference on Artificial
Intelligence , pages 3650–3658, 2022.
[43] Shangdong Yang, Yang Gao, Bo An, Hao Wang, and Xingguo Chen. Efficient average reward
reinforcement learning using constant shifting values. Proceedings of the AAAI Conference on
Artificial Intelligence , 30(1), 2016.
13s0 start
s1s3
s2 a/1 a/1b/p2
a/p1a/1−p1b/1−p2
b/1
(a) An MDP Mwhere λ(s1, a, s 1) =λ(s3, b, s 0) ={c},
and the rest are labeled with ∅.q0 start q1{c}∅ {c}
∅
(b) A DRA Afor the objective of visiting s1or
s3infinitely often where F:={({q1},∅)}.
Figure 3: Counter-example for prefix-independent objectives.
A Supplementary Materials for Section 3
Recall that a ω-regular language Lis prefix-independent if for every infinite label sequence
w∈(2AP)ω, we have w∈Liffw′∈Lfor every suffix w′ofw. We prove that there is no
optimality-preserving translation for reward functions regardless of whether Lis prefix-independent
or not. The prefix-dependent case was given in Section 3. Here we focus on the other case:
Proposition 19. There exists a tuple (S, A, s 0, λ)and a prefix-independent ω-regular language Lfor
which it is impossible to find a reward function R:S×A×S→Rsuch that for every probability
transition P, letM= (S, A, s 0, P, λ), then every Ravg-optimal policy of Mis also L-optimal (i.e.
maximizing the probability of membership in L).
Proof. Our proof technique is based on the fact that we can modify the transition probability function.
Consider the MDP in Fig. 3a, where the objective is to visit either s1ors3infinitely often. It can
be checked that the DRA in Fig. 3b captures the given objective and the language accepted by Ais
prefix-independent. There are only two deterministic memoryless policies: π1, which consistently
selects action a, and π2, which consistently selects action b. For the sake of contradiction, let’s
assume the existence of a reward function Rthat preserves optimality for every transition probability
function P. Pick p1= 1 andp2= 0. Then JM
A(π1) = 1 andJM
A(π2) = 0 , which implies that
π1isA-optimal whereas π2is not. Thus R(s1, a, s 1) =JM
Ravg(π1)>JM
Ravg(π2) =R(s0, b, s 0).
Now, assume p1, p2∈(0,1). Accordingly, we have JM
Ravg(π1)≥p1R(s1, a, s 1)and we can
deduce that (e.g. by solving the linear equation system described in [ 31, §8.2.3]) JM
Ravg(π2) =
p2
2−p2R(s0, b, s 0) +1−p2
2−p2(R(s0, b, s 3) +R(s3, b, s 0)). As a result:
lim
p1→1JM
Ravg(π1)≥ R (s1, a, s 1)>R(s0, b, s 0) = lim
p2→1JM
Ravg(π2)
Consequently, if p1, p2are sufficiently large then JM
Ravg(π1)>JM
Ravg(π2). However, this contradicts
to the fact that π2isA-optimal and π1is not, since JM
A(π2) = 1 > p1=JM
A(π1). Hence, there is
no such reward function R.
B Supplementary Materials for Section 4
Lemma 20. Every AEC contains an ASEC.
Proof. Consider an AEC C= (T,Act) ofMA. We will prove this by using induction on the number
of actions in C, denoted as size(C) :=P
s∈T|Act(s)| ≥1. For the base case where size(C) = 1 , it
can be deduced that Cconsists of only one accepting state with a self-loop. Therefore, Citself is an
ASEC.
14Now, let’s assume that size(C) =k+ 1≥2. IfCis already an ASEC, then we are done. Otherwise,
there exists a state s∈Tsuch that |Act(s)|>1. Since Cis strongly connected, there exists a
finite path ρ=sas1a1. . . s nansFwhere sFis an accepting state and all the states s1, . . . , s nare
different from s. Let a′∈Act(s)such that a′̸=a. We construct a new AEC C′= (T′,Act′)by
first removing a′from Act(s)and then removing all the states that are no longer reachable from s
along with their associated transitions. It is important to note that after the removal, sF∈T′since
we can reach sFfromswithout taking the action a′. (Besides, the graph is still strongly connected.)
Since size(C′)≤k, we can apply the induction hypothesis to conclude that C′contains an ASEC,
thus completing the proof.
Lemma 8. Almost surely, if ρis accepted by Athenρ⊗reaches a state in some ASEC CiofM ⊗ A .
To proof this result, we recall a well-known result in probabilistic model checking that with probability
of one (wpo), every run ρof the policy πeventually stays in one of the ECs of MAand visits every
transition in that EC infinitely often. To state this formally, we define for any run ρ=s0a0s1···,
InfSA( ρ) :={(s, a)∈S×A| |{i∈N|si=s∧ai=a}|=∞}
the set of state-action-pairs occurring infinitely often in ρ. Furthermore, a state-action set χ⊆S×A
defines a sub-MDP sub(χ) := ( T,Act) , where
T:={s∈S|(s, a)∈χfor some a∈A} Act(s) :={a|(s, a)∈χ}
Lemma 21 ([12]) .Pρ∼DM⊗A
π[sub(InfSA( ρ))is an end component ] = 1 .
For the sake of self-containedness, we recall the proof of [12].
Proof. We start with two more definitions: for any sub-MDP (T,Act) [1], let
sa(T,Act) := {(s, a)∈T×A|a∈Act(s)}
be the set of state-action pairs (s, a)such that ais enabled in s. Finally, let
Ω(T,Act):={ρ∈Runs( S, A)|InfSA( ρ) = sa( T,Act)}
be the set of runs such that action ais taken infinitely often in state siffs∈Tanda∈Act(s). Note
that the Ω(T,Act)constitute a partition of Runs( S, A).
Therefore, it suffices to establish for any sub-MDP (T,Act) ,(T,Act) is an end-component or
P[ρ∈Ω(T,Act)] = 0 .
Let(T,Act) be an arbitrary sub-MDP. First, suppose there exist s∈Tanda∈Act(t)such that
p:=P
s′∈T∆(t, a, t′)<1. By definition each ρ∈Ω(T,Act)takes action ain state sinfinitely often.
Hence, not only P[ρ∈Ω(T,Act)]≤pkfor all k∈Nbut also P[ρ∈Ω(T,Act)] = 0 .
Thus, we can assume that for all s∈Tanda∈Act(t),P
s′∈T∆(t, a, t′) = 1 . IfΩ(T,Act)=∅
then clearly P[ρ∈Ω(T,Act)] = 0 follows. Otherwise, take any ρ=s0a0a1··· ∈ Ω(T,Act), and let
t, t′∈Tbe arbitrary. We show that there exists a connecting path in (T,→Act), which implies that
(T,Act) is an end component.
Evidently, there exists an index i0such that all state-action pairs occur infinitely often in ρ, i.e.
{(si0, ai0),(si0+1, ai0+1), . . .}= InfSA( ρ)
Thus, for all i≥i0,si∈Tandai∈Act(si), and for all i′> i≥i0, there is a path from sitosi′in
(T,→Act). Finally, it suffices to note that clearly for some i′> i=i0,si=tandsi′=t′.
Proof of Lemma 8. By Lemma 21, almost surely sub(InfSA( ρ))is an accepting end component.
Clearly, ρis only accepted by the product MDP if this end component is an accepting EC. By
Lemma 20 this AEC contains an ASEC. Therefore, by definition of sub(InfSA( ρ)),ρalmost surely
in particular enters some ASEC. Finally, since the C1, . . . ,Cncover all states in ASECs, ρalmost
surely enters some Ci.
15q0 start q1 ⊥ q2(s0, a, s 0)/0
(s1, b, s 0)/0(s0, b, s 1)/0(s0, a, s 0)/1
(s1, b, s 0)/0(s0, b, s 1)/1∗/0 ∗/0
Figure 4: Reward machine yielded by our construction in Section 4 for the running example.
Before turning to the proof of Lemma 10, let JM
Ravg(ρ) = lim inf t→∞1
t·Pt−1
i=0ridenote the limit-
average reward of a run ρ. Note that, for any run ρ,JM
Ravg(ρ)∈ {0,1}. Thus, by the dominated
convergence theorem [28, Cor. 6.26],
Pρ∼DMπ
JM
Ravg(ρ) = 1
=Eρ∼DMπ[JM
Ravg(ρ)] = lim inf
t→∞Eρ∼DMπ"
1
t·t−1X
i=0ri#
=JM
Ravg(π)
(3)
Lemma 10. LetPbe a probability transition function with support EandM:= (S, A, s 0, P).
1. For every policy π,JM
Ravg(π)≤ JM
A(π).
2. For every policy π, there exists some policy π′satisfying JM
A(π)≤ JM
Ravg(π′).
Proof. 1.For any run ρ,JM
Ravg(ρ) = 1 only if ρ⊗enters a Ciand never leaves it. ( ρ⊗might
have entered other Cj’s earlier but then those necessarily need to overlap with yet another
Cksuch that i≤k < j to avoid being trapped in state ⊥, resulting in JM
Ravg(ρ) = 1 .
Furthermore, this Cican only overlap with Cjifi < j . Otherwise, the reward machine
would have enforced transitioning to Cj.)
SinceCiis an ASEC, ρ⊗is accepted by the product MDP M ⊗ A . Hence, by Eqs. (2)
and (3),
JM
Ravg(π) =Pρ∼DMπ
JM
Ravg(ρ) = 1
≤Pρ∼DMπ
ρ⊗accepted by M ⊗ A
=JM
A(π)
2.Letπbe arbitrary. For a run s0a0···letqtbe the state of the DRA in step t. Define π′
to follow πuntil reaching stsuch that (st, qt)∈T1∪ ··· ∪ Tn. Henceforth, we select the
(unique) action guaranteeing to stay in the Ciwith minimal iincluding the current state, i.e.
Act(q,u)(q, u). Formally9,
π′(s0a0···st) :=π(s0a0···st) if(st, qt)̸∈T1∪ ··· ∪ Tn
Act(st,qt)(st, qt)otherwise(4)
Note that whenever a run ρ∼ DM
π′follows the modified policy π′and its induced run ρ⊗
reaches some ASEC CithenJM
Ravg(ρ) = 1 . Thus,
Pρ∼DM
π′[ρ⊗reaches some Ci]≤Eρ∼DM
π′[JM
Ravg(ρ)] =JM
Ravg(π′)
Furthermore, by Lemma 8 almost surely, every induced run ρ⊗accepted by the product
MDP must reach some Ci. Consequently, by Eq. (2),
JM
A(π) =Pρ∼DMπ[ρ⊗is accepted by M ⊗ A ]
≤Pρ∼DMπ[ρ⊗reaches some Ci]
=Pρ∼DM
π′[ρ⊗reaches some Ci]≤ JM
Ravg(π′)
In the penultimate step, we have exploited the fact that πandπ′agree until reaching the
firstCi.
9We slightly abuse notation in the “otherwise”-case and denote by Act (st,qt)(st, qt)the distribution selecting
the state in the singleton set Act (st,qt)(st, qt)with probability 1.
16B.1 Efficient Construction
We consider a different collection C1, . . . ,Cnof ASECs:
Suppose C′
1, . . . ,C′
nis a collection of AECs (not necessarily simple ones) con-
taining all states in AECs. Then we consider ASECs C1, . . . ,Cnsuch that Ciis
contained in C′
i.
The definition of the reward machine in Section 4.2 and the extension in Section 5 do not need to be
changed. Next, we argue the following:
1.This collection can be obtained efficiently (in time polynomial in the size of the MDP and
DRA).
2. Lemma 10 and hence the correctness result (Theorem 9) still hold.
For 1. it is well-known that a collection of maximal AECs (covering all states in AECs) can be
found efficiently using graph algorithms [ 1, Alg. 3.1], [ 15,11] and [ 4, Alg. 47 and Lemma 10.125].
Subsequently, Lemma 20 can be used to obtain an ASEC contained in each of them. In particular, note
that the proof of Lemma 20 immediately gives rise to an efficient algorithm. (Briefly, we iteratively
remove actions and states whilst querying reachability properties.)
For 2., the first part of Lemma 10 clearly still holds. For the second, we modify policy πas follows:
Once, πenters a maximal accepting end component we select an action on the shortest path to
the respective ASEC Ciinside C′
i. Once we enter one of the Ciwe follow the actions specified by
the ASEC as before. Observe that the probability that under an AEC is entered is the same as the
probability that one of the Ciis entered under the modified policy. The lemma, hence Theorem 9,
follow.
C Supplementary Materials for Section 5
Lemma 14. Suppose M= (S, A, s 0, P)is an arbitrary MDP .
1. For every policy π,JM
Ravg(π)≤ JM
A(π).
2. For every policy π, there exists some policy π′satisfying JM
A(π)≤ JM
Ravg(π′).
Proof. 1.For a run ρ, letEρbe the set of transitions encountered in the product MDP. Note
thatJM
Ravg(ρ) = 1 only if ρ⊗enters some CEρ
iand never leaves it. ( ρ⊗might have entered
otherCE
js earlier for E⊆Eρ.)
With probability 1, Eρcontains all the transitions present in CEρ
iin the actual MDP. (NB
possible transitions outside of CEρ
imight be missing from Eρ.) In particular, with probability
1,CEρ
iis also an ASEC for the true unknown MDP and ρ⊗is accepted by the product MDP
M ⊗ A . Consequently, using Eq. (3) again,
JM
Ravg(π) =Pρ∼DMπ[JM
Ravg(ρ) = 1] ≤Pρ∼DMπ[ρ⊗accepted by M ⊗ A ] =JM
A(π)
2.Letπbe arbitrary. We modify πtoπ′as follows: until reaching an ASEC C= (T,Act)
w.r.t. the true, unknown10set of transitions E∗follow π. Henceforth, select action
ActE∗
(st,qt)(st, qt).
We claim that whenever ρ∼ DM
π′follows the modified policy π′andρ⊗reaches some
ASEC in the true product MDP, JM
Ravg(ρ) = 1 .
To see this, suppose ρ∼ DM
π′is such that for some minimal t0∈N,(st0, qt0)∈TE∗
1∪
··· ∪ TE∗
n. LetC= (T,Act) := CE∗
(st0,qt0).
Define Etto be the transitions encountered up to step t∈N, i.e. Et:=
{((sk, qk), ak,(sk+1, qk+1))|0≤k < t}. Then almost surely for some minimal t≥t0,
10NB The modified policy depends on the true, unknown E∗; we only claim the existence of such a policy.
17Etcontains all transitions in C, and no further transitions will be encountered, i.e. for all
t′≥t,Et′=Et. Define E:=Et. Note that for all ((s, q), a,(s′, q′))∈Esuch that
(s, q)∈T,Act(s, q) ={a}. (This is because upon entering the ASEC Cwe immediately
switch to following the action dictated by Act. Thus, we avoid “accidentally” discovering
other ASECs w.r.t. the partial knowledge of the product MDP’s graph, which might other-
wise force us to perform actions leaving C.) Consequently, there cannot be another ASEC
C′= (T′,Act′)w.r.t. Eoverlapping with C, i.e.T∩T′̸=∅. Therefore, for all (s, q)∈ C,
ActE
(s,q)= Act . Consequently, JM
Ravg(ρ) = 1 .
Thus,
Pρ∼DM
π′[ρ⊗reaches some ASEC in true product MDP ]≤Eρ∼DM
π′[JM
Ravg(ρ)] =JM
Ravg(π′)
Consequently,
JM
A(π) =Pρ∼DMπ[ρ⊗is accepted by M ⊗ A ]
≤Pρ∼DMπ[ρ⊗reaches some ASEC in true product MDP ]
=Pρ∼DM
π′[ρ⊗reaches some ASEC in true product MDP ]≤ JM
Ravg(π′)
In the penultimate step we have exploited that πandπ′agree until reaching some ASEC in
true product MDP.
D Supplementary Materials for Section 6
LetΠbe the set of all memoryless policies and Π∗be the set of all limit-average optimal policies.
Besides, let w∗:=JM
Ravg(π∗)the limit average reward of any optimal π∗∈Π∗.
Lemma 15 is proven completely analagously to the following (where K=N):
Lemma 22. Suppose γk↗1,ϵk↘0and each πkis a memoryless policy satisfying JM
Rγk(πk)≥
JM
Rγk(π)−ϵkfor all π∈Π. Then there exists k0such that for all k≥k0,πkis limit average
optimal.
Proof. We define ∆ := min π∈Π\Π∗JM
Ravg(π)−w∗>0. Recall (see e.g. [ 22, Sec. 8.1]) that for any
policy π∈Π,
lim
γ↗1(1−γ)· JM
Rγ(π) =JM
Ravg(π) (5)
Since Πis finite, due to Eq. (5) there exists γ0such that
|JM
Ravg(π)−(1−γ)· JM
Rγ(π)| ≤∆
4(6)
for all π∈Πandγ∈[γ0,1). Letπ∗be a memoryless Blackwell optimal policy (which exists due to
[6, 18]). Note that
w∗=JM
Ravg(π∗) (7)
and there exists γ∈[0,1)such that
JM
Rγ(π∗)≥ JM
Rγ(π) (8)
for all γ∈[γ,1)andπ∈Π. Moreover, there clearly exists k0such that ϵk≤∆/4andγk≥γ0,γ
for all k≥k0.
Therefore, for any k≥k0,
|JM
Ravg(πk)−w∗| ≤(1−γk)·JM
Rγk(πk)− JM
Rγk(π∗)+∆
2Eqs. (6) and (7)
≤(1−γk)·ϵk+∆
2premise and Eq. (8)
≤4
3·∆
Consequently, by definition of ∆,πk∈Π∗.
18NeurIPS Paper Checklist
1.Claims
Question: Do the main claims made in the abstract and introduction accurately reflect the
paper’s contributions and scope?
Answer: [Yes]
Justification: The main results mentioned in the abstract and introduction are Proposition 4
and Theorems 12, 16 and 18. They accurately reflect the paper’s contributions and scope.
Guidelines:
•The answer NA means that the abstract and introduction do not include the claims
made in the paper.
•The abstract and/or introduction should clearly state the claims made, including the
contributions made in the paper and important assumptions and limitations. A No or
NA answer to this question will not be perceived well by the reviewers.
•The claims made should match theoretical and experimental results, and reflect how
much the results can be expected to generalize to other settings.
•It is fine to include aspirational goals as motivation as long as it is clear that these goals
are not attained by the paper.
2.Limitations
Question: Does the paper discuss the limitations of the work performed by the authors?
Answer: [Yes]
Justification: Limitations are discussed in Section 7.
Guidelines:
•The answer NA means that the paper has no limitation while the answer No means that
the paper has limitations, but those are not discussed in the paper.
• The authors are encouraged to create a separate "Limitations" section in their paper.
•The paper should point out any strong assumptions and how robust the results are to
violations of these assumptions (e.g., independence assumptions, noiseless settings,
model well-specification, asymptotic approximations only holding locally). The authors
should reflect on how these assumptions might be violated in practice and what the
implications would be.
•The authors should reflect on the scope of the claims made, e.g., if the approach was
only tested on a few datasets or with a few runs. In general, empirical results often
depend on implicit assumptions, which should be articulated.
•The authors should reflect on the factors that influence the performance of the approach.
For example, a facial recognition algorithm may perform poorly when image resolution
is low or images are taken in low lighting. Or a speech-to-text system might not be
used reliably to provide closed captions for online lectures because it fails to handle
technical jargon.
•The authors should discuss the computational efficiency of the proposed algorithms
and how they scale with dataset size.
•If applicable, the authors should discuss possible limitations of their approach to
address problems of privacy and fairness.
•While the authors might fear that complete honesty about limitations might be used by
reviewers as grounds for rejection, a worse outcome might be that reviewers discover
limitations that aren’t acknowledged in the paper. The authors should use their best
judgment and recognize that individual actions in favor of transparency play an impor-
tant role in developing norms that preserve the integrity of the community. Reviewers
will be specifically instructed to not penalize honesty concerning limitations.
3.Theory Assumptions and Proofs
Question: For each theoretical result, does the paper provide the full set of assumptions and
a complete (and correct) proof?
Answer: [Yes]
19Justification: Full proofs are presented in the appendices and results are cross-referenced.
At the beginning of Section 4 we assume knowledge of the support of the MDP’s proba-
bility transition function for presentational purposes. This assumption is fully removed in
Section 5.
Guidelines:
• The answer NA means that the paper does not include theoretical results.
•All the theorems, formulas, and proofs in the paper should be numbered and cross-
referenced.
•All assumptions should be clearly stated or referenced in the statement of any theorems.
•The proofs can either appear in the main paper or the supplemental material, but if
they appear in the supplemental material, the authors are encouraged to provide a short
proof sketch to provide intuition.
•Inversely, any informal proof provided in the core of the paper should be complemented
by formal proofs provided in appendix or supplemental material.
• Theorems and Lemmas that the proof relies upon should be properly referenced.
4.Experimental Result Reproducibility
Question: Does the paper fully disclose all the information needed to reproduce the main ex-
perimental results of the paper to the extent that it affects the main claims and/or conclusions
of the paper (regardless of whether the code and data are provided or not)?
Answer: [NA]
Justification: The paper does not include experiments.
Guidelines:
• The answer NA means that the paper does not include experiments.
•If the paper includes experiments, a No answer to this question will not be perceived
well by the reviewers: Making the paper reproducible is important, regardless of
whether the code and data are provided or not.
•If the contribution is a dataset and/or model, the authors should describe the steps taken
to make their results reproducible or verifiable.
•Depending on the contribution, reproducibility can be accomplished in various ways.
For example, if the contribution is a novel architecture, describing the architecture fully
might suffice, or if the contribution is a specific model and empirical evaluation, it may
be necessary to either make it possible for others to replicate the model with the same
dataset, or provide access to the model. In general. releasing code and data is often
one good way to accomplish this, but reproducibility can also be provided via detailed
instructions for how to replicate the results, access to a hosted model (e.g., in the case
of a large language model), releasing of a model checkpoint, or other means that are
appropriate to the research performed.
•While NeurIPS does not require releasing code, the conference does require all submis-
sions to provide some reasonable avenue for reproducibility, which may depend on the
nature of the contribution. For example
(a)If the contribution is primarily a new algorithm, the paper should make it clear how
to reproduce that algorithm.
(b)If the contribution is primarily a new model architecture, the paper should describe
the architecture clearly and fully.
(c)If the contribution is a new model (e.g., a large language model), then there should
either be a way to access this model for reproducing the results or a way to reproduce
the model (e.g., with an open-source dataset or instructions for how to construct
the dataset).
(d)We recognize that reproducibility may be tricky in some cases, in which case
authors are welcome to describe the particular way they provide for reproducibility.
In the case of closed-source models, it may be that access to the model is limited in
some way (e.g., to registered users), but it should be possible for other researchers
to have some path to reproducing or verifying the results.
5.Open access to data and code
20Question: Does the paper provide open access to the data and code, with sufficient instruc-
tions to faithfully reproduce the main experimental results, as described in supplemental
material?
Answer: [NA]
Justification: The paper does not include experiments.
Guidelines:
• The answer NA means that paper does not include experiments requiring code.
•Please see the NeurIPS code and data submission guidelines ( https://nips.cc/
public/guides/CodeSubmissionPolicy ) for more details.
•While we encourage the release of code and data, we understand that this might not be
possible, so “No” is an acceptable answer. Papers cannot be rejected simply for not
including code, unless this is central to the contribution (e.g., for a new open-source
benchmark).
•The instructions should contain the exact command and environment needed to run to
reproduce the results. See the NeurIPS code and data submission guidelines ( https:
//nips.cc/public/guides/CodeSubmissionPolicy ) for more details.
•The authors should provide instructions on data access and preparation, including how
to access the raw data, preprocessed data, intermediate data, and generated data, etc.
•The authors should provide scripts to reproduce all experimental results for the new
proposed method and baselines. If only a subset of experiments are reproducible, they
should state which ones are omitted from the script and why.
•At submission time, to preserve anonymity, the authors should release anonymized
versions (if applicable).
•Providing as much information as possible in supplemental material (appended to the
paper) is recommended, but including URLs to data and code is permitted.
6.Experimental Setting/Details
Question: Does the paper specify all the training and test details (e.g., data splits, hyper-
parameters, how they were chosen, type of optimizer, etc.) necessary to understand the
results?
Answer: [NA]
Justification: The paper does not include experiments.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The experimental setting should be presented in the core of the paper to a level of detail
that is necessary to appreciate the results and make sense of them.
•The full details can be provided either with the code, in appendix, or as supplemental
material.
7.Experiment Statistical Significance
Question: Does the paper report error bars suitably and correctly defined or other appropriate
information about the statistical significance of the experiments?
Answer: [NA]
Justification: The paper does not include experiments.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The authors should answer "Yes" if the results are accompanied by error bars, confi-
dence intervals, or statistical significance tests, at least for the experiments that support
the main claims of the paper.
•The factors of variability that the error bars are capturing should be clearly stated (for
example, train/test split, initialization, random drawing of some parameter, or overall
run with given experimental conditions).
•The method for calculating the error bars should be explained (closed form formula,
call to a library function, bootstrap, etc.)
21• The assumptions made should be given (e.g., Normally distributed errors).
•It should be clear whether the error bar is the standard deviation or the standard error
of the mean.
•It is OK to report 1-sigma error bars, but one should state it. The authors should
preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis
of Normality of errors is not verified.
•For asymmetric distributions, the authors should be careful not to show in tables or
figures symmetric error bars that would yield results that are out of range (e.g. negative
error rates).
•If error bars are reported in tables or plots, The authors should explain in the text how
they were calculated and reference the corresponding figures or tables in the text.
8.Experiments Compute Resources
Question: For each experiment, does the paper provide sufficient information on the com-
puter resources (type of compute workers, memory, time of execution) needed to reproduce
the experiments?
Answer: [NA]
Justification: The paper does not include experiments.
Guidelines:
• The answer NA means that the paper does not include experiments.
•The paper should indicate the type of compute workers CPU or GPU, internal cluster,
or cloud provider, including relevant memory and storage.
•The paper should provide the amount of compute required for each of the individual
experimental runs as well as estimate the total compute.
•The paper should disclose whether the full research project required more compute
than the experiments reported in the paper (e.g., preliminary or failed experiments that
didn’t make it into the paper).
9.Code Of Ethics
Question: Does the research conducted in the paper conform, in every respect, with the
NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines ?
Answer: [Yes]
Justification: The research conducted in the paper conform, in every respect, with the
NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines .
Guidelines:
•The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.
•If the authors answer No, they should explain the special circumstances that require a
deviation from the Code of Ethics.
•The authors should make sure to preserve anonymity (e.g., if there is a special consid-
eration due to laws or regulations in their jurisdiction).
10.Broader Impacts
Question: Does the paper discuss both potential positive societal impacts and negative
societal impacts of the work performed?
Answer: [NA]
Justification: There is no societal impact of the work performed.
Guidelines:
• The answer NA means that there is no societal impact of the work performed.
•If the authors answer NA or No, they should explain why their work has no societal
impact or why the paper does not address societal impact.
•Examples of negative societal impacts include potential malicious or unintended uses
(e.g., disinformation, generating fake profiles, surveillance), fairness considerations
(e.g., deployment of technologies that could make decisions that unfairly impact specific
groups), privacy considerations, and security considerations.
22•The conference expects that many papers will be foundational research and not tied
to particular applications, let alone deployments. However, if there is a direct path to
any negative applications, the authors should point it out. For example, it is legitimate
to point out that an improvement in the quality of generative models could be used to
generate deepfakes for disinformation. On the other hand, it is not needed to point out
that a generic algorithm for optimizing neural networks could enable people to train
models that generate Deepfakes faster.
•The authors should consider possible harms that could arise when the technology is
being used as intended and functioning correctly, harms that could arise when the
technology is being used as intended but gives incorrect results, and harms following
from (intentional or unintentional) misuse of the technology.
•If there are negative societal impacts, the authors could also discuss possible mitigation
strategies (e.g., gated release of models, providing defenses in addition to attacks,
mechanisms for monitoring misuse, mechanisms to monitor how a system learns from
feedback over time, improving the efficiency and accessibility of ML).
11.Safeguards
Question: Does the paper describe safeguards that have been put in place for responsible
release of data or models that have a high risk for misuse (e.g., pretrained language models,
image generators, or scraped datasets)?
Answer: [NA]
Justification: The paper poses no such risks.
Guidelines:
• The answer NA means that the paper poses no such risks.
•Released models that have a high risk for misuse or dual-use should be released with
necessary safeguards to allow for controlled use of the model, for example by requiring
that users adhere to usage guidelines or restrictions to access the model or implementing
safety filters.
•Datasets that have been scraped from the Internet could pose safety risks. The authors
should describe how they avoided releasing unsafe images.
•We recognize that providing effective safeguards is challenging, and many papers do
not require this, but we encourage authors to take this into account and make a best
faith effort.
12.Licenses for existing assets
Question: Are the creators or original owners of assets (e.g., code, data, models), used in
the paper, properly credited and are the license and terms of use explicitly mentioned and
properly respected?
Answer: [NA]
Justification: The paper does not use existing assets.
Guidelines:
• The answer NA means that the paper does not use existing assets.
• The authors should cite the original paper that produced the code package or dataset.
•The authors should state which version of the asset is used and, if possible, include a
URL.
• The name of the license (e.g., CC-BY 4.0) should be included for each asset.
•For scraped data from a particular source (e.g., website), the copyright and terms of
service of that source should be provided.
•If assets are released, the license, copyright information, and terms of use in the
package should be provided. For popular datasets, paperswithcode.com/datasets
has curated licenses for some datasets. Their licensing guide can help determine the
license of a dataset.
•For existing datasets that are re-packaged, both the original license and the license of
the derived asset (if it has changed) should be provided.
23•If this information is not available online, the authors are encouraged to reach out to
the asset’s creators.
13.New Assets
Question: Are new assets introduced in the paper well documented and is the documentation
provided alongside the assets?
Answer: [NA]
Justification: The paper does not release new assets.
Guidelines:
• The answer NA means that the paper does not release new assets.
•Researchers should communicate the details of the dataset/code/model as part of their
submissions via structured templates. This includes details about training, license,
limitations, etc.
•The paper should discuss whether and how consent was obtained from people whose
asset is used.
•At submission time, remember to anonymize your assets (if applicable). You can either
create an anonymized URL or include an anonymized zip file.
14.Crowdsourcing and Research with Human Subjects
Question: For crowdsourcing experiments and research with human subjects, does the paper
include the full text of instructions given to participants and screenshots, if applicable, as
well as details about compensation (if any)?
Answer: [NA]
Justification: The paper does not involve crowdsourcing nor research with human subjects.
Guidelines:
•The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
•Including this information in the supplemental material is fine, but if the main contribu-
tion of the paper involves human subjects, then as much detail as possible should be
included in the main paper.
•According to the NeurIPS Code of Ethics, workers involved in data collection, curation,
or other labor should be paid at least the minimum wage in the country of the data
collector.
15.Institutional Review Board (IRB) Approvals or Equivalent for Research with Human
Subjects
Question: Does the paper describe potential risks incurred by study participants, whether
such risks were disclosed to the subjects, and whether Institutional Review Board (IRB)
approvals (or an equivalent approval/review based on the requirements of your country or
institution) were obtained?
Answer: [NA]
Justification: The paper does not involve crowdsourcing nor research with human subjects.
Guidelines:
•The answer NA means that the paper does not involve crowdsourcing nor research with
human subjects.
•Depending on the country in which research is conducted, IRB approval (or equivalent)
may be required for any human subjects research. If you obtained IRB approval, you
should clearly state this in the paper.
•We recognize that the procedures for this may vary significantly between institutions
and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the
guidelines for their institution.
•For initial submissions, do not include any information that would break anonymity (if
applicable), such as the institution conducting the review.
24